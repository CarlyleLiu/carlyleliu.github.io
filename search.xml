<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>designedPatterns-observerMethod</title>
    <url>/2019/07/31/Designed-Patterns-Observer/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>意图<br>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象<br>都得到通知并被自动更新。</p>
</li>
<li><p>别名<br>依赖(Dependents), 发布-订阅( P u b l i s h - S u b s c r i b e )</p>
</li>
<li><p>动机<br>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一<br>致性。我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了它们的可重用性。</p>
</li>
<li><p>适用性<br>在以下任一情况下可以使用观察者模式 :<br>• 当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对<br>象中以使它们可以各自独立地改变和复用。<br>• 当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。<br>• 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些<br>对象是紧密耦合的。</p>
</li>
</ol>
<p><img src="/picture/observerMethod.png" alt="观察者模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Subject;</span><br><span class="line">class Observer&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Update() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Subject&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void AddObserver(Observer* o)=0;</span><br><span class="line">    virtual void DelObserver(Observer* o)=0;</span><br><span class="line">    virtual void setState(int a) = 0;</span><br><span class="line">    virtual int getState() = 0;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class ConcreteSubject : public Subject &#123;</span><br><span class="line">public:</span><br><span class="line">    void AddObserver(Observer* o) override</span><br><span class="line">    &#123;</span><br><span class="line">        l.push_back(o);</span><br><span class="line">    &#125;</span><br><span class="line">    void DelObserver(Observer* o) override</span><br><span class="line">    &#123;</span><br><span class="line">        l.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    void setState(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        state = a;</span><br><span class="line">        NotifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    int getState() override</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void NotifyAll()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(auto item : l)</span><br><span class="line">        &#123;</span><br><span class="line">            item-&gt;Update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int state = 0;</span><br><span class="line">    std::list&lt;Observer *&gt; l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObserverA:public  Observer&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit ObserverA(Subject *subject1)</span><br><span class="line">    &#123;</span><br><span class="line">        subject = subject1;</span><br><span class="line">        this-&gt;subject-&gt;AddObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void Update() override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Update A After Subject State Changed To &quot;</span>&lt;&lt;<span class="string">subject-&gt;getState()&lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string">    Subject *subject</span>;</span><br><span class="line">&#125;;</span><br><span class="line">class ObserverB:public  Observer&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit ObserverB(Subject *subject1)</span><br><span class="line">    &#123;</span><br><span class="line">        subject = subject1;</span><br><span class="line">        this-&gt;subject-&gt;AddObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void Update() override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Update B After Subject State Changed To &quot;</span>&lt;&lt;<span class="string">subject-&gt;getState()&lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string">    Subject *subject</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Subject *subject = new ConcreteSubject();</span><br><span class="line">    Observer *a = new ObserverA(subject);</span><br><span class="line">    Observer *b = new ObserverB(subject);</span><br><span class="line"></span><br><span class="line">    subject-&gt;setState(22);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;------------------------------------------&quot;</span>&lt;&lt;<span class="string">std::endl;</span></span><br><span class="line"><span class="string">    subject-&gt;setState(35);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* Copyright (c) 2019 Robot Limited</span><br><span class="line">*</span><br><span class="line">* SPDX-License-Identifier: Apache-2.0</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef __INC_observer_h__</span></span><br><span class="line"><span class="comment">#define __INC_observer_h__</span></span><br><span class="line"></span><br><span class="line">/* define object */</span><br><span class="line">typedef struct _object</span><br><span class="line">&#123;</span><br><span class="line">   sys_slist_t observer_list;</span><br><span class="line"></span><br><span class="line">   /* Add your data to here */</span><br><span class="line">   void*	private_data;</span><br><span class="line">   /* end */</span><br><span class="line"></span><br><span class="line">   void (*notify)(struct _object* p_object);</span><br><span class="line">&#125;s_object;</span><br><span class="line"></span><br><span class="line">/* define observer struct */</span><br><span class="line">typedef struct _observer &#123;</span><br><span class="line">	sys_snode_t		node;</span><br><span class="line">	void*			private_data;</span><br><span class="line">	void (*update)(struct _observer* p_observer);</span><br><span class="line">	void (*register_to_object)(s_object* p_object);</span><br><span class="line">    void (*unregister_to_object)(s_object* p_object);</span><br><span class="line">&#125;s_observer; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Register a observer instance to object</span><br><span class="line"> *</span><br><span class="line"> * @details That will <span class="built_in">bind</span> a obserber to object.object have a single list this</span><br><span class="line"> * @details will append observer<span class="string">&#x27;s node to this list.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @param p_observer A pointer to a observer,it will be join a object</span></span><br><span class="line"><span class="string"> * @param p_object object will be join</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @return None</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static inline void register_to_object(s_observer* p_observer, s_object* p_object)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	assert(NULL != p_observer &amp;&amp; NULL != p_object);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	sys_slist_append(&amp;p_object-&gt;observer_list, &amp;p_observer-&gt;node);</span></span><br><span class="line"><span class="string">&#125;      </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * @brief Unregister a observer instance to object</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @details That will unbind a obserber to object.object have a single list this</span></span><br><span class="line"><span class="string"> * @details will remove observer&#x27;</span>s node to this list.</span><br><span class="line"> *</span><br><span class="line"> * @param p_observer A pointer to a observer,it will be delete a object</span><br><span class="line"> * @param p_object object will be delete</span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">return</span> None</span><br><span class="line"> */</span><br><span class="line">static inline void unregister_to_object(s_observer* p_observer, s_object* p_object)</span><br><span class="line">&#123;</span><br><span class="line">	assert(NULL != p_observer &amp;&amp; NULL != p_object);</span><br><span class="line"></span><br><span class="line">	sys_slist_find_and_remove(&amp;p_object-&gt;observer_list, &amp;p_observer-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Notify  observer to update object<span class="string">&#x27;s data have motify</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @details That will ergodic object&#x27;</span>s slist to execute observer<span class="string">&#x27;s update function</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @param p_object object&#x27;</span>s data have modify</span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">return</span> None</span><br><span class="line"> */</span><br><span class="line">static inline void notify(s_object* p_object)</span><br><span class="line">&#123;</span><br><span class="line">	s_observer* p_observer;</span><br><span class="line"></span><br><span class="line">	assert(NULL != p_object);</span><br><span class="line"></span><br><span class="line">	SYS_SLIST_FOR_EACH_CONTAINER(&amp;p_object-&gt;observer_list, p_observer, node)&#123;</span><br><span class="line">		<span class="keyword">if</span>( p_observer-&gt;update ) &#123;</span><br><span class="line">			p_observer-&gt;update(p_observer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* define a object and initialize <span class="keyword">function</span> pointer */</span><br><span class="line"><span class="comment">#define OBJECT_DEFINE(__obj_name) 						\</span></span><br><span class="line">	struct _object __obj_name = &#123; 						\</span><br><span class="line">		.notify = notify,  								\</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">/* define a observer and initialize <span class="keyword">function</span> pointer */</span><br><span class="line"><span class="comment">#define OBSERVER_DEFINE(__obs_name) 					\</span></span><br><span class="line">	struct _observer __obs_name = &#123;						\</span><br><span class="line">		.register_to_object = register_to_object,		\</span><br><span class="line">		.unregister_to_object = unregister_to_object,	\</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在observer结构体中增加node节点成员，在object结构图中增加slist链表，并将node插入到链表，在object的数据更新时调用notify函数，该函数将遍历链表，得到各个observer结构图指针并调用其update函数实现observer数据更新（被动调用）。</p>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>observerMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>c++-base</title>
    <url>/2019/10/04/c-base/</url>
    <content><![CDATA[<h3 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Fraction&#123;</span><br><span class="line">public:</span><br><span class="line">	Fraction(int num,int den = 1):</span><br><span class="line">	m_numerator(num),</span><br><span class="line">	m_denominnator(den)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	operator double() const&#123;</span><br><span class="line">		<span class="built_in">return</span> (double)(m_numerator / m_denominnator);</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int m_numerator;    //分子</span><br><span class="line">	int m_denominnator; //分母</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fraction f(3,5);</span><br><span class="line">double d = 4 + f; //调用double()将f转换为0.6</span><br></pre></td></tr></table></figure>
<p>实际上做（）运算符的重载。</p>
<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Fraction&#123;</span><br><span class="line">public:</span><br><span class="line">	Fraction(int num,int den = 1):</span><br><span class="line">	m_numerator(num),</span><br><span class="line">	m_denominnator(den)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	operator double() const&#123;</span><br><span class="line">		<span class="built_in">return</span> (double)(m_numerator / m_denominnator);</span><br><span class="line">	&#125;</span><br><span class="line">	Fraction operator+(const Fraction&amp; f)&#123;</span><br><span class="line">		<span class="built_in">return</span> Fraction(...);</span><br><span class="line">	&#125; 	</span><br><span class="line">private:</span><br><span class="line">	int m_numerator;    //分子</span><br><span class="line">	int m_denominnator; //分母</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fraction f(3,5);</span><br><span class="line">Fraction d = f + 4; //4:调用none-explicit ctor 将4转化为Fraction(4,1)然后调用operator+</span><br><span class="line">					//f:可以将f转化为double这样就有歧义</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Fraction&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit Fraction(int num,int den = 1):</span><br><span class="line">	m_numerator(num),</span><br><span class="line">	m_denominnator(den)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	operator double() const&#123;</span><br><span class="line">		<span class="built_in">return</span> (double)(m_numerator / m_denominnator);</span><br><span class="line">	&#125;</span><br><span class="line">	Fraction operator+(const Fraction&amp; f)&#123;</span><br><span class="line">		<span class="built_in">return</span> Fraction(...);</span><br><span class="line">	&#125; 	</span><br><span class="line">private:</span><br><span class="line">	int m_numerator;    //分子</span><br><span class="line">	int m_denominnator; //分母</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样4就没办法转化为Fractor(4,1)了，这个关键字只对单参数class起作用</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><img src="/picture/shared_ptr.png" alt="shared_ptr"></p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p><img src="/picture/iterator.png" alt="iterator"></p>
<h3 id="模板特化和偏特化"><a href="#模板特化和偏特化" class="headerlink" title="模板特化和偏特化"></a>模板特化和偏特化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 特化 */</span><br><span class="line">template&lt;class key&gt;</span><br><span class="line">struct <span class="built_in">hash</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct <span class="built_in">hash</span>&lt;char&gt; &#123;</span><br><span class="line">	size_t operator()(char x) const &#123;<span class="built_in">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct <span class="built_in">hash</span>&lt;int&gt; &#123;</span><br><span class="line">	size_t operator()(int x) const &#123;<span class="built_in">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct <span class="built_in">hash</span>&lt;long&gt; &#123;</span><br><span class="line">	size_t operator()(long x) const &#123;<span class="built_in">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 偏特化 */</span><br><span class="line">template&lt;typename T,typename Alloc=...&gt;</span><br><span class="line">class vector &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename Alloc=...&gt;</span><br><span class="line">class vector&lt;bool,Alloc&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">template&lt;typename T,  </span><br><span class="line">         template &lt;typename T&gt;  </span><br><span class="line">             class Container </span><br><span class="line">	    &gt; </span><br><span class="line">class XCls </span><br><span class="line">&#123;  </span><br><span class="line">private:</span><br><span class="line"> 	Container&lt;T&gt; c; </span><br><span class="line">public:</span><br><span class="line">	<span class="function"><span class="title">XCls</span></span>() &#123; 							</span><br><span class="line">		...		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>派生类定义了一个函数与基类中的虚函数名字相同但是参数却不同，我们本来想overwrite基类中的虚函数，但是参数不同并不会报错而是两个独立的函数，这不是我们想要的，这个问题一般很难发现，因此可以通过overridr关键字来进行检查。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	virture void f1(int) const;</span><br><span class="line">	virture void f2();</span><br><span class="line">	void f3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">	void f1(int) const override; //正确f1与基类的f1匹配</span><br><span class="line">	void f2(int) override;       //错误，A中没有f2（int）</span><br><span class="line">	void f3() override;          //错误，f3()不是虚函数</span><br><span class="line">	void f4() override;          //错误 A中没有f4()函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>定义为final的函数，之后派生类的任何覆盖该函数的行为都是非法的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class C: public A &#123;</span><br><span class="line">public:</span><br><span class="line">	void f1(int) const final;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D: public C &#123;</span><br><span class="line">public:</span><br><span class="line">	void f1(int) const; //错误C中已经将f1声明为final了</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ProgramingLanguage</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c-language</title>
    <url>/2019/09/06/c-language/</url>
    <content><![CDATA[<h3 id="区别以下函数"><a href="#区别以下函数" class="headerlink" title="区别以下函数"></a>区别以下函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int* f();        //f为一个函数,函数返回值为指向整形的指针</span><br><span class="line">int (*f)();        //f为一个指针，该指针指向一个函数</span><br><span class="line">int* f[];        //f为一个数组，数组内容为指针</span><br><span class="line">int (*f[])();        //f为数组，数组的内容为指向函数的指针</span><br><span class="line">int*(*f[])();        //f为数组，数组的内容为指向函数的指针，该函数返回一个指向整形的指针</span><br><span class="line">int f()[];        //不存在</span><br><span class="line">int f[]();        //不存在</span><br></pre></td></tr></table></figure>
<h3 id="结构体-amp-位域"><a href="#结构体-amp-位域" class="headerlink" title="结构体&amp;位域"></a>结构体&amp;位域</h3><p>对数据位的充分利用，该例是定义一个32位数据该数据的第0位表示地址是否使用10位地址；第1-3位表示速度；第四位表示是否设置为主机模式，这样的设置对数据的每一位的利用率更高。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">union __deprecated dev_config &#123;</span><br><span class="line"> u32_t raw;</span><br><span class="line"> struct __bits &#123;</span><br><span class="line">  u32_t use_10_bit_addr : 1;</span><br><span class="line">  u32_t speed : 3;</span><br><span class="line">  u32_t is_master_device : 1;</span><br><span class="line">  u32_t reserved : 26;</span><br><span class="line"> &#125; bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define _SYSCALL_CONCAT(arg1, arg2) __SYSCALL_CONCAT(arg1, arg2)</span></span><br><span class="line"><span class="comment">#define __SYSCALL_CONCAT(arg1, arg2) ___SYSCALL_CONCAT(arg1, arg2)</span></span><br><span class="line"><span class="comment">#define ___SYSCALL_CONCAT(arg1, arg2) arg1##arg2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define _SYSCALL_NARG(...) __SYSCALL_NARG(__VA_ARGS__, __SYSCALL_RSEQ_N())</span></span><br><span class="line"><span class="comment">#define __SYSCALL_NARG(...) __SYSCALL_ARG_N(__VA_ARGS__)</span></span><br><span class="line"><span class="comment">#define __SYSCALL_ARG_N(_1, _2, _3, _4, _5, _6, _7, N, ...) N</span></span><br><span class="line"><span class="comment">#define __SYSCALL_RSEQ_N() 6, 5, 4, 3, 2, 1, 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define Z_SYSCALL_HANDLER(...) \</span></span><br><span class="line"> _SYSCALL_CONCAT(__SYSCALL_HANDLER, \</span><br><span class="line">   _SYSCALL_NARG(__VA_ARGS__))(__VA_ARGS__)</span><br></pre></td></tr></table></figure>
<h3 id="container-of宏"><a href="#container-of宏" class="headerlink" title="container_of宏"></a>container_of宏</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define container_of(ptr, type, member) (&#123; \</span></span><br><span class="line">const typeof( ((<span class="built_in">type</span> *)0)-&gt;member ) *__mptr = (ptr); \</span><br><span class="line">(<span class="built_in">type</span> *)( (char *)__mptr - offsetof(<span class="built_in">type</span>,member) );&#125;)</span><br></pre></td></tr></table></figure>
<p>可以通过结构体中的一个成员获得该结构体首地址。精髓在于定义该结构体并将其放到0地址处通过已知成员获得偏移从而计算出首地址</p>
<h3 id="builtin-expect"><a href="#builtin-expect" class="headerlink" title="__builtin_expect"></a>__builtin_expect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define likely(x) __builtin_expect((bool)!!(x), true)</span><br><span class="line">#define unlikely(x) __builtin_expect((bool)!!(x), false)</span><br></pre></td></tr></table></figure>
<p>这个宏定义的作用是优化代码，减少指令跳转次数。<br>在实际使用中例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(  likely( x ) ) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当x为true的场景较多时可以优化代码减少跳转次数相反当x倾向于false时用unlikely，这个主要是cpu预取指相关内容</p>
]]></content>
      <categories>
        <category>ProgramingLanguage</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-strategyMethod</title>
    <url>/2019/10/08/designedPattern-Strategy/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>定义一系列的算法,把它们一个个封装起来 , 并且使它们可相互替换。本模式使得算法可独<br>立于使用它的客户而变化。</li>
<li>别名<br>政策（ P o l i c y）</li>
<li>动机<br>有许多算法可对一个正文流进行分行。将这些算法硬编进使用它们的类中是不可取的，<br>其原因如下:<br>• 需要换行功能的客户程序如果直接包含换行算法代码的话将会变得复杂，这使得客户程<br>序庞大并且难以维护 , 尤其当其需要支持多种换行算法时问题会更加严重。<br>• 不同的时候需要不同的算法，我们不想支持我们并不使用的换行算法。<br>• 当换行功能是客户程序的一个难以分割的成分时 ,增加新的换行算法或改变现有算法将<br>十分困难。<br>我们可以定义一些类来封装不同的换行算法，从而避免这些问题。一个以这种方法封装<br>的算法称为一个策略( s t r a t e g y )，</li>
<li>适用性<br>当存在以下情况时使用 S t r a t e g y模式<br>• 许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一<br>个类的方法。<br>• 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的<br>算法。当这些变体实现为一个算法的类层次时 [ H O 8 7 ] ,可以使用策略模式。<br>• 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数<br>据结构。<br>• 一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。<br>将相关的条件分支移入它们各自的 S t r a t e g y类中以代替这些条件语句。</li>
</ol>
<p><img src="/picture/strategyMethod.png" alt="策略模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Strategy &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Interface() = 0;</span><br><span class="line">    virtual ~<span class="function"><span class="title">Strategy</span></span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStrategyA :public Strategy &#123;</span><br><span class="line">public:</span><br><span class="line">    void <span class="function"><span class="title">Interface</span></span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteStrategyA::Interface...&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class ConcreteStrategyB :public Strategy &#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    void Interface() &#123;</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;ConcreteStrategyB::Interface...&quot; &lt;&lt; endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Context &#123;</span><br><span class="line">public:</span><br><span class="line">    Context(Strategy *stg) &#123;</span><br><span class="line">        _stg = stg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="function"><span class="title">DoAction</span></span>() &#123;</span><br><span class="line">        _stg-&gt;Interface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Strategy *_stg; //这个地方使用基类的指针，可以指向派生类</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    Strategy *ps = new ConcreteStrategyA();</span><br><span class="line">    Context *pc = new Context(ps);</span><br><span class="line">    pc-&gt;DoAction();</span><br><span class="line"></span><br><span class="line">    delete pc;</span><br><span class="line">    delete ps;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _MoviePlay</span><br><span class="line">&#123;</span><br><span class="line">    struct _CommMoviePlay* pCommMoviePlay;</span><br><span class="line"> </span><br><span class="line">&#125;MoviePlay;</span><br><span class="line"> </span><br><span class="line">typedef struct _CommMoviePlay</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hFile;</span><br><span class="line">    void (*play)(HANDLE hFile);</span><br><span class="line"> </span><br><span class="line">&#125;CommMoviePlay;</span><br><span class="line"></span><br><span class="line">/* 统一的访问接口 */</span><br><span class="line">void play_movie_file(struct MoviePlay* pMoviePlay)</span><br><span class="line">&#123;</span><br><span class="line">    CommMoviePlay* pCommMoviePlay;</span><br><span class="line">    assert(NULL != pMoviePlay);</span><br><span class="line"> </span><br><span class="line">    pCommMoviePlay = pMoviePlay-&gt;pCommMoviePlay;</span><br><span class="line">    pCommMoviePlay-&gt;play(pCommMoviePlay-&gt;hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void play_avi_file(HANDLE hFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;play avi file!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void play_rmvb_file(HANDLE hFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;play rmvb file!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void play_mpeg_file(HANDLE hFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;play mpeg file!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式</li>
<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换</li>
<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销</li>
</ul>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>strategyMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-abstractFactory</title>
    <url>/2019/10/09/designedPattern-abstractFactory/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>意 图<br>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</li>
<li><p>别 名<br>K i t</p>
</li>
<li><p>动 机</p>
</li>
<li><p>适用性<br>在以下情况可以使用 Abstract Factory模式<br>• 一个系统要独立于它的产品的创建、组合和表示时。<br>• 一个系统要由多个产品系列中的一个来配置时。<br>• 当你要强调一系列相关的产品对象的设计以便进行联合使用时。<br>• 当你提供一个产品类库，而只想显示它们的接口而不是实现时。</p>
</li>
</ol>
<p><img src="/picture/abstractfactory.png" alt="抽象工厂"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//数据库访问有关的基类</span><br><span class="line">class IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IDBFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IDBConnection* CreateDBConnection()=0;</span><br><span class="line">    virtual IDBCommand* CreateDBCommand()=0;</span><br><span class="line">    virtual IDataReader* CreateDataReader()=0; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//支持SQL Server</span><br><span class="line">class SqlConnection: public IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">class SqlCommand: public IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">class SqlDataReader: public IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SqlDBFactory:public IDBFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IDBConnection* CreateDBConnection()=0;</span><br><span class="line">    virtual IDBCommand* CreateDBCommand()=0;</span><br><span class="line">    virtual IDataReader* CreateDataReader()=0;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//支持Oracle</span><br><span class="line">class OracleConnection: public IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OracleCommand: public IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OracleDataReader: public IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class EmployeeDAO&#123;</span><br><span class="line">    IDBFactory* dbFactory;  </span><br><span class="line">public:</span><br><span class="line">    vector&lt;EmployeeDO&gt; <span class="function"><span class="title">GetEmployees</span></span>()&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbFactory-&gt;CreateDBConnection();</span><br><span class="line">        connection-&gt;ConnectionString(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* <span class="built_in">command</span> =</span><br><span class="line">            dbFactory-&gt;CreateDBCommand();</span><br><span class="line">        <span class="built_in">command</span>-&gt;CommandText(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="built_in">command</span>-&gt;SetConnection(connection); //关联性</span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = <span class="built_in">command</span>-&gt;ExecuteReader(); //关联性</span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Apple</span><br><span class="line">&#123;</span><br><span class="line">    void (*print_apple)();</span><br><span class="line">&#125;Apple;</span><br><span class="line"> </span><br><span class="line">typedef struct _Grape</span><br><span class="line">&#123;</span><br><span class="line">    void (*print_grape)();</span><br><span class="line">&#125;Grape;</span><br><span class="line"></span><br><span class="line">void print_white_apple()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;white apple!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print_red_apple()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;red apple!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print_white_grape()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;white grape!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print_red_grape()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;red grape!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct _FruitShop</span><br><span class="line">&#123;</span><br><span class="line">    Apple* (*sell_apple)();</span><br><span class="line">    Apple* (*sell_grape)();</span><br><span class="line">&#125;FruitShop;</span><br><span class="line"></span><br><span class="line">Apple* sell_white_apple()</span><br><span class="line">&#123;</span><br><span class="line">    Apple* pApple = (Apple*) malloc(sizeof(Apple));</span><br><span class="line">    assert(NULL != pApple);</span><br><span class="line"> </span><br><span class="line">    pApple-&gt;print_apple = print_white_apple;</span><br><span class="line">    <span class="built_in">return</span> pApple;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Grape* sell_white_grape()</span><br><span class="line">&#123;</span><br><span class="line">    Grape* pGrape = (Grape*) malloc(sizeof(Grape));</span><br><span class="line">    assert(NULL != pGrape);</span><br><span class="line"> </span><br><span class="line">    pGrape-&gt;print_grape = print_white_grape;</span><br><span class="line">    <span class="built_in">return</span> pGrape;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">FruitShop* create_fruit_shop(int color)</span><br><span class="line">&#123;</span><br><span class="line">    FruitShop* pFruitShop = (FruitShop*) malloc(sizeof(FruitShop));</span><br><span class="line">    assert(NULL != pFruitShop);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(WHITE == color)</span><br><span class="line">    &#123;</span><br><span class="line">        pFruitShop-&gt;sell_apple = sell_white_apple;</span><br><span class="line">        pFruitShop-&gt;sell_grape = sell_white_grape;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pFruitShop-&gt;sell_apple = sell_red_apple;</span><br><span class="line">        pFruitShop-&gt;sell_grape = sell_red_grape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> pFruitShop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>abstractFactory</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-adaptMethod</title>
    <url>/2019/10/09/designedPattern-adaptMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>将一个类的接口转换成客户希望的另外一个接口。 A d a p t e r模式使得原本由于接口不兼容<br>而不能一起工作的那些类可以一起工作。</li>
<li>别名<br>包装器 Wr a p p e r。</li>
<li>动机<br>有时，为复用而设计的工具箱类不能够被复用的原因仅仅是因为它的接口与专业应用领<br>域所需要的接口不匹配。</li>
<li>适用性<br>以下情况使用A d a p t e r模式<br>• 你想使用一个已经存在的类，而它的接口不符合你的需求。<br>• 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口<br>可能不一定兼容的类）协同工作。<br>• （ 仅适用于对象 A d a p t e r）你想使用一些已经存在的子类，但是不可能对每一个都进行<br>子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
</ol>
<p><img src="/picture/adaptMethod.png" alt="适配器模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//目标接口（新接口）</span><br><span class="line">class ITarget&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void process()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//遗留接口（老接口）</span><br><span class="line">class IAdaptee&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo(int data)=0;</span><br><span class="line">    virtual int bar()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//遗留类型</span><br><span class="line">class OldClass: public IAdaptee&#123;</span><br><span class="line">    //....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对象适配器</span><br><span class="line">class Adapter: public ITarget&#123; //继承</span><br><span class="line">protected:</span><br><span class="line">    IAdaptee* pAdaptee;//组合</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    Adapter(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        this-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    virtual void <span class="function"><span class="title">process</span></span>()&#123;</span><br><span class="line">        int data=pAdaptee-&gt;bar();</span><br><span class="line">        pAdaptee-&gt;foo(data);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类适配器</span><br><span class="line">class Adapter: public ITarget,</span><br><span class="line">               protected OldClass&#123; //多继承               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    IAdaptee* pAdaptee=new OldClass();</span><br><span class="line"></span><br><span class="line">    ITarget* pTarget=new Adapter(pAdaptee);</span><br><span class="line">    pTarget-&gt;process();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class stack&#123;</span><br><span class="line">    deqeue container;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class queue&#123;</span><br><span class="line">    deqeue container; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class voltage_12v</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">voltage_12v</span></span>() &#123;&#125;</span><br><span class="line">    virtual ~<span class="function"><span class="title">voltage_12v</span></span>() &#123;&#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">request</span></span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class v220_to_v12</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">v220_to_v12</span></span>() &#123;&#125;</span><br><span class="line">    ~<span class="function"><span class="title">v220_to_v12</span></span>() &#123;&#125;</span><br><span class="line">    void <span class="function"><span class="title">voltage_transform_process</span></span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class adapter: public voltage_12v</span><br><span class="line">&#123;</span><br><span class="line">    v220_to_v12* pAdaptee;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">adapter</span></span>() &#123;&#125;</span><br><span class="line">    ~<span class="function"><span class="title">adapter</span></span>() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    void request() </span><br><span class="line">    &#123;</span><br><span class="line">        pAdaptee-&gt;voltage_transform_process();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typdef struct _Adaptee</span><br><span class="line">&#123;</span><br><span class="line">    void (*real_process)(struct _Adaptee* pAdaptee);</span><br><span class="line">&#125;Adaptee;</span><br><span class="line"> </span><br><span class="line">typedef struct _Adapter</span><br><span class="line">&#123;</span><br><span class="line">    void* pAdaptee;</span><br><span class="line">    void (*transform_process)(struct _Adapter* pAdapter);</span><br><span class="line"> </span><br><span class="line">&#125;Adapter;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>adaptMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-builderMethod</title>
    <url>/2019/10/09/designedPattern-builderMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>意图<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</li>
<li><p>动机</p>
</li>
<li><p>适用性<br>在以下情况使用B u i l d e r模式<br>• 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。<br>• 当构造过程必须允许被构造的对象有不同的表示时</p>
</li>
</ol>
<p><img src="/picture/builderMethod.png" alt="构建器"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class House&#123;</span><br><span class="line">    //....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HouseBuilder &#123;</span><br><span class="line">public:</span><br><span class="line">    House* <span class="function"><span class="title">GetResult</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> pHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~<span class="function"><span class="title">HouseBuilder</span></span>()&#123;&#125;</span><br><span class="line">protected:</span><br><span class="line">    </span><br><span class="line">    House* pHouse;</span><br><span class="line">	virtual void BuildPart1()=0;</span><br><span class="line">    virtual void BuildPart2()=0;</span><br><span class="line">    virtual void BuildPart3()=0;</span><br><span class="line">    virtual void BuildPart4()=0;</span><br><span class="line">    virtual void BuildPart5()=0;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">class StoneHouse: public House&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class StoneHouseBuilder: public HouseBuilder&#123;</span><br><span class="line">protected:</span><br><span class="line">    </span><br><span class="line">    virtual void <span class="function"><span class="title">BuildPart1</span></span>()&#123;</span><br><span class="line">        //pHouse-&gt;Part1 = ...;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">BuildPart2</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">BuildPart3</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">BuildPart4</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">BuildPart5</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HouseDirector&#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    </span><br><span class="line">    HouseDirector(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        this-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    House* <span class="function"><span class="title">Construct</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart1();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        bool flag=pHouseBuilder-&gt;BuildPart3();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart4();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart5();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> pHouseBuilder-&gt;GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _AssemblePersonalComputer</span><br><span class="line">&#123;</span><br><span class="line">    void (*assemble_cpu)();</span><br><span class="line">    void (*assemble_memory)();</span><br><span class="line">    void (*assemble_harddisk)();</span><br><span class="line"> </span><br><span class="line">&#125;AssemblePersonalComputer;</span><br><span class="line"></span><br><span class="line">void assemble_intel_cpu()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intel cpu!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void assemble_samsung_memory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;samsung memory!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void assemble_hitachi_harddisk()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hitachi harddisk!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void assemble_amd_cpu()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;amd cpu!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void assemble_kingston_memory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kingston memory!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void assmeble_western_digital_harddisk()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;western digital harddisk!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>abstractFactory</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-chainOfResposibility</title>
    <url>/2019/10/10/designedPattern-chainOfResposibility/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这<br>些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</li>
<li>动机<br>考虑一个图形用户界面中的上下文有关的帮助机制。用户在界面的任一部分上点击就可<br>以得到帮助信息，所提供的帮助依赖于点击的是界面的哪一部分以及其上下文。例如，对话<br>框中的按钮的帮助信息就可能和主窗口中类似的按钮不同。如果对那一部分界面没有特定的<br>帮助信息，那么帮助系统应该显示一个关于当前上下文的较一般的帮助信息 —比如说，整个对话框。</li>
<li>适用性<br>在以下条件下使用Responsibility 链：<br>• 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。<br>• 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br>• 可处理一个请求的对象集合应被动态指定。</li>
</ol>
<p><img src="/picture/chainofrespositily.png" alt="责任链"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum class RequestType</span><br><span class="line">&#123;</span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Reqest</span><br><span class="line">&#123;</span><br><span class="line">    string description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line">public:</span><br><span class="line">    Reqest(const string &amp; desc, RequestType <span class="built_in">type</span>) : description(desc), reqType(<span class="built_in">type</span>) &#123;&#125;</span><br><span class="line">    RequestType getReqType() const &#123; <span class="built_in">return</span> reqType; &#125;</span><br><span class="line">    const string&amp; getDescription() const &#123; <span class="built_in">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ChainHandler&#123;</span><br><span class="line">    </span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    void sendReqestToNextHandler(const Reqest &amp; req)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != nullptr)</span><br><span class="line">            nextChain-&gt;handle(req);</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    virtual bool canHandleRequest(const Reqest &amp; req) = 0;</span><br><span class="line">    virtual void processRequest(const Reqest &amp; req) = 0;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">ChainHandler</span></span>() &#123; nextChain = nullptr; &#125;</span><br><span class="line">    void setNextChain(ChainHandler *next) &#123; nextChain = next; &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    void handle(const Reqest &amp; req)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canHandleRequest(req))</span><br><span class="line">            processRequest(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sendReqestToNextHandler(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Handler1 : public ChainHandler&#123;</span><br><span class="line">protected:</span><br><span class="line">    bool canHandleRequest(const Reqest &amp; req) override</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> req.getReqType() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    void processRequest(const Reqest &amp; req) override</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; <span class="string">req.getDescription() &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">class Handler2 : public ChainHandler&#123;</span></span><br><span class="line"><span class="string">protected:</span></span><br><span class="line"><span class="string">    bool canHandleRequest(const Reqest &amp; req</span>) override</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> req.getReqType() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    void processRequest(const Reqest &amp; req) override</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; <span class="string">req.getDescription() &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Handler3 : public ChainHandler&#123;</span></span><br><span class="line"><span class="string">protected:</span></span><br><span class="line"><span class="string">    bool canHandleRequest(const Reqest &amp; req</span>) override</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> req.getReqType() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    void processRequest(const Reqest &amp; req) override</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; <span class="string">req.getDescription() &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()&#123;</span></span><br><span class="line"><span class="string">    Handler1 h1;</span></span><br><span class="line"><span class="string">    Handler2 h2;</span></span><br><span class="line"><span class="string">    Handler3 h3;</span></span><br><span class="line"><span class="string">    h1.setNextChain(&amp;h2);</span></span><br><span class="line"><span class="string">    h2.setNextChain(&amp;h3);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Reqest req</span>(<span class="string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3);</span><br><span class="line">    h1.handle(req);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Leader</span><br><span class="line">&#123;</span><br><span class="line">    struct _Leader* next;</span><br><span class="line">    int account;</span><br><span class="line">    </span><br><span class="line">    int (*request)(strcut _Leader* pLeader, int num); </span><br><span class="line">&#125;Leader;</span><br><span class="line"></span><br><span class="line">void set_account(struct _Leader* pLeader, int account)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pLeader);</span><br><span class="line">     </span><br><span class="line">    pLeader-&gt;account = account;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">void set_next_leader(const struct _Leader* pLeader, struct _Leader* next)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pLeader &amp;&amp; NULL != next);</span><br><span class="line"> </span><br><span class="line">    pLeader-&gt;next = next;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int request_for_manager(struct _Leader* pLeader, int num)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pLeader &amp;&amp; 0 != num);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(num &lt; 100000)</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pLeader-&gt;next) </span><br><span class="line">        <span class="built_in">return</span> pLeader-&gt;next-&gt;request(pLeader-&gt;next, num);   </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>chainOfResposibility</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-commandMethod</title>
    <url>/2019/10/10/designedPattern-commandMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</li>
<li>别名<br>动作( A c t i o n )，事务( Tr a n s a c t i o n )</li>
<li>动机<br>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。<br>例如，用户界面工具箱包括按钮和菜单这样的对象，它们执行请求响应用户输入。但工具箱<br>不能显式的在按钮或菜单中实现该请求，因为只有使用工具箱的应用知道该由哪个对象做哪<br>个操作。而工具箱的设计者无法知道请求的接受者或执行的操作。</li>
<li>适用性<br>当你有如下需求时，可使用 C o m m a n d模式：<br>• 像上面讨论的 M e n u I t e m对象那样，抽象出待执行的动作以参数化某对象。你可用过程<br>语言中的回调（ c a l l b a c k）函数表达这种参数化机制。所谓回调函数是指函数先在某处<br>注册，而它将在稍后某个需要的时候被调用。 C o m m a n d模式是回调机制的一个面向对<br>象的替代品。<br>• 在不同的时刻指定、排列和执行请求。一个 C o m m a n d对象可以有一个与初始请求无关<br>的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负<br>责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。<br>• 支持取消操作。 C o m m a n d的E x c u t e操作可在实施操作前将状态存储起来，在取消操作时<br>这个状态用来消除该操作的影响。 C o m m a n d接口必须添加一个 U n e x e c u t e操作，该操作<br>取消上一次 E x e c u t e调用的效果。执行的命令被存储在一个历史列表中。可通过向后和<br>向前遍历这一列表并分别调用 U n e x e c u t e和E x e c u t e来实现重数不限的“取消”和“重<br>做” 。<br>• 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在 C o m m a n d接口中添<br>加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过<br>程包括从磁盘中重新读入记录下来的命令并用 E x e c u t e操作重新执行它们。<br>• 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( t r a n s a c t i o n )<br>的信息系统中很常见。一个事务封装了对数据的一组变动。 C o m m a n d模式提供了对事<br>务进行建模的方法。 C o m m a n d有一个公共的接口，使得你可以用同一种方式调用所有<br>的事务。同时使用该模式也易于添加新事务以扩展系统。</li>
</ol>
<p><img src="/picture/commandMethod.png" alt="命令模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Command</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void execute() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteCommand1 : public Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line">public:</span><br><span class="line">    ConcreteCommand1(const string &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    void execute() override &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;1 process...&quot;</span> &lt;&lt; <span class="string">arg &lt;&lt;endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class ConcreteCommand2 : public Command</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    string arg</span>;</span><br><span class="line">public:</span><br><span class="line">    ConcreteCommand2(const string &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    void execute() override &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;#2 process...&quot;</span>&lt;&lt;<span class="string">arg&lt;&lt;endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;       </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">class MacroCommand : public Command</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    vector&lt;Command*&gt; commands;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    void addCommand(Command *c) &#123; commands.push_back(c); &#125;</span></span><br><span class="line"><span class="string">    void execute() override &#123;</span></span><br><span class="line"><span class="string">        for (auto &amp;c : commands) &#123;</span></span><br><span class="line"><span class="string">            c-&gt;execute();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ConcreteCommand1 command1(receiver, &quot;Arg ###&quot;);</span></span><br><span class="line"><span class="string">    ConcreteCommand2 command2(receiver, &quot;Arg $$$&quot;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    MacroCommand macro;</span></span><br><span class="line"><span class="string">    macro.addCommand(&amp;command1);</span></span><br><span class="line"><span class="string">    macro.addCommand(&amp;command2);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    macro.execute();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Post</span><br><span class="line">&#123;</span><br><span class="line">    void (*<span class="keyword">do</span>)(struct _Post* pPost);   </span><br><span class="line">&#125;Post;</span><br><span class="line"></span><br><span class="line">typedef struct _Command</span><br><span class="line">&#123;</span><br><span class="line">    void* pData;</span><br><span class="line">    void (*exe)(struct _Command* pCommand);</span><br><span class="line"> </span><br><span class="line">&#125;Command;</span><br><span class="line"> </span><br><span class="line">void post_exe(struct _Command* pCommand)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pCommand);</span><br><span class="line"> </span><br><span class="line">    (Post*)(pCommand-&gt;pData)-&gt;<span class="keyword">do</span>((Post*)(pCommand-&gt;pData));</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct _Boss</span><br><span class="line">&#123;</span><br><span class="line">    Command* pCommand;</span><br><span class="line">    void (*call)(struct _Boss* pBoss);</span><br><span class="line">&#125;Boss;</span><br><span class="line"> </span><br><span class="line">void boss_call(struct _Boss* pBoss)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pBoss);</span><br><span class="line"> </span><br><span class="line">    pBoss-&gt;pCommand-&gt;exe(pBoss-&gt;pCommand);</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>commandMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-compositeMethod</title>
    <url>/2019/10/10/designedPattern-compositeMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>将对象组合成树形结构以表示“部分 -整体”的层次结构。 C o m p o s i t e使得用户对单个对象<br>和组合对象的使用具有一致性。</li>
<li>动机<br>在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的组件创建复<br>杂的图表。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大<br>的组件。一个简单的实现方法是为 Te x t和L i n e这样的图元定义一些类，另外定义一些类作为这<br>些图元的容器类( C o n t a i n e r )。</li>
<li>适用性<br>以下情况使用C o m p o s i t e模式:<br>• 你想表示对象的部分 -整体层次结构。<br>• 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对<br>象。</li>
</ol>
<p><img src="/picture/compositeMethod.png" alt="组合模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;list&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void process() = 0;</span><br><span class="line">    virtual ~<span class="function"><span class="title">Component</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//树节点</span><br><span class="line">class Composite : public Component&#123;</span><br><span class="line">    </span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line">public:</span><br><span class="line">    Composite(const string &amp; s) : name(s) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void add(Component* element) &#123;</span><br><span class="line">        elements.push_back(element);</span><br><span class="line">    &#125;</span><br><span class="line">    void remove(Component* element)&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">process</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">        //1. process current node</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //2. process leaf nodes</span><br><span class="line">        <span class="keyword">for</span> (auto &amp;e : elements)</span><br><span class="line">            e-&gt;process(); //多态调用</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//叶子节点</span><br><span class="line">class Leaf : public Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">public:</span><br><span class="line">    Leaf(string s) : name(s) &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    void <span class="function"><span class="title">process</span></span>()&#123;</span><br><span class="line">        //process current node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Invoke(Component &amp; c)&#123;</span><br><span class="line">    //...</span><br><span class="line">    c.process();</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Composite root(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    Composite treeNode1(<span class="string">&quot;treeNode1&quot;</span>);</span><br><span class="line">    Composite treeNode2(<span class="string">&quot;treeNode2&quot;</span>);</span><br><span class="line">    Composite treeNode3(<span class="string">&quot;treeNode3&quot;</span>);</span><br><span class="line">    Composite treeNode4(<span class="string">&quot;treeNode4&quot;</span>);</span><br><span class="line">    Leaf leat1(<span class="string">&quot;left1&quot;</span>);</span><br><span class="line">    Leaf leat2(<span class="string">&quot;left2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    root.add(&amp;treeNode1);</span><br><span class="line">    treeNode1.add(&amp;treeNode2);</span><br><span class="line">    treeNode2.add(&amp;leaf1);</span><br><span class="line">    </span><br><span class="line">    root.add(&amp;treeNode3);</span><br><span class="line">    treeNode3.add(&amp;treeNode4);</span><br><span class="line">    treeNode4.add(&amp;leaf2);</span><br><span class="line">    </span><br><span class="line">    process(root);</span><br><span class="line">    process(leaf2);</span><br><span class="line">    process(treeNode3);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _NODE</span><br><span class="line">&#123;</span><br><span class="line">    void* pData;</span><br><span class="line">    struct _NODE* left;</span><br><span class="line">    struct _NODE* right;</span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">typedef struct _Object</span><br><span class="line">&#123;</span><br><span class="line">    struct _Object** ppObject;</span><br><span class="line">    int number;</span><br><span class="line">    void (*operate)(struct _Object* pObject);</span><br><span class="line"> </span><br><span class="line">&#125;Object;</span><br><span class="line"></span><br><span class="line">void operate_of_parent(struct _Object* pObject)</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    assert(NULL != pObject);</span><br><span class="line">    assert(NULL != pObject-&gt;ppObject &amp;&amp; 0 != pObject-&gt;number);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(index = 0; index &lt; pObject-&gt;number; index ++)</span><br><span class="line">    &#123;</span><br><span class="line">        pObject-&gt;ppObject[index]-&gt;operate(pObject-&gt;ppObject[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void operate_of_child(struct _Object* pObject)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pObject);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child node!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void process(struct Object* pObject)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pObject);</span><br><span class="line">    pObject-&gt;operate(pObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>compositeMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-decoratorMethod</title>
    <url>/2019/10/09/designedPattern-decoratorMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>动态地给一个对象添加一些额外的职责。就增加功能来说， D e c o r a t o r模式相比生成子类<br>更为灵活。</li>
<li>别名<br>包装器Wr a p p e r</li>
<li>动机<br>有时我们希望给某个对象而不是整个类添加一些功能。例如，一个图形用户界面工具箱<br>允许你对任意一个用户界面组件添加一些特性，例如边框，或是一些行为，例如窗口滚动。<br>使用继承机制是添加功能的一种有效途径，从其他类继承过来的边框特性可以被多个子<br>类的实例所使用。但这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加<br>边框的方式和时机。<br>一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框。我们称这个嵌<br>入的对象为装饰。这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明。<br>它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作</li>
<li>适用性<br>以下情况使用D e c o r a t o r模式<br>• 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。<br>• 处理那些可以撤消的职责。<br>• 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持<br>每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类<br>定义被隐藏，或类定义不能用于生成子类。</li>
</ol>
<p><img src="/picture/dectorateMethod.png" alt="装饰器模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//业务操作</span><br><span class="line">class Stream&#123;</span><br><span class="line"></span><br><span class="line">public：</span><br><span class="line">    virtual char Read(int number)=0;</span><br><span class="line">    virtual void Seek(int position)=0;</span><br><span class="line">    virtual void Write(char data)=0;</span><br><span class="line">    </span><br><span class="line">    virtual ~<span class="function"><span class="title">Stream</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//主体类</span><br><span class="line">class FileStream: public Stream&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual char Read(int number)&#123;</span><br><span class="line">        //读文件流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Seek(int position)&#123;</span><br><span class="line">        //定位文件流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Write(char data)&#123;</span><br><span class="line">        //写文件流</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class NetworkStream :public Stream&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual char Read(int number)&#123;</span><br><span class="line">        //读网络流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Seek(int position)&#123;</span><br><span class="line">        //定位网络流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Write(char data)&#123;</span><br><span class="line">        //写网络流</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MemoryStream :public Stream&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual char Read(int number)&#123;</span><br><span class="line">        //读内存流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Seek(int position)&#123;</span><br><span class="line">        //定位内存流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Write(char data)&#123;</span><br><span class="line">        //写内存流</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//扩展操作</span><br><span class="line">/* 既继承基类又包含基类指针，这个指针可以指向派生类 */</span><br><span class="line">class DecoratorStream: public Stream&#123;</span><br><span class="line">protected:</span><br><span class="line">    Stream* stream; //...</span><br><span class="line"></span><br><span class="line">    DecoratorStream(Stream * stm):stream(stm)&#123; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CryptoStream: public DecoratorStream &#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    CryptoStream(Stream* stm):DecoratorStream(stm)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    virtual char Read(int number)&#123;</span><br><span class="line">       </span><br><span class="line">        //额外的加密操作...</span><br><span class="line">        stream-&gt;Read(number);//读文件流</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Seek(int position)&#123;</span><br><span class="line">        //额外的加密操作...</span><br><span class="line">        stream::Seek(position);//定位文件流</span><br><span class="line">        //额外的加密操作...</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Write(byte data)&#123;</span><br><span class="line">        //额外的加密操作...</span><br><span class="line">        stream::Write(data);//写文件流</span><br><span class="line">        //额外的加密操作...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BufferedStream : public DecoratorStream&#123;</span><br><span class="line">    </span><br><span class="line">    Stream* stream;//...</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    BufferedStream(Stream* stm):DecoratorStream(stm)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">Process</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    //运行时装配</span><br><span class="line">    FileStream* s1=new FileStream();</span><br><span class="line">    </span><br><span class="line">    CryptoStream* s2=new CryptoStream(s1);</span><br><span class="line">    </span><br><span class="line">    BufferedStream* s3=new BufferedStream(s1);</span><br><span class="line">    </span><br><span class="line">    BufferedStream* s4=new BufferedStream(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”</li>
<li>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类</li>
<li>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义</li>
</ul>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Object</span><br><span class="line">&#123;</span><br><span class="line">    struct _Object* prev;</span><br><span class="line"> </span><br><span class="line">    void (*decorate)(struct _Object* pObject);</span><br><span class="line">&#125;Object;</span><br><span class="line"></span><br><span class="line">void decorate(struct _Object* pObject)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pObject);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(NULL != pObject-&gt;prev)</span><br><span class="line">        pObject-&gt;prev-&gt;decorate(pObject-&gt;prev);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;normal decorate!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>decoratorMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-facadeMethod</title>
    <url>/2019/10/09/designedPattern-facadeMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>为子系统中的一组接口提供一个一致的界面， F a c a d e模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li>动机<br>将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使<br>子系统间的通信和相互依赖关系达到最小。达到该目标的途径之一是就是引入一个 外观<br>（ f a c a d e）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。</li>
<li>适用性<br>在遇到以下情况使用 F a c a d e模式<br>• 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越<br>复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容<br>易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。<br>F a c a d e可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需<br>要更多的可定制性的用户可以越过 f a c a d e层。<br>• 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 f a c a d e将这个子系统与客<br>户以及其他的子系统分离，可以提高子系统的独立性和可移植性。<br>• 当你需要构建一个层次结构的子系统时，使用 f a c a d e模式定义子系统中每层的入口点。<br>如果子系统之间是相互依赖的，你可以让它们仅通过 f a c a d e进行通讯，从而简化了它们<br>之间的依赖关系。</li>
</ol>
<p><img src="/picture/facadeMethod.png" alt="外观模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class BuyTickets&#123; //Subsystem </span><br><span class="line">public:</span><br><span class="line">    void <span class="function"><span class="title">buying</span></span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;先买票&quot;</span>&lt;&lt;<span class="string">std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Travel&#123; //Subsystem </span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    void travling()&#123;</span></span><br><span class="line"><span class="string">        std</span>::cout&lt;&lt;<span class="string">&quot;游玩ing.........&quot;</span>&lt;&lt;<span class="string">std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class BackHome&#123; //Subsystem </span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    void back()&#123;</span></span><br><span class="line"><span class="string">        std</span>::cout&lt;&lt;<span class="string">&quot;回家了&quot;</span>&lt;&lt;<span class="string">std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Facade&#123; //Facade </span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    void working()&#123;</span></span><br><span class="line"><span class="string">       auto buy = new BuyTickets();</span></span><br><span class="line"><span class="string">       auto travel = new Travel();</span></span><br><span class="line"><span class="string">       auto backHome = new BackHome();</span></span><br><span class="line"><span class="string">       buy-&gt;buying();</span></span><br><span class="line"><span class="string">       travel-&gt;travling();</span></span><br><span class="line"><span class="string">       backHome-&gt;back();</span></span><br><span class="line"><span class="string">       delete buy;</span></span><br><span class="line"><span class="string">       delete travel;</span></span><br><span class="line"><span class="string">       delete backHome;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()//客户端调用</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    //一般我们这么做</span></span><br><span class="line"><span class="string">    auto buy = new BuyTickets();</span></span><br><span class="line"><span class="string">    auto travel = new Travel();</span></span><br><span class="line"><span class="string">    auto backHome = new BackHome();</span></span><br><span class="line"><span class="string">    buy-&gt;buying();</span></span><br><span class="line"><span class="string">    travel-&gt;travling();</span></span><br><span class="line"><span class="string">    backHome-&gt;back();</span></span><br><span class="line"><span class="string">    std</span>::cout&lt;&lt;<span class="string">&quot;---------------------------------------------&quot;</span>&lt;&lt;<span class="string">std::endl;</span></span><br><span class="line"><span class="string">    //外观模式这么做</span></span><br><span class="line"><span class="string">    Facade facade;</span></span><br><span class="line"><span class="string">    facade.working();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _FoodSteet</span><br><span class="line">&#123;</span><br><span class="line">    void (*eat)();</span><br><span class="line">&#125;FoodStreet;    </span><br><span class="line"> </span><br><span class="line">void eat()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eat here!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">typedef struct _ShopStreet</span><br><span class="line">&#123;</span><br><span class="line">    void (*buy)();</span><br><span class="line">&#125;ShopStreet;</span><br><span class="line"> </span><br><span class="line">void buy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buy here!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">typedef struct _BookStreet</span><br><span class="line">&#123;</span><br><span class="line">    void (*<span class="built_in">read</span>)();</span><br><span class="line">&#125;BookStreet;</span><br><span class="line"> </span><br><span class="line">void <span class="built_in">read</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read here&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct _Plaza</span><br><span class="line">&#123;</span><br><span class="line">    FoodStreet* pFoodStreet;</span><br><span class="line">    ShopStreet* pShopStreet;</span><br><span class="line">    BookStreet* pBookStreet;</span><br><span class="line"> </span><br><span class="line">    void (*play)(struct _Plaza* pPlaza); </span><br><span class="line">&#125;Plaza;</span><br><span class="line"> </span><br><span class="line">void play(struct _Plaza* pPlaza)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pPlaza);</span><br><span class="line"> </span><br><span class="line">    pPlaza-&gt;pFoodStreet-&gt;eat();</span><br><span class="line">    pPlaza-&gt;pShopStreet-&gt;buy();</span><br><span class="line">    pPlaza-&gt;pBookStreet-&gt;<span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>facadeMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-factoryMethod</title>
    <url>/2019/10/09/designedPattern-factoryMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>为子系统中的一组接口提供一个一致的界面， F a c a d e模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li>动机<br>将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使<br>子系统间的通信和相互依赖关系达到最小。达到该目标的途径之一是就是引入一个 外观<br>（ f a c a d e）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。</li>
<li>适用性<br>在遇到以下情况使用 F a c a d e模式<br>• 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越<br>复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容<br>易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。<br>F a c a d e可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需<br>要更多的可定制性的用户可以越过 f a c a d e层。<br>• 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 f a c a d e将这个子系统与客<br>户以及其他的子系统分离，可以提高子系统的独立性和可移植性。<br>• 当你需要构建一个层次结构的子系统时，使用 f a c a d e模式定义子系统中每层的入口点。<br>如果子系统之间是相互依赖的，你可以让它们仅通过 f a c a d e进行通讯，从而简化了它们<br>之间的依赖关系。</li>
</ol>
<p><img src="/picture/factoryMethod.png" alt="工厂方式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//抽象类</span><br><span class="line">class ISplitter&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void split()=0;</span><br><span class="line">    virtual ~<span class="function"><span class="title">ISplitter</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//工厂基类</span><br><span class="line">class SplitterFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ISplitter* CreateSplitter()=0;</span><br><span class="line">    virtual ~<span class="function"><span class="title">SplitterFactory</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//具体类</span><br><span class="line">class BinarySplitter : public ISplitter&#123;</span><br><span class="line">	...   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TxtSplitter: public ISplitter&#123;</span><br><span class="line"> 	...   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class PictureSplitter: public ISplitter&#123;</span><br><span class="line">	...   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VideoSplitter: public ISplitter&#123;</span><br><span class="line">	...   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//具体工厂</span><br><span class="line">class BinarySplitterFactory: public SplitterFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ISplitter* <span class="function"><span class="title">CreateSplitter</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> new BinarySplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TxtSplitterFactory: public SplitterFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ISplitter* <span class="function"><span class="title">CreateSplitter</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> new TxtSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class PictureSplitterFactory: public SplitterFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ISplitter* <span class="function"><span class="title">CreateSplitter</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> new PictureSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VideoSplitterFactory: public SplitterFactory&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ISplitter* <span class="function"><span class="title">CreateSplitter</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> new VideoSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MainForm : public Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;//工厂</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    MainForm(SplitterFactory*  factory)&#123;</span><br><span class="line">        this-&gt;factory=factory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	void <span class="function"><span class="title">Button1_Click</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">		ISplitter * splitter=</span><br><span class="line">            factory-&gt;CreateSplitter(); //多态new</span><br><span class="line">        </span><br><span class="line">        splitter-&gt;split();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导<br>致软件的脆弱</p>
</li>
<li><p>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好<br>地解决了这种紧耦合关系</p>
</li>
<li><p>Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同</p>
</li>
</ul>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Shoe</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">type</span>;</span><br><span class="line">    void (*print_shoe)(struct _Shoe*);</span><br><span class="line">&#125;Shoe;</span><br><span class="line"></span><br><span class="line">void print_leather_shoe(struct _Shoe* pShoe)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pShoe);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a leather show!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print_rubber_shoe(struct _Shoe* pShoe)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pShoe);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a rubber shoe!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEATHER_TYPE 0x01</span></span><br><span class="line"><span class="comment">#define RUBBER_TYPE  0x02</span></span><br><span class="line"> </span><br><span class="line">Shoe* manufacture_new_shoe(int <span class="built_in">type</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(LEATHER_TYPE == <span class="built_in">type</span> || RUBBER_TYPE == <span class="built_in">type</span>);</span><br><span class="line"> </span><br><span class="line">    Shoe* pShoe = (Shoe*)malloc(sizeof(Shoe));</span><br><span class="line">    assert(NULL != pShoe);</span><br><span class="line"> </span><br><span class="line">    memset(pShoe, 0, sizeof(Shoe));</span><br><span class="line">    <span class="keyword">if</span>(LEATHER_TYPE == <span class="built_in">type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pShoe-&gt;<span class="built_in">type</span> == LEATHER_TYPE;</span><br><span class="line">        pShoe-&gt;print_shoe = print_leather_shoe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pShoe-&gt;<span class="built_in">type</span> == RUBBER_TYPE;</span><br><span class="line">        pShoe-&gt;print_shoe = print_rubber_shoe;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> pShoe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>factoryMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-flyweightMethod</title>
    <url>/2019/10/09/designedPattern-flyweightMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>运用共享技术有效地支持大量细粒度的对象。</li>
<li>动机<br>有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。</li>
<li>适用性<br>F l y w e i g h t模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都<br>成立时使用F l y w e i g h t模式：<br>• 一个应用程序使用了大量的对象。<br>• 完全由于使用大量的对象，造成很大的存储开销。<br>• 对象的大多数状态都可变为外部状态。<br>• 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。<br>• 应用程序不依赖于对象标识。由于 F l y w e i g h t对象可以被共享，对于概念上明显有别的对<br>象，标识测试将返回真值。</li>
</ol>
<p><img src="/picture/flyweightMethod.png" alt="享元模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Font &#123;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    //unique object key</span><br><span class="line">    string key;</span><br><span class="line">    </span><br><span class="line">    //object state</span><br><span class="line">    //....</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Font(const string&amp; key)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ß</span><br><span class="line"></span><br><span class="line">class FontFactory&#123;</span><br><span class="line">private:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Font* GetFont(const string&amp; key)&#123;</span><br><span class="line"></span><br><span class="line">        map&lt;string,Font*&gt;::iterator item=fontPool.find(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(item!=footPool.end())&#123;</span><br><span class="line">            <span class="built_in">return</span> fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font = new Font(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="built_in">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">clear</span></span>()&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Font</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">type</span>;</span><br><span class="line">    int sequence;</span><br><span class="line">    int gap;</span><br><span class="line">    int lineDistance;</span><br><span class="line"> </span><br><span class="line">    void (*operate)(struct _Font* pFont);</span><br><span class="line"> </span><br><span class="line">&#125;Font;</span><br><span class="line"></span><br><span class="line">typedef struct _FontFactory</span><br><span class="line">&#123;</span><br><span class="line">    Font** ppFont;</span><br><span class="line">    int number;</span><br><span class="line">    int size;</span><br><span class="line"> </span><br><span class="line">    Font* GetFont(struct _FontFactory* pFontFactory, int <span class="built_in">type</span>, int sequence, int gap, int lineDistance);</span><br><span class="line">&#125;FontFactory;</span><br><span class="line"></span><br><span class="line">Font* GetFont(struct _FontFactory* pFontFactory, int <span class="built_in">type</span>, int sequence, int gap, int lineDistance)</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    Font* pFont;</span><br><span class="line">    Font* ppFont;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(NULL == pFontFactory)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(index = 0; index &lt; pFontFactory-&gt;number; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">type</span> != pFontFactory-&gt;ppFont[index]-&gt;<span class="built_in">type</span>)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(sequence != pFontFactory-&gt;ppFont[index]-&gt;sequence)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(gap != pFontFactory-&gt;ppFont[index]-&gt;gap)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(lineDistance != pFontFactory-&gt;ppFont[index]-&gt;lineDistance)</span><br><span class="line">             <span class="built_in">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">return</span> pFontFactory-&gt;ppFont[index];</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    pFont = (Font*)malloc(sizeof(Font));</span><br><span class="line">    assert(NULL != pFont);</span><br><span class="line">    pFont-&gt;<span class="built_in">type</span> = <span class="built_in">type</span>;</span><br><span class="line">    pFont-&gt;sequence = sequence;</span><br><span class="line">    pFont-&gt;gap = gap;</span><br><span class="line">    pFont-&gt;lineDistance = lineDistance;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pFontFactory-&gt; number &lt; pFontFactory-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        pFontFactory-&gt;ppFont[index] = pFont;</span><br><span class="line">        pFontFactory-&gt;number ++;</span><br><span class="line">        <span class="built_in">return</span> pFont;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ppFont = (Font**)malloc(sizeof(Font*) * pFontFactory-&gt;size * 2);</span><br><span class="line">    assert(NULL != ppFont);</span><br><span class="line">    memmove(ppFont, pFontFacoty-&gt;ppFont, pFontFactory-&gt;size);</span><br><span class="line">    free(pFontFactory-&gt;ppFont);</span><br><span class="line">    pFontFactory-&gt;size *= 2;</span><br><span class="line">    pFontFactory-&gt;number ++;</span><br><span class="line">    ppFontFactory-&gt;ppFont = ppFont;</span><br><span class="line">    <span class="built_in">return</span> pFont;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>flyweightMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-iteratorMethod</title>
    <url>/2019/10/10/designedPattern-iteratorMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。</li>
<li>别名<br>游标（ C u r s o r） 。</li>
<li>动机<br>一个聚合对象 , 如列表 (list), 应该提供一种方法来让别人可以访问它的元素，而又不需暴<br>露它的内部结构. 此外，针对不同的需要，可能要以不同的方式遍历这个列表。但是即使可以<br>预见到所需的那些遍历操作，你可能也不希望列表的接口中充斥着各种不同遍历的操作。有<br>时还可能需要在同一个表列上同时进行多个遍历。<br>迭代器模式都可帮你解决所有这些问题。这一模式的关键思想是将对列表的访问和遍历<br>从列表对象中分离出来并放入一个迭代器 （ i t e r a t o r）对象中。迭代器类定义了一个访问该列<br>表元素的接口。迭代器对象负责跟踪当前的元素 ; 即, 它知道哪些元素已经遍历过了。</li>
<li>适用性<br>迭代器模式可用来：<br>• 访问一个聚合对象的内容而无需暴露它的内部表示。<br>• 支持对聚合对象的多种遍历。<br>• 为遍历不同的聚合结构提供一个统一的接口 (即, 支持多态迭代)。</li>
</ol>
<p><img src="/picture/iteratorMethod.png" alt="迭代器"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Iterator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void first() = 0;</span><br><span class="line">    virtual void next() = 0;</span><br><span class="line">    virtual bool isDone() const = 0;</span><br><span class="line">    virtual T&amp; current() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MyCollection&#123;  </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;T&gt; <span class="function"><span class="title">GetIterator</span></span>()&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class CollectionIterator : public Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    CollectionIterator(const MyCollection&lt;T&gt; &amp; c): mc(c)&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    void first() override &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void next() override &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool isDone() const override&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; current() override&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void MyAlgorithm()</span><br><span class="line">&#123;</span><br><span class="line">    MyCollection&lt;int&gt; mc;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;int&gt; iter= mc.GetIterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (iter.first(); !iter.isDone(); iter.next())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">iter.current() &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Container</span><br><span class="line">&#123;</span><br><span class="line">    int* pData;</span><br><span class="line">    int size;</span><br><span class="line">    int length;</span><br><span class="line"> </span><br><span class="line">    Interator* (*create_new_interator)(struct _Container* pContainer);</span><br><span class="line">    int (*get_first)(struct _Container* pContainer);</span><br><span class="line">    int (*get_last)(struct _Container* pContainer);</span><br><span class="line"> </span><br><span class="line">&#125;Container;</span><br><span class="line"></span><br><span class="line">typedef struct _Interator</span><br><span class="line">&#123;</span><br><span class="line">    void* pVector;</span><br><span class="line">    int index;</span><br><span class="line"> </span><br><span class="line">    int(* get_first)(struct _Interator* pInterator); </span><br><span class="line">    int(* get_last)(struct _Interator* pInterator);</span><br><span class="line">&#125;Interator;</span><br><span class="line"></span><br><span class="line">int vector_get_first(struct _Container* pContainer)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pContainer);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> pContainer-&gt;pData[0];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int vector_get_last(struct _Container* pContainer)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pContainer);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">return</span> pContainer-&gt;pData[pContainer-&gt;size -1];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int vector_interator_get_first(struct _Interator* pInterator)</span><br><span class="line">&#123;</span><br><span class="line">    Container* pContainer;</span><br><span class="line">    assert(NULL != pInterator &amp;&amp; NULL != pInterator-&gt;pVector);</span><br><span class="line"> </span><br><span class="line">    pContainer = (struct _Container*) (pInterator-&gt;pVector);</span><br><span class="line">    <span class="built_in">return</span> pContainer -&gt;get_first(pContainer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int vector_interator_get_last(struct _Interator* pInterator)</span><br><span class="line">&#123;</span><br><span class="line">    Container* pContainer;</span><br><span class="line">    assert(NULL != pInterator &amp;&amp; NULL != pInterator-&gt;pVector);</span><br><span class="line"> </span><br><span class="line">    pContainer = (struct _Container*) (pInterator-&gt;pVector);</span><br><span class="line">    <span class="built_in">return</span> pContainer -&gt;get_last(pContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>iteratorMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-iterpreterMethod</title>
    <url>/2019/10/10/designedPattern-iterpreterMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示<br>来解释语言中的句子。</li>
<li>动机<br>如果一种特定类型的问题发生的频率足够高 , 那么可能就值得将该问题的各个实例表述为<br>一个简单语言中的句子。这样就可以构建一个解释器 , 该解释器通过解释这些句子来解决该问<br>题。</li>
<li>适用性<br>当有一个语言需要解释执行 , 并且你可将该语言中的句子表示为一个抽象语法树时，可使<br>用解释器模式。而当存在以下情况时该模式效果最好：<br>• 该文法简单对于复杂的文法 , 文法的类层次变得庞大而无法管理。此时语法分析程序生<br>成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式 , 这样可以节<br>省空间而且还可能节省时间。<br>• 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的 , 而是<br>首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种<br>情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</li>
</ol>
<p><img src="/picture/iterpreperMethod.png" alt="解释器"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Expression &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int interpreter(map&lt;char, int&gt; var)=0;</span><br><span class="line">    virtual ~<span class="function"><span class="title">Expression</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//变量表达式</span><br><span class="line">class VarExpression: public Expression &#123;</span><br><span class="line">    </span><br><span class="line">    char key;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    VarExpression(const char&amp; key) &#123;</span><br><span class="line">        this-&gt;key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int interpreter(map&lt;char, int&gt; var) override &#123;</span><br><span class="line">        <span class="built_in">return</span> var[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//符号表达式</span><br><span class="line">class SymbolExpression : public Expression &#123;</span><br><span class="line">    </span><br><span class="line">    // 运算符左右两个参数</span><br><span class="line">protected:</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    SymbolExpression( Expression* left,  Expression* right):</span><br><span class="line">        left(left),right(right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//加法运算</span><br><span class="line">class AddExpression : public SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    AddExpression(Expression* left, Expression* right):</span><br><span class="line">        SymbolExpression(left,right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int interpreter(map&lt;char, int&gt; var) override &#123;</span><br><span class="line">        <span class="built_in">return</span> left-&gt;interpreter(var) + right-&gt;interpreter(var);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//减法运算</span><br><span class="line">class SubExpression : public SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    SubExpression(Expression* left, Expression* right):</span><br><span class="line">        SymbolExpression(left,right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int interpreter(map&lt;char, int&gt; var) override &#123;</span><br><span class="line">        <span class="built_in">return</span> left-&gt;interpreter(var) - right-&gt;interpreter(var);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Expression*  analyse(string expStr) &#123;</span><br><span class="line">    </span><br><span class="line">    stack&lt;Expression*&gt; expStack;</span><br><span class="line">    Expression* left = nullptr;</span><br><span class="line">    Expression* right = nullptr;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;expStr.size(); i++) &#123;</span><br><span class="line">        switch(expStr[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                // 加法运算</span><br><span class="line">                left = expStack.top();</span><br><span class="line">                right = new VarExpression(expStr[++i]);</span><br><span class="line">                expStack.push(new AddExpression(left, right));</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                // 减法运算</span><br><span class="line">                left = expStack.top();</span><br><span class="line">                right = new VarExpression(expStr[++i]);</span><br><span class="line">                expStack.push(new SubExpression(left, right));</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                // 变量表达式</span><br><span class="line">                expStack.push(new VarExpression(expStr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Expression* expression = expStack.top();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(Expression* expression)&#123;</span><br><span class="line">    </span><br><span class="line">    //释放表达式树的节点内存...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    string expStr = <span class="string">&quot;a+b-c+d-e&quot;</span>;</span><br><span class="line">    map&lt;char, int&gt; var;</span><br><span class="line">    var.insert(make_pair(<span class="string">&#x27;a&#x27;</span>,5));</span><br><span class="line">    var.insert(make_pair(<span class="string">&#x27;b&#x27;</span>,2));</span><br><span class="line">    var.insert(make_pair(<span class="string">&#x27;c&#x27;</span>,1));</span><br><span class="line">    var.insert(make_pair(<span class="string">&#x27;d&#x27;</span>,6));</span><br><span class="line">    var.insert(make_pair(<span class="string">&#x27;e&#x27;</span>,10));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Expression* expression= analyse(expStr);</span><br><span class="line">    </span><br><span class="line">    int result=expression-&gt;interpreter(var);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">result&lt;&lt;endl;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    release(expression);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Interpret</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">type</span>;</span><br><span class="line">    void* (*process)(void* pData, int* <span class="built_in">type</span>, int* result);</span><br><span class="line"> </span><br><span class="line">&#125;Interpret;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define DIGITAL_TYPE 1</span></span><br><span class="line"><span class="comment">#define LETTER_TYPE  2</span></span><br><span class="line"><span class="comment">#define BOTTOM_LINE  3</span></span><br><span class="line"> </span><br><span class="line">void* digital_process(void* pData, int* <span class="built_in">type</span>, int* result)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* str;</span><br><span class="line">    assert(NULL != pData &amp;&amp; NULL != <span class="built_in">type</span> &amp;&amp; NULL != result);</span><br><span class="line"> </span><br><span class="line">    str = (UNT8*)pData;</span><br><span class="line">    <span class="keyword">while</span> (*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str ++;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        *<span class="built_in">type</span> = BOTTOM_TYPE;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;z&#x27;</span> || *str &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        *<span class="built_in">type</span> = LETTER_TYPE;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *result = FALSE;</span><br><span class="line">    <span class="built_in">return</span> NULL;            </span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line">void* letter_process(void* pData, int* <span class="built_in">type</span>, int* result)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* str;</span><br><span class="line">    assert(NULL != pData &amp;&amp; NULL != <span class="built_in">type</span> &amp;&amp; NULL != result);</span><br><span class="line"> </span><br><span class="line">    str = (UNT8*)pData;</span><br><span class="line">    <span class="keyword">while</span> (*str &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;z&#x27;</span> || *str &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str ++;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        *<span class="built_in">type</span> = BOTTOM_TYPE;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        *<span class="built_in">type</span> = DIGITAL_TYPE;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *result = FALSE;</span><br><span class="line">    <span class="built_in">return</span> NULL;            </span><br><span class="line">&#125;          </span><br><span class="line"> </span><br><span class="line">void* bottom_process(void* pData, int* <span class="built_in">type</span>, int* result)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* str;</span><br><span class="line">    assert(NULL != pData &amp;&amp; NULL != <span class="built_in">type</span> &amp;&amp; NULL != result);</span><br><span class="line"> </span><br><span class="line">    str = (UNT8*)pData;</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">&#x27;_&#x27;</span> == *str )</span><br><span class="line">    &#123;</span><br><span class="line">        str ++;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;z&#x27;</span> || *str &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        *<span class="built_in">type</span> = LETTER_TYPE;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = TRUE;</span><br><span class="line">        *<span class="built_in">type</span> = DIGITAL_TYPE;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *result = FALSE;</span><br><span class="line">    <span class="built_in">return</span> NULL;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>iterpreterMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-mediatorMethod</title>
    <url>/2019/10/09/designedPattern-mediatorMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从<br>而使其耦合松散，而且可以独立地改变它们之间的交互。</li>
<li>动机<br>面向对象设计鼓励将行为分布到各个对象中。这种分布可能会导致对象间有许多连接。<br>在最坏的情况下,每一个对象都知道其他所有对象。<br>虽然将一个系统分割成许多对象通常可以增强可复用性 , 但是对象间相互连接的激增又会<br>降低其可复用性。大量的相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作<br>—系统表现为一个不可分割的整体。而且 ,对系统的行为进行任何较大的改动都十分困难，<br>因为行为被分布在许多对象中。结果是 , 你可能不得不定义很多子类以定制系统的行为。</li>
<li>适用性<br>在下列情况下使用中介者模式 :<br>• 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理<br>解。<br>• 一个对象引用其他很多对象并且直接与这些对象通信 ,导致难以复用该对象。<br>• 想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li>
</ol>
<p><img src="/picture/mediatorMethod.png" alt="中介者模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum&#123;</span><br><span class="line">    Widget_A,</span><br><span class="line">    Widget_B,</span><br><span class="line">&#125;;</span><br><span class="line">class Widget;</span><br><span class="line">class Meadiator&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void showMsg(std::string msg,Widget *meadiator) = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Widget&#123;</span><br><span class="line">public:</span><br><span class="line">    Widget(int id_,Meadiator *meadiator1)</span><br><span class="line">    &#123;</span><br><span class="line">        id = id_;</span><br><span class="line">        meadiator = meadiator1;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void showMe(std::string) = 0;</span><br><span class="line">    int getId()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    Meadiator *meadiator;</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line">class WidgetA:public Widget&#123;</span><br><span class="line">public:</span><br><span class="line">    WidgetA(int id,Meadiator *meadiator1):Widget(id,meadiator1)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void showMe(std::string msg) override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;A: &quot;</span>&lt;&lt;<span class="string">msg&lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    void showMsg(std::string msg</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        meadiator-&gt;showMsg(msg,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">lass WidgetB:public Widget&#123;</span><br><span class="line">public:</span><br><span class="line">    WidgetB(int id,Meadiator *meadiator1):Widget(id,meadiator1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void showMe(std::string msg) override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;B: &quot;</span>&lt;&lt;<span class="string">msg&lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    void showMsg(std::string msg</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        meadiator-&gt;showMsg(msg,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class ConcreteMeadiator: public  Meadiator&#123;</span><br><span class="line">public:</span><br><span class="line">    void SetWidgetA(WidgetA *widgetA1)</span><br><span class="line">    &#123;</span><br><span class="line">        widgetA = widgetA1;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetWidgetB(WidgetB *widgetB1)</span><br><span class="line">    &#123;</span><br><span class="line">        widgetB = widgetB1;</span><br><span class="line">    &#125;</span><br><span class="line">    void showMsg(std::string msg,Widget *widget) override</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(widget-&gt;getId() == Widget_A)</span><br><span class="line">        &#123;</span><br><span class="line">            widgetA-&gt;showMe(msg);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(widget-&gt;getId() == Widget_B)</span><br><span class="line">        &#123;</span><br><span class="line">            widgetB-&gt;showMe(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    WidgetA *widgetA;</span><br><span class="line">    WidgetB *widgetB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ConcreteMeadiator meadiator;</span><br><span class="line">    auto *widgetA = new WidgetA(Widget_A,&amp;meadiator);</span><br><span class="line">    auto *widgetB = new WidgetB(Widget_B,&amp;meadiator);</span><br><span class="line">    meadiator.SetWidgetA(widgetA);</span><br><span class="line">    meadiator.SetWidgetB(widgetB);</span><br><span class="line">    widgetA-&gt;showMsg(<span class="string">&quot;你好啊！&quot;</span>);</span><br><span class="line">    widgetB-&gt;showMsg(<span class="string">&quot;我很好！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Mediator</span><br><span class="line">&#123;</span><br><span class="line">    People* man;</span><br><span class="line">    People* woman; </span><br><span class="line">&#125;Mediator;</span><br><span class="line"></span><br><span class="line">typedef struct _People</span><br><span class="line">&#123;</span><br><span class="line">    Mediator* pMediator;</span><br><span class="line"> </span><br><span class="line">    void (*request)(struct _People* pPeople);</span><br><span class="line">    void (*process)(struct _Peoplle* pPeople);</span><br><span class="line">&#125;People;</span><br><span class="line"></span><br><span class="line">void man_request(struct _People* pPeople)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pPeople);</span><br><span class="line"> </span><br><span class="line">    pPeople-&gt;pMediator-&gt;woman-&gt;process(pPeople-&gt;pMediator-&gt;woman);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void woman_request(struct _People* pPeople)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pPeople);</span><br><span class="line"> </span><br><span class="line">    pPeople-&gt;pMediator-&gt;man-&gt;process(pPeople-&gt;pMediator-&gt;man);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>mediatorMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-mementoMethod</title>
    <url>/2019/10/10/designedPattern-mementoMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br>这样以后就可将该对象恢复到原先保存的状态。</li>
<li>别名<br>To k e n</li>
<li>动机<br>有时有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复<br>过来，需要实现检查点和取消机制 , 而要实现这些机制，你必须事先将状态信息保存在某处，<br>这样才能将对象恢复到它们先前的状态。但是对象通常封装了其部分或所有的状态信息 , 使得<br>其状态不能被其他对象访问，也就不可能在该对象之外保存其状态。而暴露其内部状态又将<br>违反封装的原则，可能有损应用的可靠性和可扩展性。</li>
<li>适用性<br>在以下情况下使用备忘录模式：<br>• 必须保存一个对象在某一个时刻的 (部分)状态, 这样以后需要时它才能恢复到先前的状<br>态。<br>• 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象<br>的封装性。</li>
</ol>
<p><img src="/picture/mementoMethod.png" alt="备忘录模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Memento</span><br><span class="line">&#123;</span><br><span class="line">    string state;</span><br><span class="line">    //..</span><br><span class="line">public:</span><br><span class="line">    Memento(const string &amp; s) : state(s) &#123;&#125;</span><br><span class="line">    string getState() const &#123; <span class="built_in">return</span> state; &#125;</span><br><span class="line">    void setState(const string &amp; s) &#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Originator</span><br><span class="line">&#123;</span><br><span class="line">    string state;</span><br><span class="line">    //....</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">Originator</span></span>() &#123;&#125;</span><br><span class="line">    Memento <span class="function"><span class="title">createMomento</span></span>() &#123;</span><br><span class="line">        Memento m(state);</span><br><span class="line">        <span class="built_in">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    void setMomento(const Memento &amp; m) &#123;</span><br><span class="line">        state = m.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Originator orginator;</span><br><span class="line">    </span><br><span class="line">    //捕获对象状态，存储到备忘录</span><br><span class="line">    Memento mem = orginator.createMomento();</span><br><span class="line">    </span><br><span class="line">    //... 改变orginator状态</span><br><span class="line">    </span><br><span class="line">    //从备忘录中恢复</span><br><span class="line">    orginator.setMomento(memento);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Action</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">type</span>;</span><br><span class="line">    struct _Action* next;</span><br><span class="line"> </span><br><span class="line">    void* pData;</span><br><span class="line">    void (*process)(void* pData);</span><br><span class="line"> </span><br><span class="line">&#125;Action;</span><br><span class="line"></span><br><span class="line">typedef struct _Organizer</span><br><span class="line">&#123;</span><br><span class="line">    int number;</span><br><span class="line">    Action* pActionHead;</span><br><span class="line"> </span><br><span class="line">    Action* (*create)();</span><br><span class="line">    void (*restore)(struct _Organizer* pOrganizer); </span><br><span class="line">&#125;Organizer;</span><br><span class="line"></span><br><span class="line">void restore(struct _Organizer* pOrganizer)</span><br><span class="line">&#123;</span><br><span class="line">    Action* pHead;</span><br><span class="line">    assert(NULL != pOrganizer);</span><br><span class="line"> </span><br><span class="line">    pHead = pOrganizer-&gt;pActionHead;</span><br><span class="line">    pHead-&gt;process(pHead-&gt;pData);</span><br><span class="line">    pOrganizer-&gt;pActionHead = pHead-&gt;next;</span><br><span class="line">    pOrganizer-&gt;number --;</span><br><span class="line">    free(pHead);</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>mementoMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-proxyMethod</title>
    <url>/2019/10/09/designedPattern-proxyMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>别名<br>Surrogate</li>
<li>动机<br>对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行<br>创建和初始化。我们考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象（如<br>大型光栅图像）的创建开销很大。但是打开文档必须很迅速，因此我们在打开文档时应避免<br>一次性创建所有开销很大的对象。因为并非所有这些对象在文档中都同时可见，所以也没有<br>必要同时创建这些对象。</li>
<li>适用性<br>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 P r o x y模式。下面是一<br>些可以使用P r o x y模式常见情况：</li>
</ol>
<ol>
<li>远 程 代 理 （ Remote Proxy ） 为 一 个 对 象在 不 同 的 地 址 空间 提 供 局 部 代 表。<br>NEXTSTEP[Add94] 使用N X P r o x y类实现了这一目的。 Coplien[Cop92] 称这种代理为“大使”<br>（ A m b a s s a d o r） 。<br>2 ) 虚代理（ Virtual Proxy）根据需要创建开销很大的对象。在动机一节描述的 I m a g e P r o x y<br>就是这样一种代理的例子。</li>
<li>保护代理（ Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同<br>的访问权限的时候。例如，在 C h o i c e s操作系统[ C I R M 9 3 ]中K e m e l P r o x i e s为操作系统对象提供<br>了访问保护。<br>4 ) 智能指引 （ Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。<br>它的典型用途包括：<br>• 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它 (也称为S m a r t<br>P o i n t e r s[ E d e 9 2 ] )。<br>• 当第一次引用一个持久对象时，将它装入内存。<br>• 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ol>
<p><img src="/picture/proxyMethod.png" alt="代理模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class ISubject&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void process();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Proxy的设计</span><br><span class="line">class SubjectProxy: public ISubject&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void <span class="function"><span class="title">process</span></span>()&#123;</span><br><span class="line">        //对RealSubject的一种间接访问</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClientApp&#123;</span><br><span class="line">    </span><br><span class="line">    ISubject* subject;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">ClientApp</span></span>()&#123;</span><br><span class="line">        subject=new SubjectProxy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">DoTask</span></span>()&#123;</span><br><span class="line">        //...</span><br><span class="line">        subject-&gt;process();</span><br><span class="line">        </span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _PC_Client</span><br><span class="line">&#123;</span><br><span class="line">    void (*request)();</span><br><span class="line">&#125;PC_Client;</span><br><span class="line"> </span><br><span class="line">void ftp_request()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;request from ftp!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void http_request()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;request from http!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void smtp_request()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;request from smtp!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">typedef struct _Proxy</span><br><span class="line">&#123;</span><br><span class="line">    PC_Client* pClient;</span><br><span class="line">&#125;Proxy;</span><br><span class="line"> </span><br><span class="line">void process(Proxy* pProxy)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pProxy);</span><br><span class="line"> </span><br><span class="line">    pProxy-&gt;pClient-&gt;request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>proxyMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-singletonMethod</title>
    <url>/2019/10/09/designedPattern-singletonMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li>动机<br>对一些类来说，只有一个实例是很重要的。虽然系统中可以有许多打印机，但却只应该<br>有一个打印假脱机（ printer spooler） ，只应该有一个文件系统和一个窗口管理器。一个数字滤<br>波器只能有一个A / D转换器。一个会计系统只能专用于一个公司。<br>我们怎么样才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使<br>得一个对象可以被访问，但它不能防止你实例化多个对象。<br>一个更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可<br>以被创建（通过截取创建新对象的请求） ，并且它可以提供一个访问该实例的方法。这就是<br>S i n g l e t o n模式。</li>
<li>适用性<br>在下面的情况下可以使用 S i n g l e t o n模式<br>• 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br>• 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个<br>扩展的实例时。</li>
</ol>
<p><img src="/picture/singletonMethod.png" alt="单例模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">private:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(const Singleton&amp; other);</span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance();</span><br><span class="line">    static Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=nullptr;</span><br><span class="line"></span><br><span class="line">//线程非安全版本</span><br><span class="line">Singleton* Singleton::<span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == nullptr) &#123;</span><br><span class="line">        m_instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//C++ 11版本之后的跨平台实现 (volatile)</span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::<span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(std::memory_order_relaxed);</span><br><span class="line">    std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence</span><br><span class="line">    <span class="keyword">if</span> (tmp == nullptr) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</span><br><span class="line">        tmp = m_instance.load(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == nullptr) &#123;</span><br><span class="line">            tmp = new Singleton;</span><br><span class="line">            std::atomic_thread_fence(std::memory_order_release);//释放内存fence</span><br><span class="line">            m_instance.store(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _DATA</span><br><span class="line">&#123;</span><br><span class="line">    void* pData;</span><br><span class="line">&#125;DATA;</span><br><span class="line"> </span><br><span class="line">void* get_data()</span><br><span class="line">&#123;</span><br><span class="line">    static DATA* pData = NULL;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(NULL != pData)</span><br><span class="line">        <span class="built_in">return</span> pData;</span><br><span class="line"> </span><br><span class="line">    pData = (DATA*)malloc(sizeof(DATA));</span><br><span class="line">    assert(NULL != pData);</span><br><span class="line">    <span class="built_in">return</span> (void*)pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>singletonMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-stateMethod</title>
    <url>/2019/10/10/designedPattern-stateMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</li>
<li>别名<br>状态对象（ Objects for States）</li>
<li>动机</li>
<li>适用性<br>在下面的两种情况下均可使用 S t a t e模式:<br>• 一个对象的行为取决于它的状态 , 并且它必须在运行时刻根据状态改变它的行为。<br>• 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状<br>态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 S t a t e<br>模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对<br>象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li>
</ol>
<p><img src="/picture/stateMethod.png" alt="状态模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class NetworkState&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    NetworkState* pNext;</span><br><span class="line">    virtual void Operation1()=0;</span><br><span class="line">    virtual void Operation2()=0;</span><br><span class="line">    virtual void Operation3()=0;</span><br><span class="line"></span><br><span class="line">    virtual ~<span class="function"><span class="title">NetworkState</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OpenState :public NetworkState&#123;</span><br><span class="line">    </span><br><span class="line">    static NetworkState* m_instance;</span><br><span class="line">public:</span><br><span class="line">    static NetworkState* <span class="function"><span class="title">getInstance</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == nullptr) &#123;</span><br><span class="line">            m_instance = new OpenState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="function"><span class="title">Operation1</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">        //**********</span><br><span class="line">        pNext = CloseState::getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">Operation2</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">        //..........</span><br><span class="line">        pNext = ConnectState::getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">Operation3</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">        //$$$$$$$$$$</span><br><span class="line">        pNext = OpenState::getInstance();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CloseState:public NetworkState&#123; &#125;</span><br><span class="line">//...</span><br><span class="line">class NetworkProcessor&#123;</span><br><span class="line">    </span><br><span class="line">    NetworkState* pState;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    NetworkProcessor(NetworkState* pState)&#123;</span><br><span class="line">        </span><br><span class="line">        this-&gt;pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">Operation1</span></span>()&#123;</span><br><span class="line">        //...</span><br><span class="line">        pState-&gt;Operation1();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">Operation2</span></span>()&#123;</span><br><span class="line">        //...</span><br><span class="line">        pState-&gt;Operation2();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">Operation3</span></span>()&#123;</span><br><span class="line">        //...</span><br><span class="line">        pState-&gt;Operation3();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _State</span><br><span class="line">&#123;</span><br><span class="line">    void (*process)();</span><br><span class="line">    struct _State* (*change_state)();</span><br><span class="line"> </span><br><span class="line">&#125;State;</span><br><span class="line"></span><br><span class="line">void normal_process()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;normal process!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct _State* change_state()</span><br><span class="line">&#123;</span><br><span class="line">    State* pNextState = NULL;</span><br><span class="line"> </span><br><span class="line">    pNextState = (struct _State*)malloc(sizeof(struct _State));</span><br><span class="line">    assert(NULL != pNextState);</span><br><span class="line"> </span><br><span class="line">    pNextState -&gt;process = next_process;</span><br><span class="line">    pNextState -&gt;change_state = next_change_state;</span><br><span class="line">    <span class="built_in">return</span> pNextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct _Context</span><br><span class="line">&#123;</span><br><span class="line">    State* pState;</span><br><span class="line">    void (*change)(struct _Context* pContext);</span><br><span class="line">    </span><br><span class="line">&#125;Context;</span><br><span class="line"> </span><br><span class="line">void context_change(struct _Context* pContext)</span><br><span class="line">&#123;</span><br><span class="line">    State* pPre;</span><br><span class="line">    assert(NULL != pContext);</span><br><span class="line"> </span><br><span class="line">    pPre = pContext-&gt;pState;</span><br><span class="line">    pContext-&gt;pState = pPre-&gt;changeState();</span><br><span class="line">    free(pPre);</span><br><span class="line">    <span class="built_in">return</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>stateMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPatterns-bridgeMethod</title>
    <url>/2019/07/31/designedPatterns-bridge/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>
<li>别名<br>H a n d l e / B o d y</li>
<li>动机<br>当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，<br>而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它<br>的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。</li>
<li>适用性<br>以下一些情况使用B r i d g e模式:<br>• 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。 例如这种情况可能是因为，<br>在程序运行时刻实现部分应可以被选择或者切换。<br>• 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 B r i d g e模式使你<br>可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。<br>• 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。<br>• （ C + +）你想对客户完全隐藏抽象的实现部分。在 C + +中，类的表示在类接口中是可见<br>的。<br>• 正如在意图一节的第一个类图中所示的那样，有许多类要生成。这样一种类层次结构说<br>明你必须将一个对象分解成两个部分。 R u m b a u g h称这种类层次结构为“嵌套的普化”<br>（ nested generalizations） 。<br>• 你想在多个对象间共享实现（可能使用引用计数） ，但同时要求客户并不知道这一点。<br>一个简单的例子便是 C o p l i e n的S t r i n g类[ C o p 9 2 ]，在这个类中多个对象可以共享同一个字<br>符串表示（ S t r i n g R e p） 。</li>
</ol>
<p><img src="/picture/bridgeMethod.png" alt="桥模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Messager&#123;</span><br><span class="line">protected:</span><br><span class="line">     MessagerImp* messagerImp;//组合方式</span><br><span class="line">public:</span><br><span class="line">    virtual void Login(string username, string password)=0;</span><br><span class="line">    virtual void SendMessage(string message)=0;</span><br><span class="line">    virtual void SendPicture(Image image)=0;</span><br><span class="line">    </span><br><span class="line">    virtual ~<span class="function"><span class="title">Messager</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MessagerImp&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void PlaySound()=0;</span><br><span class="line">    virtual void DrawShape()=0;</span><br><span class="line">    virtual void WriteText()=0;</span><br><span class="line">    virtual void Connect()=0;</span><br><span class="line">    </span><br><span class="line">    virtual <span class="function"><span class="title">MessagerImp</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//平台实现 n</span><br><span class="line">class PCMessagerImp : public MessagerImp&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    virtual void <span class="function"><span class="title">PlaySound</span></span>()&#123;</span><br><span class="line">        //**********</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">DrawShape</span></span>()&#123;</span><br><span class="line">        //**********</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">WriteText</span></span>()&#123;</span><br><span class="line">        //**********</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">Connect</span></span>()&#123;</span><br><span class="line">        //**********</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MobileMessagerImp : public MessagerImp&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    virtual void <span class="function"><span class="title">PlaySound</span></span>()&#123;</span><br><span class="line">        //==========</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">DrawShape</span></span>()&#123;</span><br><span class="line">        //==========</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">WriteText</span></span>()&#123;</span><br><span class="line">        //==========</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">Connect</span></span>()&#123;</span><br><span class="line">        //==========</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//业务抽象 m</span><br><span class="line"></span><br><span class="line">//类的数目：1+n+m</span><br><span class="line"></span><br><span class="line">class MessagerLite :public Messager &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    virtual void Login(string username, string password)&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;Connect();</span><br><span class="line">        //........</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void SendMessage(string message)&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;WriteText();</span><br><span class="line">        //........</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void SendPicture(Image image)&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;DrawShape();</span><br><span class="line">        //........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MessagerPerfect  :public Messager &#123;</span><br><span class="line">     </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    virtual void Login(string username, string password)&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;PlaySound();</span><br><span class="line">        //********</span><br><span class="line">        messagerImp-&gt;Connect();</span><br><span class="line">        //........</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void SendMessage(string message)&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;PlaySound();</span><br><span class="line">        //********</span><br><span class="line">        messagerImp-&gt;WriteText();</span><br><span class="line">        //........</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void SendPicture(Image image)&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;PlaySound();</span><br><span class="line">        //********</span><br><span class="line">        messagerImp-&gt;DrawShape();</span><br><span class="line">        //........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">Process</span></span>()&#123;</span><br><span class="line">    //运行时装配</span><br><span class="line">    MessagerImp* mImp=new PCMessagerImp();</span><br><span class="line">    Messager *m =new Messager(mImp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们</li>
<li>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法</li>
<li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式</li>
</ul>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* Copyright (c) 2019 Robot Limited</span><br><span class="line">*</span><br><span class="line">* SPDX-License-Identifier: Apache-2.0</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef __INC_bridge_h__</span></span><br><span class="line"><span class="comment">#define __INC_bridge_h__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;include.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define USE_TB6612_DRIVER	1</span></span><br><span class="line"><span class="comment">#define USE_L298N_DRIVER	2</span></span><br><span class="line"></span><br><span class="line">/* define tb6612 driver */</span><br><span class="line">typedef struct _motor_dev_tb6612&#123;</span><br><span class="line">	void (*use)();</span><br><span class="line">&#125; s_motor_dev_tb6612;</span><br><span class="line"></span><br><span class="line">/* define l298n driver */</span><br><span class="line">typedef struct _motor_dev_l298n&#123;</span><br><span class="line">	void (*use)();</span><br><span class="line">&#125; s_motor_dev_tb6612;</span><br><span class="line"></span><br><span class="line">/* define motor driver adapt struct */</span><br><span class="line">typedef struct _motor_adapt&#123;</span><br><span class="line">	int <span class="built_in">type</span>;</span><br><span class="line">	void *motor_driver;</span><br><span class="line">&#125;s_motor_adapt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Request motor driver </span><br><span class="line"> *</span><br><span class="line"> * @details That will request motor driver, motor driver is so manay, </span><br><span class="line"> * @details we can chose one of them by bridge</span><br><span class="line"> *</span><br><span class="line"> * @param motor_adapt struct of motor adapt </span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">return</span> None</span><br><span class="line"> */</span><br><span class="line">static inline void motor_driver_request(struct _motor_adapt *motor_adapt)</span><br><span class="line">&#123;</span><br><span class="line">	assert(NULL != motor_adapt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(motor_adapt-&gt;<span class="built_in">type</span> == USE_TB6612_DRIVER)&#123;</span><br><span class="line">		<span class="built_in">return</span> (s_motor_dev_tb6612*)(motor_adapt-&gt;motor_driver)-&gt;use();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(motor_adapt-&gt;<span class="built_in">type</span> == USE_L298N_DRIVER)&#123;</span><br><span class="line">		<span class="built_in">return</span> (_motor_dev_l298n*)(motor_adapt-&gt;motor_driver)-&gt;use();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在有多种驱动器的时候可以通过一个bridge来选择具体使用哪一个驱动，motor adapt结构图里有两个成员，一个代表驱动类型，用来选择具体使用哪一个驱动器，另一个void* 指针来指向具体driver，实现获得对应driver的接口。</p>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>bridgeMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPattern-visitorMethod</title>
    <url>/2019/10/10/designedPattern-visitorMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提<br>下定义作用于这些元素的新操作。</li>
<li>动机<br>考虑一个编译器，它将源程序表示为一个抽象语法树。该编译器需在抽象语法树上实施<br>某些操作以进行“静态语义”分析，例如检查是否所有的变量都已经被定义了。它也需要生<br>成代码。因此它可能要定义许多操作以进行类型检查、代码优化、流程分析，检查变量是否<br>在使用前被赋初值，等等。此外，还可使用抽象语法树进行优美格式打印、程序重构、 c o d e<br>i n s t r u m e n t a t i o n以及对程序进行多种度量。</li>
<li>适用性<br>在下列情况下使用Vi s i t o r模式：<br>• 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于<br>其具体类的操作。<br>• 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操<br>作“污染”这些对象的类。 Vi s i t o r使得你可以将相关的操作集中起来定义在一个类中。<br>当该对象结构被很多应用共享时，用 Vi s i t o r模式让每个应用仅包含需要用到的操作。<br>• 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需<br>要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那<br>么可能还是在这些类中定义这些操作较好</li>
</ol>
<p><img src="/picture/visitorMethod.png" alt="访问者模式"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Visitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Element</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Func1() = 0;</span><br><span class="line">    </span><br><span class="line">    virtual void Func2(int data)=0;</span><br><span class="line">    virtual void Func3(int data)=0;</span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">    virtual ~<span class="function"><span class="title">Element</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ElementA : public Element</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Func1() override &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void Func2(int data) override&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ElementB : public Element</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Func1() override &#123;</span><br><span class="line">        //***</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void Func2(int data) override &#123;</span><br><span class="line">        //***</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Tofu</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">type</span>;</span><br><span class="line">    void (*eat)	(struct _Visitor* pVisitor, struct _Tofu* pTofu);</span><br><span class="line">&#125;Tofu;</span><br><span class="line"> </span><br><span class="line">typedef struct _Visitor</span><br><span class="line">&#123;</span><br><span class="line">    int region;</span><br><span class="line">    void (*process)(struct _Tofu* pTofu, struct _Visitor* pVisitor);</span><br><span class="line">&#125;Visitor;</span><br><span class="line"></span><br><span class="line">void eat(struct _Visitor* pVisitor, struct _Tofu* pTofu)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pVisitor &amp;&amp; NULL != pTofu);</span><br><span class="line"> </span><br><span class="line">    pVisitor-&gt;process(pTofu, pVisitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void process(struct _Tofu* pTofu, struct _Visitor* pVisitor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(NULL != pTofu &amp;&amp; NULL != pVisitor);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pTofu-&gt;<span class="built_in">type</span> == SPICY_FOOD &amp;&amp; pVisitor-&gt;region == WEST ||</span><br><span class="line">        pTofu-&gt;<span class="built_in">type</span> == STRONG_SMELL_FOOD &amp;&amp; pVisitor-&gt;region == EAST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I like this food!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I hate this food!\n&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>visitorMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>designedPatterns-templateMethod</title>
    <url>/2019/10/08/designedPatterns-templateMethod/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>意图<br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 Te m p l a t e M e t h o d使得子类<br>可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li>动机<br>考虑一个提供 A p p l i c a t i o n和D o c u m e n t类的应用框架。 A p p l i c a t i o n类负责打开一个已有的<br>以外部形式存储的文档，如一个文件。一旦一个文档中的信息从该文件中读出后，它就由一<br>个D o c u m e n t对象表示。</li>
<li>适用性<br>模板方法应用于下列情况：<br>• 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。<br>• 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是<br>O p d y k e和J o h n s o n所描述过的“重分解以一般化”的一个很好的例子 [ O J 9 3 ]。首先识别<br>现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的<br>操作的模板方法来替换这些不同的代码。<br>• 控制子类扩展。模板方法只在特定点调用“ h o o k”操作（参见效果一节） ，这样就只允<br>许在这些点进行扩展。</li>
</ol>
<p><img src="/picture/templateMethod.png" alt="结构"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>c++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class basic</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void <span class="function"><span class="title">basic</span></span>() &#123;&#125;</span><br><span class="line">    virtual ~<span class="function"><span class="title">basic</span></span>() &#123;&#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">step1</span></span>() &#123;&#125;</span><br><span class="line">    virtual void <span class="function"><span class="title">step2</span></span>() &#123;&#125;</span><br><span class="line">    void <span class="function"><span class="title">process</span></span>() &#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class derived : public basic</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">derived</span></span>() &#123;&#125;</span><br><span class="line">    ~<span class="function"><span class="title">derived</span></span>() &#123;&#125;</span><br><span class="line">    void <span class="function"><span class="title">step1</span></span>() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void <span class="function"><span class="title">step2</span></span>() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过virtual将函数的具体实现延迟到子类，实现在基类中调用子类实现，是一种晚绑定手段。</p>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _Basic</span><br><span class="line">&#123;</span><br><span class="line">    void* pData;</span><br><span class="line">    void (*step1) (struct _Basic* pBasic);</span><br><span class="line">    void (*step2) (struct _Basic* pBasic);</span><br><span class="line">    void (*process) (struct _Basic* pBasic);</span><br><span class="line">&#125;Basic;</span><br><span class="line"></span><br><span class="line">void process(struct _Basic* pBasic)</span><br><span class="line">&#123;</span><br><span class="line">    pBasic-&gt;step1(pBasic);</span><br><span class="line">    pBasic-&gt;step2(pBasic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在c语言环境下没有继承机制，通过函数指针操作来实现，具体函数定义可以延后</p>
]]></content>
      <categories>
        <category>Designed Patterns</category>
      </categories>
      <tags>
        <tag>templateMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>hardware-anamorphose</title>
    <url>/2018/06/06/hardware-anamorphose/</url>
    <content><![CDATA[<p><strong>频率失真和非线性失真同样都是使输出信号产生畸变，但两者在实质上是不同的。具体体现在以下两点：</strong><br>起因不同：频率失真是由电路中的线性电抗元件对不同信号频率的响应不同而引起，非线性失真由电路中非线性元件的非线性特性（如BJT、FET的特性曲线等）引起的。<br>结果不同：频率失真只会使各频率分量信号的比例关系和时间关系发生变化，或滤掉某些频率分量信号。但非线性失真，会将正弦波变为非正弦波，它不仅包含输入信号的频率成分，而且还产生许多新的谐波成分。<br>频率失真:<br>　　 频率失真：又称线性失真，是由于线性电抗元件所引起的,它包括幅度失真和相位失真。<br>　　 幅度失真：输入信号由基波和二次谐波组成，受放大电路带宽限制,基波增益较大，而二次谐波增益较小，输出电压波形产生了失真。<br>　　相位失真：当放大电路对不同频率的信号产生的相移不同刊产生频率失真了失真.。<br>非线性失真产生的主要原因来自两个方面：<br>①晶体管等特性的非线性；<br>②静态工作等位置设置的不合适或输入信号过大. 由于放大器件工作在非线性区而产生的非线性失真有4 种：饱和失真、截止失真、交越失真和不对称失真。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>anamorphose</tag>
      </tags>
  </entry>
  <entry>
    <title>hardware-jlinkPort</title>
    <url>/2018/05/06/hardware-jlinkPort/</url>
    <content><![CDATA[<p><img src="/picture/swd.png" alt="接口"><br><strong>SWD 和传统的调试方式区别</strong></p>
<ol>
<li><p>SWD 模式比 JTAG 在高速模式下面更加可靠。 在大数据量的情况下面 JTAG 下载程序会失败, 但是 SWD 发生的几率会小很多。基本使用 JTAG 仿真模式的情况下是可以直接使用 SWD 模式的, 只要你的仿真器支持。 所以推荐大家使用这个模式。</p>
</li>
<li><p>在大家 GPIO 刚好缺一个的时候, 可以使用 SWD 仿真, 这种模式支持更少的引脚。</p>
</li>
<li><p>在大家板子的体积有限的时候推荐使用 SWD 模式, 它需要的引脚少, 当然需要的 PCB 空间就小啦！ 比如你可以选择一个很小的 2.54 间距的 5 芯端子做仿真接口。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>swd jlink</tag>
      </tags>
  </entry>
  <entry>
    <title>hardware-usb</title>
    <url>/2018/04/06/hardware-usb/</url>
    <content><![CDATA[<p><strong>USB的DM、DP的上拉电阻分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usb有主从设备之分，主设备有：pc, 现在市面上的那些插u-disk即可播放mp3的“mp3”之类的，</span><br><span class="line"></span><br><span class="line">usb 信号是差分信号，信号线为D+, D-,。 在usb host 端， D+，D- 各接一个15kohm 的下拉电阻， 而在usb device端，这时就有高速低速设备的区别了。usb1.0, 1.1,2.0协议中都有定义高低速设备以满足不同情况的需求，这些在硬件上的区别就是：高速设备：d+ 接一个1.5kohm的上拉电阻，d-不接；低速设备则相反。</span><br><span class="line"></span><br><span class="line">这样当usb device 插入到host中时，如果是高速设备， 则d+被拉高，d-不变；低速设备则与之相反。这个上拉过程需要大概2.5us的时间，host这这个时间内便检测到了该信号，即可判断有device plug <span class="keyword">in</span>，和该device的类型，然后开始通讯，枚举。。。等。</span><br></pre></td></tr></table></figure>
<p><strong>USB OTG（on the go） 就是既可以做host又可以做client</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我们一般是作为client接受pc传输数据，作为host时可以接打印机直接把手机中的照片打印出来</span><br><span class="line"></span><br><span class="line">判别是host还是client是靠USB_ID这根pin</span><br><span class="line"></span><br><span class="line">当作为client时，USB_ID基本是悬空的（内部有上拉）</span><br><span class="line"></span><br><span class="line">如果侦测到USB_ID被拉低，就被认为是作为host，向外输出</span><br><span class="line"></span><br><span class="line">所以需要外部client设备把USB_ID拉低</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-archlinux-pacman</title>
    <url>/2019/09/06/linux-archlinux-pacman/</url>
    <content><![CDATA[<h3 id="archlinux下pacman和yaourt下载加速"><a href="#archlinux下pacman和yaourt下载加速" class="headerlink" title="archlinux下pacman和yaourt下载加速"></a>archlinux下pacman和yaourt下载加速</h3><p>各位用archlinux的朋友们都知道pacman能够调用外部下载工具来代替默认的wget来给pacman提速</p>
<p>比如将/etc/pacman.conf中XferCommand = /usr/bin/wget –passive-ftp -c -O %o %u注释掉</p>
<p>同时添加XferCommand = /usr/bin/axel -o %o %u</p>
<p>但arch中还有一个有力的工具yaourt，用它可以方便的从AUR上安装软件</p>
<p>但绝大多数情况下用其默认的wget下载时还是会觉得很慢</p>
<p>所以也很想把yaourt弄成多线程下载的</p>
<p>最开始翻了半天的yaourt源代码 怎么也找不到</p>
<p>快要放弃时才发现原来yaourt是调用makepkg来实现下载、编译、安装的</p>
<p>一下子就明了了</p>
<p>在/etc/makepkg.conf中有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DLAGENTS=(<span class="string">&#x27;ftp::/usr/bin/wget -c --passive-ftp -t 3 --waitretry=3 -O %o %u&#x27;</span></span><br><span class="line">          <span class="string">&#x27;http::/usr/bin/wget -c -t 3 --waitretry=3 -O %o %u&#x27;</span></span><br><span class="line">          <span class="string">&#x27;http::/usr/bin/axel -o %o %u&#x27;</span></span><br><span class="line">          <span class="string">&#x27;https::/usr/bin/wget -c -t 3 --waitretry=3 --no-check-certificate -O %o %u&#x27;</span></span><br><span class="line">          <span class="string">&#x27;rsync::/usr/bin/rsync -z %u %o&#x27;</span></span><br><span class="line">          <span class="string">&#x27;scp::/usr/bin/scp -C %u %o&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表明了各种协议所调用的下载工具</p>
<p>一般下载都是http的</p>
<p>所以我将http::/usr/bin/wget -c -t 3 –waitretry=3 -O %o %u改成了http::/usr/bin/axel -o %o %u</p>
<p>至此一切OK,来体验一下yaourt以及makepkg多线程的下载速度吧~</p>
<h3 id="1、签名-接受签名"><a href="#1、签名-接受签名" class="headerlink" title="1、签名( 接受签名)"></a>1、签名( 接受签名)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --recv-keys 签名</span><br></pre></td></tr></table></figure>
<h3 id="2、archlinux引导win10"><a href="#2、archlinux引导win10" class="headerlink" title="2、archlinux引导win10"></a>2、archlinux引导win10</h3><p>安装引导程序 grub 和 efi管理工具</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ pacman -S grub efibootmgr <span class="comment">--noconfirm</span></span><br></pre></td></tr></table></figure>
<p>如安装有多系统 需安装 os-prober</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>pacman -S os-prober</span><br></pre></td></tr></table></figure>
<p>安装引导 使用了efi的情况</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">grub-install <span class="attribute">--efi-directory</span>=/boot <span class="attribute">--bootloader-id</span>=grub</span><br></pre></td></tr></table></figure>
<p>生成引导配置</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ grub-mkconfig -o <span class="regexp">/boot/g</span>rub/grub.cfg</span><br></pre></td></tr></table></figure>
<p>编辑/etc/grub.d/40_custom<br> 修改成如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">exec</span> tail -n +3 <span class="variable">$0</span></span><br><span class="line"><span class="comment"># This file provides an easy way to add custom menu entries. Simply type the</span></span><br><span class="line"><span class="comment"># menu entries you want to add after this comment. Be careful not to change</span></span><br><span class="line"><span class="comment"># the &#x27;exec tail&#x27; line above.</span></span><br><span class="line"> </span><br><span class="line">menuentry <span class="string">&quot;System shutdown&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;System shutting down...&quot;</span></span><br><span class="line">    halt</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">menuentry <span class="string">&quot;System restart&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;System rebooting...&quot;</span></span><br><span class="line">    reboot</span><br><span class="line">&#125;</span><br><span class="line"> 执行命令</span><br><span class="line"><span class="comment"># grub-mkconfig -o /boot/grub/grub.cfg</span></span><br></pre></td></tr></table></figure>
<p>设置国内源<br>设置官方镜像源（包括 core， extra， community， multilib ）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sudo pacman-mirrors -i -c China -m rank <span class="regexp">//</span>更新镜像排名</span><br></pre></td></tr></table></figure>
<p>然后勾选你需要的镜像源，确认即可。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -Syy <span class="regexp">//</span>更新数据源</span><br></pre></td></tr></table></figure>
<p>时间不准</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line">$ <span class="string">timedatectl</span> <span class="built_in">set-local-rtc</span> <span class="string">1</span> <span class="built_in">--adjust-system-clock</span></span><br></pre></td></tr></table></figure>
<p><strong>manjaro切换内核版本命令</strong><br><strong>mhwd-kernel</strong><br><strong>manjaro硬件检测工具</strong><br><strong>mhwd</strong></p>
<h3 id="archlinux安装shadowsocksr并启用"><a href="#archlinux安装shadowsocksr并启用" class="headerlink" title="archlinux安装shadowsocksr并启用"></a>archlinux安装shadowsocksr并启用</h3><ol>
<li>安装<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yaourt shadowsocksr</span></span><br></pre></td></tr></table></figure></li>
<li>修改配置文件<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>shadowsocksr/config.json</span><br><span class="line"><span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;auth_sha1_v4&quot;</span>,</span><br><span class="line"><span class="string">&quot;obfs&quot;</span>:<span class="string">&quot;http_simple&quot;</span>,</span><br></pre></td></tr></table></figure></li>
<li>启动<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo python .<span class="regexp">/.local/</span>lib<span class="regexp">/python3.6/</span>site-packages<span class="regexp">/shadowsocks/</span>local.py -c <span class="regexp">/etc/</span>shadowsocksr/config.json</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-docker</title>
    <url>/2019/09/06/linux-docker/</url>
    <content><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="设置开机自启动并启动-Docker-ce"><a href="#设置开机自启动并启动-Docker-ce" class="headerlink" title="设置开机自启动并启动 Docker-ce"></a>设置开机自启动并启动 Docker-ce</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">enable</span> docker</span><br><span class="line">sudo systemctl <span class="keyword">start</span> docker</span><br></pre></td></tr></table></figure>
<h3 id="添加当前用户到-docker-用户组，可以不用-sudo-运行-docker"><a href="#添加当前用户到-docker-用户组，可以不用-sudo-运行-docker" class="headerlink" title=".添加当前用户到 docker 用户组，可以不用 sudo 运行 docker"></a>.添加当前用户到 docker 用户组，可以不用 sudo 运行 docker</h3><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<h3 id="获取archlinux镜像"><a href="#获取archlinux镜像" class="headerlink" title="获取archlinux镜像"></a>获取archlinux镜像</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">docker pull <span class="keyword">base</span>/archlinux</span><br></pre></td></tr></table></figure>
<h2 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h2><h3 id="列出所有镜像"><a href="#列出所有镜像" class="headerlink" title="列出所有镜像"></a>列出所有镜像</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span> </span><br></pre></td></tr></table></figure>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">image</span> rm image_id</span><br></pre></td></tr></table></figure>
<h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><p><strong>新建容器并挂载本地目录</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker run -it -v ~<span class="regexp">/myPrograms/</span>docker:<span class="regexp">/work/my</span>Programs<span class="regexp">/ base/</span>archlinux <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure>
<p><strong>启动容器</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">docker <span class="literal">start</span> ubuntu</span><br></pre></td></tr></table></figure>
<p><strong>进入shell</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">attach</span> ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="制作镜像并上传"><a href="#制作镜像并上传" class="headerlink" title="制作镜像并上传"></a>制作镜像并上传</h3><p><strong>制作镜像</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;xxxx&quot;</span> -<span class="keyword">a</span> <span class="string">&quot;techliu &lt;yyliushuai@gmail.com&gt;&quot;</span> container_id repository_name</span><br></pre></td></tr></table></figure>
<p><strong>登录</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker login</span></span><br></pre></td></tr></table></figure>
<p><strong>上传</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">push</span> techliu/ubuntu:latest</span><br></pre></td></tr></table></figure>
<p><strong>验证</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">inspect</span> techliu/ubuntu</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-envriment</title>
    <url>/2018/10/06/linux-envriment/</url>
    <content><![CDATA[<h2 id="一、配置文件级别"><a href="#一、配置文件级别" class="headerlink" title="一、配置文件级别"></a>一、配置文件级别</h2><h3 id="1-系统级文件：-etc-profile"><a href="#1-系统级文件：-etc-profile" class="headerlink" title="1.系统级文件：/etc/profile"></a>1.系统级文件：/etc/profile</h3><p>在登录时,操作系统定制用户环境时使用的第一个文件，此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。并从/etc/profile.d目录的配置文件中搜集shell的设置。这个文件一般就是调用/etc/bash.bashrc文件。<br>/etc/bash.bashrc：系统级的bashrc文件，为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<p>/etc/environment: 在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。</p>
<h3 id="2-用户级文件：-profile"><a href="#2-用户级文件：-profile" class="headerlink" title="2.用户级文件：~/.profile"></a>2.用户级文件：~/.profile</h3><p>在登录时用到的第三个文件 是.profile文件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</p>
<p>~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。不推荐放到这儿，因为每开一个shell，这个文件会读取一次，效率 上讲不好。</p>
<p><del>/.bash_profile：每个用户都可使用该文件输入专用于自己 使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</del>/.bash_profile 是交互式、login 方式进入 bash 运行的~/.bashrc是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p>
<p>~./bash_login:不推荐使用这个，这些不会影响图形界面。而且.bash_profile优先级比bash_login高。当它们存在时，登录shell启动时会读取它们。</p>
<p>~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件.</p>
<p>~/.pam_environment：用户级的环境变量设置文件。</p>
<p>另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是”父子”关系。</p>
<h2 id="二、设置环境变量的方法"><a href="#二、设置环境变量的方法" class="headerlink" title="二、设置环境变量的方法"></a>二、设置环境变量的方法</h2><p>由以上分析可知：<br>/etc/profile全局的，随系统启动设置【设置这个文件是一劳永逸的办法】</p>
<p>/root/.profile和/home/myname/.profile只对当前窗口有效。</p>
<p>/root/.bashrc和 /home/yourname/.bashrc随系统启动，设置用户的环境变量【平时设置这个文件就可以了】</p>
<p>那么要配置Ubuntu的环境变量，就是在这几个配置文件中找一个合适的文件进行操作了；如想将一个路径加入到$PATH中，可以由下面这样几种添加方法：<br>1.控制台中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$PATH</span>=<span class="string">&quot;<span class="variable">$PATH</span>:/my_new_path&quot;</span> （关闭shell，会还原PATH）</span><br></pre></td></tr></table></figure>
<p>2.修改profile文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sudo gedit <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>
<p>在里面加入:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">exportPATH</span>=<span class="string">&quot;$PATH:/my_new_path&quot;</span></span><br></pre></td></tr></table></figure>
<p>3.修改.bashrc文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sudo gedit <span class="regexp">/root/</span>.bashrc</span><br></pre></td></tr></table></figure>
<p>在里面加入：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">&quot;<span class="variable">$PATH</span>:/my_new_path&quot;</span></span><br></pre></td></tr></table></figure>
<p>后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure>
<p>输出已经是新路径了。<br>举个列子，如果想把当前路径加入到环境变量中去，就可以这样做：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> PATH =<span class="string">&quot;<span class="variable">$PATH:</span>.&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样运行自己编写的shell脚本时就可以不输入./了</p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>综上所述，在Ubuntu 系统中/etc/profile文件是全局的环境变量配置文件，它适用于所有的shell。在我们登陆Linux系统时，首先启动/etc/profile文件，然后再启动用户目录下的<del>/.bash_profile、</del>/.bash_login或<del>/.profile文件中的其中一个，执行的顺序和上面的排序一样。如果</del>/.bash_profile文件存在的话，一般还会执行~/.bashrc文件。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>envriment</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-class</title>
    <url>/2019/09/05/linux-kernel-class/</url>
    <content><![CDATA[<h3 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h3><p>A device class describes a type of device, like an audio or network<br>device. The following device classes have been identified:</p>
<Insert List of Device Classes Here>


<p>Each device class defines a set of semantics and a programming interface<br>that devices of that class adhere to. Device drivers are the<br>implementation of that programming interface for a particular device on<br>a particular bus. </p>
<p>Device classes are agnostic with respect to what bus a device resides<br>on.<br>class是将device中的共性抽象出来，放在一起实现的抽象结构和接口。</p>
<h3 id="二、Programming-Interface"><a href="#二、Programming-Interface" class="headerlink" title="二、Programming Interface"></a>二、Programming Interface</h3><p>The device class structure looks like: </p>
<p>typedef int (*devclass_add)(struct device *);<br>typedef void (*devclass_remove)(struct device *);</p>
<p>See the kerneldoc for the struct class.</p>
<p>A typical device class definition would look like: </p>
<p>struct device_class input_devclass = {<br>        .name        = “input”,<br>        .add_device    = input_add_device,<br>    .remove_device    = input_remove_device,<br>};</p>
<p>Each device class structure should be exported in a header file so it<br>can be used by drivers, extensions and interfaces.</p>
<p>Device classes are registered and unregistered with the core using: </p>
<p>int devclass_register(struct device_class * cls);<br>void devclass_unregister(struct device_class * cls);</p>
<h3 id="三、Devices"><a href="#三、Devices" class="headerlink" title="三、Devices"></a>三、Devices</h3><p>As devices are bound to drivers, they are added to the device class<br>that the driver belongs to. Before the driver model core, this would<br>typically happen during the driver’s probe() callback, once the device<br>has been initialized. It now happens after the probe() callback<br>finishes from the core. </p>
<p>The device is enumerated in the class. Each time a device is added to<br>the class, the class’s devnum field is incremented and assigned to the<br>device. The field is never decremented, so if the device is removed<br>from the class and re-added, it will receive a different enumerated<br>value. </p>
<p>The class is allowed to create a class-specific structure for the<br>device and store it in the device’s class_data pointer. </p>
<p>There is no list of devices in the device class. Each driver has a<br>list of devices that it supports. The device class has a list of<br>drivers of that particular class. To access all of the devices in the<br>class, iterate over the device lists of each driver in the class.</p>
<h3 id="四、Device-Drivers"><a href="#四、Device-Drivers" class="headerlink" title="四、Device Drivers"></a>四、Device Drivers</h3><p>Device drivers are added to device classes when they are registered<br>with the core. A driver specifies the class it belongs to by setting<br>the struct device_driver::devclass field.<br>sysfs directory structure</p>
<p>There is a top-level sysfs directory named ‘class’. </p>
<p>Each class gets a directory in the class directory, along with two<br>default subdirectories:</p>
<pre><code>    class/
    `-- input
        |-- devices
        `-- drivers</code></pre>
<p>Drivers registered with the class get a symlink in the drivers/ directory<br>that points to the driver’s directory (under its bus directory):</p>
<p>   class/<br>   <code>-- input        |-- devices        </code>– drivers<br>           `– usb:usb_mouse -&gt; ../../../bus/drivers/usb_mouse/</p>
<p>Each device gets a symlink in the devices/ directory that points to the<br>device’s directory in the physical hierarchy:</p>
<p>   class/<br>   <code>-- input        |-- devices        |   </code>– 1 -&gt; ../../../root/pci0/00:1f.0/usb_bus/00:1f.2-1:0/<br>       `– drivers</p>
<h3 id="五、Exporting-Attributes"><a href="#五、Exporting-Attributes" class="headerlink" title="五、Exporting Attributes"></a>五、Exporting Attributes</h3><p>struct devclass_attribute {<br>        struct attribute        attr;<br>        ssize_t (*show)(struct device_class *, char * buf, size_t count, loff_t off);<br>        ssize_t (*store)(struct device_class *, const char * buf, size_t count, loff_t off);<br>};</p>
<p>Class drivers can export attributes using the DEVCLASS_ATTR macro that works<br>similarly to the DEVICE_ATTR macro for devices. For example, a definition<br>like this:</p>
<p>static DEVCLASS_ATTR(debug,0644,show_debug,store_debug);</p>
<p>is equivalent to declaring:</p>
<p>static devclass_attribute devclass_attr_debug;</p>
<p>The bus driver can add and remove the attribute from the class’s<br>sysfs directory using:</p>
<p>int devclass_create_file(struct device_class *, struct devclass_attribute *);<br>void devclass_remove_file(struct device_class *, struct devclass_attribute *);</p>
<p>In the example above, the file will be named ‘debug’ in placed in the<br>class’s directory in sysfs. </p>
<h3 id="六、Interfaces"><a href="#六、Interfaces" class="headerlink" title="六、Interfaces"></a>六、Interfaces</h3><p>There may exist multiple mechanisms for accessing the same device of a<br>particular class type. Device interfaces describe these mechanisms. </p>
<p>When a device is added to a device class, the core attempts to add it<br>to every interface that is registered with the device class.</p>
<h3 id="七、数据结构"><a href="#七、数据结构" class="headerlink" title="七、数据结构"></a>七、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct class &#123;</span><br><span class="line">	const char		*name; //class的名称，会在“/sys/class/”目录下体现</span><br><span class="line">	struct module		*owner;</span><br><span class="line"></span><br><span class="line">	const struct attribute_group	**class_groups;</span><br><span class="line">	const struct attribute_group	**dev_groups;</span><br><span class="line">	struct kobject			*dev_kobj; //表示该class下的设备在/sys/dev/下的目录，现在一般有char和block两个，如果dev_kobj为NULL，则默认选择char</span><br><span class="line"></span><br><span class="line">	int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); //当该class下有设备发生变化时，会调用class的uevent回调函数</span><br><span class="line">	char *(*devnode)(struct device *dev, umode_t *mode);</span><br><span class="line"></span><br><span class="line">	void (*class_release)(struct class *class); //用于release自身的回调函数</span><br><span class="line">	void (*dev_release)(struct device *dev); //用于release class内设备的回调函数。在device_release接口中，会依次检查Device、Device Type以及Device所在的class，是否注册release接口，如果有则调用相应的release接口release设备指针</span><br><span class="line"></span><br><span class="line">	int (*shutdown_pre)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	const struct kobj_ns_type_operations *ns_type;</span><br><span class="line">	const void *(*namespace)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm;</span><br><span class="line"></span><br><span class="line">	struct subsys_private *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct class_interface是这样的一个结构：它允许class driver在class下有设备添加或移除的时候，调用预先设置好的回调函数（add_dev和remove_dev）。那调用它们做什么呢？想做什么都行（例如修改设备的名称），由具体的class driver实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct class_interface &#123;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">	struct class		*class;</span><br><span class="line"></span><br><span class="line">	int (*add_dev)		(struct device *, struct class_interface *);</span><br><span class="line">	void (*remove_dev)	(struct device *, struct class_interface *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="八、API"><a href="#八、API" class="headerlink" title="八、API"></a>八、API</h3><p><strong>class的注册</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int __class_register(struct class *cls, struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	struct subsys_private *cp;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;device class &#x27;%s&#x27;: registering\n&quot;</span>, cls-&gt;name);</span><br><span class="line"></span><br><span class="line">	/* 为class结构中的struct subsys_private类型的指针（cp）分配空间 */</span><br><span class="line">	cp = kzalloc(sizeof(*cp), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!cp)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;0</span><br><span class="line">	klist_init(&amp;cp-&gt;klist_devices, klist_class_dev_get, klist_class_dev_put);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cp-&gt;interfaces);</span><br><span class="line">	kset_init(&amp;cp-&gt;glue_dirs);</span><br><span class="line">	__mutex_init(&amp;cp-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">	error = kobject_set_name(&amp;cp-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, cls-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		kfree(cp);</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* <span class="built_in">set</span> the default /sys/dev directory <span class="keyword">for</span> devices of this class */</span><br><span class="line">	<span class="keyword">if</span> (!cls-&gt;dev_kobj)</span><br><span class="line">		cls-&gt;dev_kobj = sysfs_dev_char_kobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_BLOCK)</span></span><br><span class="line">	/* <span class="built_in">let</span> the block class directory show up <span class="keyword">in</span> the root of sysfs */</span><br><span class="line">	<span class="keyword">if</span> (!sysfs_deprecated || cls != &amp;block_class)</span><br><span class="line">		cp-&gt;subsys.kobj.kset = class_kset;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	cp-&gt;subsys.kobj.kset = class_kset;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	cp-&gt;subsys.kobj.ktype = &amp;class_ktype;</span><br><span class="line">	cp-&gt;class = cls;</span><br><span class="line">	cls-&gt;p = cp;</span><br><span class="line"></span><br><span class="line">	/* 调用kset_register，注册该class,该过程结束后，在/sys/class/目录下，就会创建对应该class的目录*/</span><br><span class="line">	error = kset_register(&amp;cp-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		kfree(cp);</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	error = class_add_groups(class_get(cls), cls-&gt;class_groups);</span><br><span class="line">	class_put(cls);</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__class_register);</span><br></pre></td></tr></table></figure>
<p><strong>__class_create</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 创建一个结构体，并注册 */</span><br><span class="line">struct class *__class_create(struct module *owner, const char *name,</span><br><span class="line">			     struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	struct class *cls;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	cls = kzalloc(sizeof(*cls), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		goto error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cls-&gt;name = name;</span><br><span class="line">	cls-&gt;owner = owner;</span><br><span class="line">	cls-&gt;class_release = class_create_release;</span><br><span class="line"></span><br><span class="line">	retval = __class_register(cls, key);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto error;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> cls;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	kfree(cls);</span><br><span class="line">	<span class="built_in">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__class_create);</span><br></pre></td></tr></table></figure>
<p><strong>class_release</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static void class_release(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	struct subsys_private *cp = to_subsys_private(kobj);</span><br><span class="line">	struct class *class = cp-&gt;class;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;class &#x27;%s&#x27;: release.\n&quot;</span>, class-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (class-&gt;class_release)</span><br><span class="line">		class-&gt;class_release(class);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pr_debug(<span class="string">&quot;class &#x27;%s&#x27; does not have a release() function, &quot;</span></span><br><span class="line">			 <span class="string">&quot;be careful\n&quot;</span>, class-&gt;name);</span><br><span class="line"></span><br><span class="line">	kfree(cp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kobj_type</strong><br>相同的结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static const struct sysfs_ops class_sysfs_ops = &#123;</span><br><span class="line">	.show	   = class_attr_show,</span><br><span class="line">	.store	   = class_attr_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct kobj_type class_ktype = &#123;</span><br><span class="line">	.sysfs_ops	= &amp;class_sysfs_ops,</span><br><span class="line">	.release	= class_release,</span><br><span class="line">	.child_ns_type	= class_child_ns_type,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">tatic ssize_t class_attr_show(struct kobject *kobj, struct attribute *attr,</span><br><span class="line">			       char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	struct class_attribute *class_attr = to_class_attr(attr);</span><br><span class="line">	struct subsys_private *cp = to_subsys_private(kobj);</span><br><span class="line">	ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (class_attr-&gt;show)</span><br><span class="line">		ret = class_attr-&gt;show(cp-&gt;class, class_attr, buf);</span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t class_attr_store(struct kobject *kobj, struct attribute *attr,</span><br><span class="line">				const char *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	struct class_attribute *class_attr = to_class_attr(attr);</span><br><span class="line">	struct subsys_private *cp = to_subsys_private(kobj);</span><br><span class="line">	ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (class_attr-&gt;store)</span><br><span class="line">		ret = class_attr-&gt;store(cp-&gt;class, class_attr, buf, count);</span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void class_release(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	struct subsys_private *cp = to_subsys_private(kobj);</span><br><span class="line">	struct class *class = cp-&gt;class;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;class &#x27;%s&#x27;: release.\n&quot;</span>, class-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (class-&gt;class_release)</span><br><span class="line">		class-&gt;class_release(class);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pr_debug(<span class="string">&quot;class &#x27;%s&#x27; does not have a release() function, &quot;</span></span><br><span class="line">			 <span class="string">&quot;be careful\n&quot;</span>, class-&gt;name);</span><br><span class="line"></span><br><span class="line">	kfree(cp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-git</title>
    <url>/2018/09/06/linux-git/</url>
    <content><![CDATA[<h2 id="免密操作"><a href="#免密操作" class="headerlink" title="免密操作"></a>免密操作</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol>
<li>进入用户主目录，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></li>
<li>建立文件 .git-credentials，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch .git-credentials</span><br></pre></td></tr></table></figure></li>
<li>编辑文件 .git-credentials<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi .git-credentials</span><br></pre></td></tr></table></figure></li>
<li>添加规则<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://username:password@gitlab.com</span><br></pre></td></tr></table></figure></li>
<li>执行命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper store</span><br><span class="line"></span><br><span class="line">$ git pull /git push </span><br></pre></td></tr></table></figure>
第一次需要输入用户名密码，以后就不用了（本质上同上，会在用户目录下创建.git-credential文件并将用户信息写入该文件）<h3 id="关于ssh-key"><a href="#关于ssh-key" class="headerlink" title="关于ssh-key"></a>关于ssh-key</h3></li>
</ol>
<p><strong>创建key</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;something&quot;</span></span><br></pre></td></tr></table></figure>
<p>-t 指定密钥类型，默认是 rsa<br>-C 设置注释文字，比如邮箱<br>该命令会生成两个秘钥文件将id_rsa.pub文件内容复制到github或gitlab就可以通过ssh传输文件<br>对于http协议传输需要修改.git目录下config文件格式为</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//u</span>sername:password@github.com</span><br></pre></td></tr></table></figure>
<p><strong>git不能clone代码，证书问题</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ git config --global http.sslverify <span class="keyword">true</span></span><br><span class="line">$ git config --global http.sslCAPath <span class="regexp">/etc/</span>pki<span class="regexp">/tls/</span>certs</span><br></pre></td></tr></table></figure>
<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><h3 id="0、常用"><a href="#0、常用" class="headerlink" title="0、常用"></a>0、常用</h3><p>显示所有分支（本地+远程）</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git branch -a</span><br></pre></td></tr></table></figure>
<p>切换分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>将本地代码推送到远程</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">reset</span>:<span class="built_in">reset</span></span><br></pre></td></tr></table></figure>
<p>删除远程分支</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> &lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<p>删除本地分支</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$git</span> branch -d &lt;branchName&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改最后一次commit的备注</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure>
<p>查看用户名和邮箱地址：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git config <span class="keyword">user</span>.name</span><br><span class="line">$ git config <span class="keyword">user</span>.email</span><br></pre></td></tr></table></figure>
<p>修改用户名和邮箱地址：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure>
<p>更新远程代码到本地</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git fetch origin branch1</span><br><span class="line"><span class="variable">$ </span>git merge origin/branch1</span><br></pre></td></tr></table></figure>
<h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><p>在当前目录新建一个Git代码库</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>新建一个目录，将其初始化为Git代码库</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git init [project-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>
<p>下载一个项目和它的整个代码历史</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]</span><br></pre></td></tr></table></figure>
<h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<p>显示当前的Git配置</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">config</span> <span class="comment">--list</span></span><br></pre></td></tr></table></figure>
<p>设置提交代码时的用户信息</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">config</span> [--<span class="keyword">global</span>] user<span class="variable">.name</span> <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git <span class="keyword">config</span> [--<span class="keyword">global</span>] user<span class="variable">.email</span> <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><p>添加指定文件到暂存区</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">$ git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<p>添加指定目录到暂存区，包括子目录</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> [dir]</span></span><br></pre></td></tr></table></figure>
<p>添加当前目录的所有文件到暂存区</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> .</span></span><br></pre></td></tr></table></figure>
<h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><p>提交暂存区到仓库区</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ git commit -m [<span class="keyword">message</span>]</span><br></pre></td></tr></table></figure>
<p>使用一次新的commit，替代上一次提交<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend -m [message]</span></span><br></pre></td></tr></table></figure>
<h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><p>列出所有本地分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git branch</span><br></pre></td></tr></table></figure>
<p>列出所有远程分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git branch -r</span><br></pre></td></tr></table></figure>
<p>列出所有本地分支和远程分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git branch -a</span><br></pre></td></tr></table></figure>
<p>新建一个分支，但依然停留在当前分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git branch [branch-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>
<p>新建一个分支，并切换到该分支</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git checkout -<span class="keyword">b</span> [branch]</span><br></pre></td></tr></table></figure>
<p>新建一个分支，指向指定commit</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">$ git branch <span class="comment">[branch]</span> <span class="comment">[commit]</span></span><br></pre></td></tr></table></figure>
<p>切换到指定分支，并更新工作区</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git checkout [branch-<span class="built_in">name</span></span><br></pre></td></tr></table></figure>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch --<span class="keyword">set</span>-upstream <span class="comment">[branch] [remote-branch]</span></span><br></pre></td></tr></table></figure>
<p>合并指定分支到当前分支</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> [branch]</span><br></pre></td></tr></table></figure>
<p>选择一个commit，合并进当前分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git cherry-pick [commit]</span><br></pre></td></tr></table></figure>
<p>删除分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git branch -d [branch-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>
<p>删除远程分支</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><p>列出所有tag</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure>
<p>新建一个tag在当前commit</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>]</span><br></pre></td></tr></table></figure>
<p>新建一个tag在指定commit</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>] [commit]</span><br></pre></td></tr></table></figure>
<p>删除本地tag</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> [<span class="keyword">tag</span>]</span><br></pre></td></tr></table></figure>
<p>删除远程tag</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git push origin <span class="symbol">:refs/tags/</span>[tagName]</span><br></pre></td></tr></table></figure>
<p>查看tag信息</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git show [<span class="keyword">tag</span>]</span><br></pre></td></tr></table></figure>
<p>提交指定tag</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">$ git push <span class="comment">[remote]</span> <span class="comment">[tag]</span></span><br></pre></td></tr></table></figure>
<p>提交所有tag</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git push [remote] <span class="comment">--tags</span></span><br></pre></td></tr></table></figure>
<p>新建一个分支，指向某个tag</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">$ git checkout -b <span class="comment">[branch]</span> <span class="comment">[tag]</span></span><br></pre></td></tr></table></figure>
<h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><p>显示有变更的文件</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git status</span><br></pre></td></tr></table></figure>
<p>显示当前分支的版本历史</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>显示指定文件相关的每一次diff</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built_in">log</span> -p [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<p>显示所有提交过的用户，按提交次数排序</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git shortlog -<span class="meta">sn</span></span><br></pre></td></tr></table></figure>
<p>显示暂存区和工作区的代码差异</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span></span><br></pre></td></tr></table></figure>
<p>显示暂存区和上一个commit的差异</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git diff --cached [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<p>显示工作区与当前分支最新commit之间的差异</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span> HEAD</span><br></pre></td></tr></table></figure>
<p>显示两次提交之间的差异</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">diff</span> [<span class="built_in">first</span>-branch]...[<span class="built_in">second</span>-branch]</span><br></pre></td></tr></table></figure>
<p>显示某次提交时，某个文件的内容</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">$ git show <span class="comment">[commit]</span>:<span class="comment">[filename]</span></span><br></pre></td></tr></table></figure>
<p>从本地master拉取代码更新当前分支：branch 一般为master</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git rebase [branch]</span><br></pre></td></tr></table></figure>
<h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><p>下载远程仓库的所有变动</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git fetch [remote]</span><br></pre></td></tr></table></figure>
<p>显示所有远程仓库</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure>
<p>显示某个远程仓库的信息</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="keyword">show</span> [remote]</span><br></pre></td></tr></table></figure>
<p>增加一个新的远程仓库，并命名</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="keyword">add</span><span class="bash"> [shortname] [url]</span></span><br></pre></td></tr></table></figure>
<p>取回远程仓库的变化，并与本地分支合并</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">$ git pull <span class="comment">[remote]</span> <span class="comment">[branch]</span></span><br></pre></td></tr></table></figure>
<p>上传本地指定分支到远程仓库</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">$ git push <span class="comment">[remote]</span> <span class="comment">[branch]</span></span><br></pre></td></tr></table></figure>
<p>强行推送当前分支到远程仓库，即使有冲突</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git push [remote] <span class="comment">--force</span></span><br></pre></td></tr></table></figure>
<p>推送所有分支到远程仓库</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git push [remote] --<span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><p>恢复暂存区的指定文件到工作区</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<p>恢复某个commit的指定文件到暂存区和工作区</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout [commit] [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure>
<p>恢复暂存区的所有文件到工作区</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout .</span><br></pre></td></tr></table></figure>
<p>重置暂存区与工作区，与上一次commit保持一致</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard</span></span><br></pre></td></tr></table></figure>
<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> [<span class="keyword">commit</span>]</span><br></pre></td></tr></table></figure>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard [commit]</span></span><br></pre></td></tr></table></figure>
<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--keep [commit]</span></span><br></pre></td></tr></table></figure>
<p>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">revert</span> [commit]</span><br></pre></td></tr></table></figure>
<p>暂时将未提交的变化移除，稍后再移入</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git stash</span><br><span class="line"><span class="variable">$ </span>git stash pop</span><br></pre></td></tr></table></figure>
<h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><p>Git 标签：<br>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。<br>附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息。</p>
<h4 id="创建标签："><a href="#创建标签：" class="headerlink" title="创建标签："></a>创建标签：</h4><p>附注标签</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">4</span> -m &#x27;my <span class="keyword">version</span> <span class="number">1.4</span>&#x27;</span><br></pre></td></tr></table></figure>
<p>轻量标签</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">4</span>-lw</span><br></pre></td></tr></table></figure>
<p>后期打标签</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">29</span>fceb02 (<span class="number">29</span>fceb02是一次提交的校验)</span><br></pre></td></tr></table></figure>
<p>共享标签<br>将标签提交到远程服务器</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">push</span> origin <span class="built_in">v1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>一次性推送很多标签</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure>
<p>Git 别名<br>通过 git config 文件来轻松地为每一个命令设置一个别名。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.ci</span> commit</span><br></pre></td></tr></table></figure>
<p>这意味着，当要输入 git commit 时，只需要输入 git ci。</p>
<p>查询是否使用代理：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">config</span> <span class="comment">--global http.proxy </span></span><br></pre></td></tr></table></figure>
<p>取消代理：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> --<span class="keyword">unset</span> <span class="keyword">http</span>.proxy</span><br></pre></td></tr></table></figure>
<p>使用代理</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.proxy</span> &#x27;socks5:<span class="comment">//127.0.0.1:7891&#x27;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> https<span class="variable">.proxy</span> &#x27;socks5:<span class="comment">//127.0.0.1:7891&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="git与上游-保持同步"><a href="#git与上游-保持同步" class="headerlink" title="git与上游 保持同步"></a>git与上游 保持同步</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git remote add src-zephyr https:<span class="regexp">//gi</span>thub.com<span class="regexp">/zephyrproject-rtos/</span>zephyr</span><br><span class="line">git pull src-zephyr master</span><br><span class="line">git push </span><br></pre></td></tr></table></figure>
<h3 id="git合并分支"><a href="#git合并分支" class="headerlink" title="git合并分支"></a>git合并分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert  </span><br><span class="line">git pull --rebase origin  </span><br><span class="line">git pull --rebase origin release-retail-v1.0-ORICO-RNAS  </span><br><span class="line">  </span><br><span class="line">有冲突  </span><br><span class="line">git status 查看冲突文件并解决冲突  </span><br><span class="line">git add提交解决冲突后的文件  </span><br><span class="line">git rebase --<span class="built_in">continue</span> rebase完成 </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-device</title>
    <url>/2019/09/09/linux-kernel-device/</url>
    <content><![CDATA[<h3 id="一、Programming-Interface"><a href="#一、Programming-Interface" class="headerlink" title="一、Programming Interface"></a>一、Programming Interface</h3><p>The bus driver that discovers the device uses this to register the<br>device with the core:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int device_register(struct device * dev);</span><br></pre></td></tr></table></figure>
<p>The bus should initialize the following fields:</p>
<pre><code>- parent
- name
- bus_id
- bus</code></pre>
<p>A device is removed from the core when its reference count goes to<br>0. The reference count can be adjusted using:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device * get_device(struct device * dev);</span><br><span class="line">void put_device(struct device * dev);</span><br></pre></td></tr></table></figure>
<p>get_device() will return a pointer to the struct device passed to it<br>if the reference is not already 0 (if it’s in the process of being<br>removed already).</p>
<p>A driver can access the lock in the device structure using: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void lock_device(struct device * dev);</span><br><span class="line">void unlock_device(struct device * dev);</span><br></pre></td></tr></table></figure>
<h3 id="二、Attributes"><a href="#二、Attributes" class="headerlink" title="二、Attributes"></a>二、Attributes</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device_attribute &#123;</span><br><span class="line">	struct attribute	attr;</span><br><span class="line">	ssize_t (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">			char *buf);</span><br><span class="line">	ssize_t (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">			 const char *buf, size_t count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Attributes of devices can be exported by a device driver through sysfs.</p>
<p>Please see Documentation/filesystems/sysfs.txt for more information<br>on how sysfs works.</p>
<p>As explained in Documentation/kobject.txt, device attributes must be<br>created before the KOBJ_ADD uevent is generated. The only way to realize<br>that is by defining an attribute group.</p>
<p>Attributes are declared using a macro called DEVICE_ATTR:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define DEVICE_ATTR(name,mode,show,store)</span></span><br></pre></td></tr></table></figure>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static DEVICE_ATTR(<span class="built_in">type</span>, 0444, show_type, NULL);</span><br><span class="line">static DEVICE_ATTR(power, 0644, show_power, store_power);</span><br></pre></td></tr></table></figure>
<p>This declares two structures of type struct device_attribute with respective<br>names ‘dev_attr_type’ and ‘dev_attr_power’. These two attributes can be<br>organized as follows into a group:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static struct attribute *dev_attrs[] = &#123;</span><br><span class="line">	&amp;dev_attr_type.attr,</span><br><span class="line">	&amp;dev_attr_power.attr,</span><br><span class="line">	NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct attribute_group dev_attr_group = &#123;</span><br><span class="line">	.attrs = dev_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct attribute_group *dev_attr_groups[] = &#123;</span><br><span class="line">	&amp;dev_attr_group,</span><br><span class="line">	NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This array of groups can then be associated with a device by setting the<br>group pointer in struct device before device_register() is invoked:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dev-&gt;groups = dev_attr_groups;</span><br><span class="line">device_register(dev);</span><br></pre></td></tr></table></figure>
<p>The device_register() function will use the ‘groups’ pointer to create the<br>device attributes and the device_unregister() function will use this pointer<br>to remove the device attributes.</p>
<p>Word of warning:  While the kernel allows device_create_file() and<br>device_remove_file() to be called on a device at any time, userspace has<br>strict expectations on when attributes get created.  When a new device is<br>registered in the kernel, a uevent is generated to notify userspace (like<br>udev) that a new device is available.  If attributes are added after the<br>device is registered, then userspace won’t get notified and userspace will<br>not know about the new attributes.</p>
<p>This is important for device driver that need to publish additional<br>attributes for a device at driver probe time.  If the device driver simply<br>calls device_create_file() on the device structure passed to it, then<br>userspace will never be notified of the new attributes.</p>
<h3 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device &#123;</span><br><span class="line">	struct device		*parent; //该设备的父设备，一般是该设备所从属的bus、controller等设备</span><br><span class="line"></span><br><span class="line">	struct device_private	*p; //一个用于struct device的私有数据结构指针，该指针中会保存子设备链表、用于添加到bus/driver/prent等设备中的链表头等等</span><br><span class="line">	struct kobject kobj; //该数据结构对应的struct kobject</span><br><span class="line">	const char		*init_name; /* initial name of the device */ //该设备的名称</span><br><span class="line">	const struct device_type *<span class="built_in">type</span>; //struct device_type结构是新版本内核新引入的一个结构，它和struct device关系，非常类似stuct kobj_type和struct kobject之间的关系</span><br><span class="line"></span><br><span class="line">	struct mutex		mutex;	/* mutex to synchronize calls to</span><br><span class="line">					 * its driver.</span><br><span class="line">					 */</span><br><span class="line"></span><br><span class="line">	struct bus_type	*bus;		/* <span class="built_in">type</span> of bus device is on */ //该device属于哪个总线</span><br><span class="line">	struct device_driver *driver;	/* <span class="built_in">which</span> driver has allocated this</span><br><span class="line">					   device */ //该device对应的device driver</span><br><span class="line">	void		*platform_data;	/* Platform specific data, device</span><br><span class="line">					   core doesn<span class="string">&#x27;t touch it */ //用于保存具体的平台相关的数据。具体的driver模块，可以将一些私有的数据，暂存在这里，需要使用的时候，再拿出来，因此设备模型并不关心该指针得实际含义</span></span><br><span class="line"><span class="string">	void		*driver_data;	/* Driver data, set and get with</span></span><br><span class="line"><span class="string">					   dev_set/get_drvdata */ //driver的数据</span></span><br><span class="line"><span class="string">	struct dev_links_info	links;</span></span><br><span class="line"><span class="string">	struct dev_pm_info	power;</span></span><br><span class="line"><span class="string">	struct dev_pm_domain	*pm_domain; //power和pm_domain电源管理相关</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line"><span class="string">	struct irq_domain	*msi_domain;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_PINCTRL</span></span><br><span class="line"><span class="string">	struct dev_pin_info	*pins; //pinctrl功能</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line"><span class="string">	struct list_head	msi_list;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifdef CONFIG_NUMA</span></span><br><span class="line"><span class="string">	int		numa_node;	/* NUMA node this device is close to */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	const struct dma_map_ops *dma_ops;</span></span><br><span class="line"><span class="string">	u64		*dma_mask;	/* dma mask (if dma&#x27;</span>able device) */</span><br><span class="line">	u64		coherent_dma_mask;/* Like dma_mask, but <span class="keyword">for</span></span><br><span class="line">					     alloc_coherent mappings as</span><br><span class="line">					     not all hardware supports</span><br><span class="line">					     64 bit addresses <span class="keyword">for</span> consistent</span><br><span class="line">					     allocations such descriptors. */ //DMA相关</span><br><span class="line">	unsigned long	dma_pfn_offset;</span><br><span class="line"></span><br><span class="line">	struct device_dma_parameters *dma_parms;</span><br><span class="line"></span><br><span class="line">	struct list_head	dma_pools;	/* dma pools (<span class="keyword">if</span> dma<span class="string">&#x27;ble) */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	struct dma_coherent_mem	*dma_mem; /* internal for coherent mem</span></span><br><span class="line"><span class="string">					     override */</span></span><br><span class="line"><span class="string">#ifdef CONFIG_DMA_CMA</span></span><br><span class="line"><span class="string">	struct cma *cma_area;		/* contiguous memory area for dma</span></span><br><span class="line"><span class="string">					   allocations */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	/* arch specific additions */</span></span><br><span class="line"><span class="string">	struct dev_archdata	archdata;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	struct device_node	*of_node; /* associated device tree node */ </span></span><br><span class="line"><span class="string">	struct fwnode_handle	*fwnode; /* firmware device node */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	dev_t			devt;	/* dev_t, creates the sysfs &quot;dev&quot; */ //dev_t是一个32位的整数，它由两个部分（Major和Minor）组成，在需要以设备节点的形式（字符设备和块设备）向用户空间提供接口的设备中，当作设备号使用。在这里，该变量主要用于在sys文件系统中，为每个具有设备号的device，创建/sys/dev/* 下的对应目录</span></span><br><span class="line"><span class="string">	u32			id;	/* device instance */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	spinlock_t		devres_lock;</span></span><br><span class="line"><span class="string">	struct list_head	devres_head;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	struct klist_node	knode_class;</span></span><br><span class="line"><span class="string">	struct class		*class; //该设备属于哪个class</span></span><br><span class="line"><span class="string">	const struct attribute_group **groups;	/* optional groups */ //该设备的默认attribute集合。将会在设备注册时自动在sysfs中创建对应的文件</span></span><br><span class="line"><span class="string">	void	(*release)(struct device *dev);</span></span><br><span class="line"><span class="string">	struct iommu_group	*iommu_group; </span></span><br><span class="line"><span class="string">	struct iommu_fwspec	*iommu_fwspec;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	bool			offline_disabled:1;</span></span><br><span class="line"><span class="string">	bool			offline:1;</span></span><br><span class="line"><span class="string">	bool			of_node_reused:1;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">struct device_private &#123;</span></span><br><span class="line"><span class="string">	struct klist klist_children;</span></span><br><span class="line"><span class="string">	struct klist_node knode_parent;</span></span><br><span class="line"><span class="string">	struct klist_node knode_driver;</span></span><br><span class="line"><span class="string">	struct klist_node knode_bus;</span></span><br><span class="line"><span class="string">	struct list_head deferred_probe;</span></span><br><span class="line"><span class="string">	struct device *device;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">static struct kobj_type device_ktype = &#123;</span></span><br><span class="line"><span class="string">	.release	= device_release,</span></span><br><span class="line"><span class="string">	.sysfs_ops	= &amp;dev_sysfs_ops,</span></span><br><span class="line"><span class="string">	.namespace	= device_namespace,</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">struct device_type &#123;</span></span><br><span class="line"><span class="string">	const char *name; //name表示该类型的名称，当该类型的设备添加到内核时，内核会发出&quot;DEVTYPE=‘name’“类型的uevent，告知用户空间某个类型的设备available了</span></span><br><span class="line"><span class="string">	const struct attribute_group **groups; //该类型设备的公共attribute集合。设备注册时，会同时注册这些attribute。这就是面向对象中“继承”的概念</span></span><br><span class="line"><span class="string">	int (*uevent)(struct device *dev, struct kobj_uevent_env *env); //同理，所有相同类型的设备，会有一些共有的uevent需要发送，由该接口实现</span></span><br><span class="line"><span class="string">	char *(*devnode)(struct device *dev, umode_t *mode,</span></span><br><span class="line"><span class="string">			 kuid_t *uid, kgid_t *gid); //devtmpfs有关的内容</span></span><br><span class="line"><span class="string">	void (*release)(struct device *dev); //如果device结构没有提供release接口，就要查询它所属的type是否提供。用于释放device变量所占的空间</span></span><br><span class="line"><span class="string">	const struct dev_pm_ops *pm;//电源管理相关</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="四、API"><a href="#四、API" class="headerlink" title="四、API"></a>四、API</h3><p>device_register(struct device *dev)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int device_register(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	device_initialize(dev);</span><br><span class="line">	<span class="built_in">return</span> device_add(dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></table></figure>
<p>device_initialize(struct device *dev)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* /sys/devices/ */</span><br><span class="line">struct kset *devices_kset;</span><br><span class="line">...</span><br><span class="line">/* 初始化相关成员 */</span><br><span class="line">void device_initialize(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	dev-&gt;kobj.kset = devices_kset;</span><br><span class="line">	kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">	mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">	lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">	spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">	device_pm_init(dev);</span><br><span class="line">	set_dev_node(dev, -1);</span><br><span class="line"><span class="comment">#ifdef CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;links.consumers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;links.suppliers);</span><br><span class="line">	dev-&gt;links.status = DL_DEV_NO_DRIVER;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_initialize);</span><br></pre></td></tr></table></figure>
<p>device_add(struct device *dev)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int device_add(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *parent;</span><br><span class="line">	struct kobject *kobj;</span><br><span class="line">	struct class_interface *class_intf;</span><br><span class="line">	int error = -EINVAL;</span><br><span class="line">	struct kobject *glue_dir = NULL;</span><br><span class="line"></span><br><span class="line">	dev = get_device(dev);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		goto <span class="keyword">done</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">		error = device_private_init(dev);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			goto <span class="keyword">done</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * <span class="keyword">for</span> statically allocated devices, <span class="built_in">which</span> should all be converted</span><br><span class="line">	 * some day, we need to initialize the name. We prevent reading back</span><br><span class="line">	 * the name, and force the use of dev_name()</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;init_name) &#123;</span><br><span class="line">		dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, dev-&gt;init_name); //设置dev-&gt;kobj的name</span><br><span class="line">		dev-&gt;init_name = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* subsystems can specify simple device enumeration */</span><br><span class="line">	<span class="keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">		dev_set_name(dev, <span class="string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev_name(dev)) &#123;</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		goto name_error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);</span><br><span class="line"></span><br><span class="line">	parent = get_device(dev-&gt;parent);</span><br><span class="line">	kobj = get_device_parent(dev, parent);</span><br><span class="line">	<span class="keyword">if</span> (kobj)</span><br><span class="line">		dev-&gt;kobj.parent = kobj;</span><br><span class="line"></span><br><span class="line">	/* use parent numa_node */</span><br><span class="line">	<span class="keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE))</span><br><span class="line">		set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">	/* first, register with generic layer. */</span><br><span class="line">	/* we require the name to be <span class="built_in">set</span> before, and pass NULL */</span><br><span class="line">	error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		glue_dir = get_glue_dir(dev);</span><br><span class="line">		goto Error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* notify platform of device entry */</span><br><span class="line">	<span class="keyword">if</span> (platform_notify)</span><br><span class="line">		platform_notify(dev);</span><br><span class="line"></span><br><span class="line">	error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto attrError;</span><br><span class="line"></span><br><span class="line">	error = device_add_class_symlinks(dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto SymlinkError;</span><br><span class="line">	error = device_add_attrs(dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto AttrsError;</span><br><span class="line">	error = bus_add_device(dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto BusError;</span><br><span class="line">	error = dpm_sysfs_add(dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto DPMError;</span><br><span class="line">	device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">		error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			goto DevAttrError;</span><br><span class="line"></span><br><span class="line">		error = device_create_sys_dev_entry(dev);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			goto SysEntryError;</span><br><span class="line"></span><br><span class="line">		devtmpfs_create_node(dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Notify clients of device addition.  This call must come</span><br><span class="line">	 * after dpm_sysfs_add() and before kobject_uevent().</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">		blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					     BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line">	bus_probe_device(dev);</span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">			       &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">		mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">		/* tie the class to the device */</span><br><span class="line">		klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">			       &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">		/* notify any interfaces that the device is here */</span><br><span class="line">		list_for_each_entry(class_intf,</span><br><span class="line">				    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">			<span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">				class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">		mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">done</span>:</span><br><span class="line">	put_device(dev);</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line"> SysEntryError:</span><br><span class="line">	<span class="keyword">if</span> (MAJOR(dev-&gt;devt))</span><br><span class="line">		device_remove_file(dev, &amp;dev_attr_dev);</span><br><span class="line"> DevAttrError:</span><br><span class="line">	device_pm_remove(dev);</span><br><span class="line">	dpm_sysfs_remove(dev);</span><br><span class="line"> DPMError:</span><br><span class="line">	bus_remove_device(dev);</span><br><span class="line"> BusError:</span><br><span class="line">	device_remove_attrs(dev);</span><br><span class="line"> AttrsError:</span><br><span class="line">	device_remove_class_symlinks(dev);</span><br><span class="line"> SymlinkError:</span><br><span class="line">	device_remove_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"> attrError:</span><br><span class="line">	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);</span><br><span class="line">	glue_dir = get_glue_dir(dev);</span><br><span class="line">	kobject_del(&amp;dev-&gt;kobj);</span><br><span class="line"> Error:</span><br><span class="line">	cleanup_glue_dir(dev, glue_dir);</span><br><span class="line">	put_device(parent);</span><br><span class="line">name_error:</span><br><span class="line">	kfree(dev-&gt;p);</span><br><span class="line">	dev-&gt;p = NULL;</span><br><span class="line">	goto <span class="keyword">done</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_add);</span><br></pre></td></tr></table></figure>
<p>这里重点关注两个函数：<br>bus_add_device函数将device-&gt;device_private-&gt;knode_bus加入到bus_type-&gt;subsys_private-&gt;klist_devices链表中去。<br>bus_probe_device(dev);函数执行device_initial_probe(dev);<br>以及bus_type-&gt;subsys_private-&gt;interfaces链表结构体里的add_dev函数<br>下面看下bus_probe_device函数的调用层级关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bus_probe_device(dev);</span><br><span class="line">	device_initial_probe(dev);</span><br><span class="line">		__device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">		bus_for_each_drv(dev-&gt;bus, NULL, &amp;data,</span><br><span class="line">					__device_attach_driver);</span><br><span class="line">			klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,</span><br><span class="line">			     start ? &amp;start-&gt;p-&gt;knode_bus : NULL);</span><br><span class="line">			<span class="keyword">while</span> ((drv = next_driver(&amp;i)) &amp;&amp; !error)</span><br><span class="line">			error = fn(drv, data);</span><br><span class="line">			/* fn就是__device_attach_driver*/</span><br><span class="line">				driver_probe_device(drv, dev);</span><br><span class="line">					ret = really_probe(dev, drv);</span><br><span class="line">							<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">								ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">								<span class="keyword">if</span> (ret)</span><br><span class="line">									goto probe_failed;</span><br><span class="line">							&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">								ret = drv-&gt;probe(dev);</span><br><span class="line">								<span class="keyword">if</span> (ret)</span><br><span class="line">									goto probe_failed;</span><br><span class="line">							&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后调用bus-&gt;probe如果定义了这个函数，否则调用drv的probe函数<br><strong>get_device</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device *get_device(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> dev ? kobj_to_dev(kobject_get(&amp;dev-&gt;kobj)) : NULL;</span><br><span class="line">&#125;</span><br><span class="line">struct kobject *kobject_get(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">			WARN(1, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">			       <span class="string">&quot;initialized, yet kobject_get() is being &quot;</span></span><br><span class="line">			       <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">		kref_get(&amp;kobj-&gt;kref);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> kobj;</span><br><span class="line">&#125;</span><br><span class="line">static inline void kref_get(struct kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">	refcount_inc(&amp;kref-&gt;refcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>device</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-devres</title>
    <url>/2019/09/06/linux-kernel-devres/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个设备能工作，需要依赖很多的外部条件，如供电、时钟等等，这些外部条件称作设备资源（device resouce）。对于现代计算机的体系结构，可能的资源包括：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a）power，供电。</span><br><span class="line">b）clock，时钟。</span><br><span class="line">c）memory，内存，在kernel中一般使用kzalloc分配。</span><br><span class="line">d）GPIO，用户和CPU交换简单控制、状态等信息。</span><br><span class="line">e）IRQ，触发中断。</span><br><span class="line">f）DMA，无CPU参与情况下进行数据传输。</span><br><span class="line">g）虚拟地址空间，一般使用ioremap、request_region等分配。</span><br><span class="line">h）等等</span><br></pre></td></tr></table></figure>
<p>而在Linux kernel的眼中，“资源”的定义更为广义，比如PWM、RTC、Reset，都可以抽象为资源，供driver使用。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct devres &#123;</span><br><span class="line">	struct devres_node		node; //用于将devres组织起来，方便插入到device结构的devres_head链表中，因此一定也有一个list_head（见下面的entry）</span><br><span class="line">	/* -- 3 pointers */</span><br><span class="line">	unsigned long long		data[];	/* guarantee ull alignment */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于0长度数组<br>零长度数组的英文原名为Arrays of Length Zero，是GNU C的规范，主要用途是用来作为结构体的最后一个成员，然后用它来访问此结构体对象之后的一段内存（通常是动态分配的内存）。</p>
<p>以struct devres为例，node变量的长度为3个指针的长度，而struct devres的长度也是3个指针的长度。而data只是一个标记，当有人分配了大于3个指针长度的空间并把它转换为struct devres类型的变量后，我们就可以通过data来访问多出来的memory。也就是说，有了零长度数组data，struct devres结构的长度可以不定，完全依赖于你分配的空间的大小。有什么用呢？</p>
<p>以本文的应用场景为例，多出来的、可通过data访问的空间，正是具体的device resource所占的空间。资源的类型不同，占用的空间的多少也不同，但devres模块的主要功能又是释放资源所占的资源。这是就是零长度数组的功能之一，因为整个memory空间是连续的，因此可以通过释devres指针，释放所有的空间，包括data所指的那片不定长度的、具体资源所用的空间。</p>
<h3 id="API（IRQ）"><a href="#API（IRQ）" class="headerlink" title="API（IRQ）"></a>API（IRQ）</h3><p><img src="/picture/devres.gif" alt="结构"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Device resource management aware IRQ request/free implementation.</span><br><span class="line"> */</span><br><span class="line">struct irq_devres &#123;</span><br><span class="line">	unsigned int irq; //中断资源 irq num</span><br><span class="line">	void *dev_id;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">static void devm_irq_release(struct device *dev, void *res)</span><br><span class="line">&#123;</span><br><span class="line">	struct irq_devres *this = res;</span><br><span class="line"></span><br><span class="line">	free_irq(this-&gt;irq, this-&gt;dev_id);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,</span><br><span class="line">		 unsigned long irqflags, const char *devname, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> devm_request_threaded_irq(dev, irq, handler, NULL, irqflags,</span><br><span class="line">					 devname, dev_id);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">int devm_request_threaded_irq(struct device *dev, unsigned int irq,</span><br><span class="line">			      irq_handler_t handler, irq_handler_t thread_fn,</span><br><span class="line">			      unsigned long irqflags, const char *devname,</span><br><span class="line">			      void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct irq_devres *dr;</span><br><span class="line">	int rc;</span><br><span class="line"></span><br><span class="line">	dr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),</span><br><span class="line">			  GFP_KERNEL); //以回调函数、resource的size为参数，调用devres_alloc接口，为resource分配空间</span><br><span class="line">	<span class="keyword">if</span> (!dr)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!devname)</span><br><span class="line">		devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">	/* 调用原来的中断注册接口（这里是request_threaded_irq），注册中断 */</span><br><span class="line">	rc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,</span><br><span class="line">				  dev_id);</span><br><span class="line">	<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">		devres_free(dr);</span><br><span class="line">		<span class="built_in">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dr-&gt;irq = irq;</span><br><span class="line">	dr-&gt;dev_id = dev_id;</span><br><span class="line">	/* 注册成功后，以设备指针（dev）和资源指针（dr）为参数，调用devres_add，将资源添加到设备的资源链表头（devres_head）中 */</span><br><span class="line">	devres_add(dev, dr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(devm_request_threaded_irq);\</span><br><span class="line">...</span><br><span class="line">void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct irq_devres match_data = &#123; irq, dev_id &#125;;</span><br><span class="line"></span><br><span class="line">	WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,</span><br><span class="line">			       &amp;match_data));</span><br><span class="line">	free_irq(irq, dev_id);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(devm_free_irq);</span><br><span class="line"></span><br><span class="line"><span class="comment">#define devres_alloc(release, size, gfp) \</span></span><br><span class="line">	__devres_alloc_node(release, size, gfp, NUMA_NO_NODE, <span class="comment">#release)</span></span><br><span class="line">...</span><br><span class="line">void * __devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp, int nid,</span><br><span class="line">		      const char *name)</span><br><span class="line">&#123;</span><br><span class="line">	struct devres *dr;</span><br><span class="line"></span><br><span class="line">	dr = alloc_dr(release, size, gfp | __GFP_ZERO, nid);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dr))</span><br><span class="line">		<span class="built_in">return</span> NULL;</span><br><span class="line">	set_node_dbginfo(&amp;dr-&gt;node, name, size);</span><br><span class="line">	<span class="built_in">return</span> dr-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__devres_alloc_node);</span><br><span class="line">...</span><br><span class="line">// 分配一个struct devres类型的变量，并返回其中的data指针</span><br><span class="line">static __always_inline struct devres * alloc_dr(dr_release_t release,</span><br><span class="line">						size_t size, gfp_t gfp, int nid)</span><br><span class="line">&#123;</span><br><span class="line">	/* 在资源size之前，加一个struct devres的size，就是total分配的空间。除去struct devres的，就是资源的（由data指针访问）。之后是初始化struct devres变量的node */</span><br><span class="line">	size_t tot_size = sizeof(struct devres) + size;</span><br><span class="line">	struct devres *dr;</span><br><span class="line"></span><br><span class="line">	dr = kmalloc_node_track_caller(tot_size, gfp, nid);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dr))</span><br><span class="line">		<span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	memset(dr, 0, offsetof(struct devres, data));</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;dr-&gt;node.entry);</span><br><span class="line">	dr-&gt;node.release = release;</span><br><span class="line">	<span class="built_in">return</span> dr;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void devres_add(struct device *dev, void *res)</span><br><span class="line">&#123;</span><br><span class="line">	struct devres *dr = container_of(res, struct devres, data);</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;devres_lock, flags);</span><br><span class="line">	add_dr(dev, &amp;dr-&gt;node);</span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;devres_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devres_add);</span><br><span class="line">...</span><br><span class="line">static void add_dr(struct device *dev, struct devres_node *node)</span><br><span class="line">&#123;</span><br><span class="line">	devres_log(dev, node, <span class="string">&quot;ADD&quot;</span>);</span><br><span class="line">	BUG_ON(!list_empty(&amp;node-&gt;entry));</span><br><span class="line">	list_add_tail(&amp;node-&gt;entry, &amp;dev-&gt;devres_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>devres_release_all</strong><br>释放申请到的资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int devres_release_all(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	/* Looks like an uninitialized device structure */</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(dev-&gt;devres_head.next == NULL))</span><br><span class="line">		<span class="built_in">return</span> -ENODEV;</span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;devres_lock, flags);</span><br><span class="line">	<span class="built_in">return</span> release_nodes(dev, dev-&gt;devres_head.next, &amp;dev-&gt;devres_head,</span><br><span class="line">			     flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>release_nodes</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int release_nodes(struct device *dev, struct list_head *first,</span><br><span class="line">			 struct list_head *end, unsigned long flags)</span><br><span class="line">	__releases(&amp;dev-&gt;devres_lock)</span><br><span class="line">&#123;</span><br><span class="line">	LIST_HEAD(todo);</span><br><span class="line">	int cnt;</span><br><span class="line">	struct devres *dr, *tmp;</span><br><span class="line"></span><br><span class="line">	/* 将设备所有的struct devres指针从设备的devres_head中移除 */</span><br><span class="line">	cnt = remove_nodes(dev, first, end, &amp;todo);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;devres_lock, flags);</span><br><span class="line"></span><br><span class="line">	/* Release.  Note that both devres and devres_group are</span><br><span class="line">	 * handled as devres <span class="keyword">in</span> the following loop.  This is safe.</span><br><span class="line">	 */</span><br><span class="line">	list_for_each_entry_safe_reverse(dr, tmp, &amp;todo, node.entry) &#123;</span><br><span class="line">		devres_log(dev, &amp;dr-&gt;node, <span class="string">&quot;REL&quot;</span>);</span><br><span class="line">		dr-&gt;node.release(dev, dr-&gt;data);//调用所有资源的release回调函数</span><br><span class="line">		kfree(dr); //调用free，释放devres以及资源所占的空间</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>devres</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-driver</title>
    <url>/2019/09/09/linux-kernel-driver/</url>
    <content><![CDATA[<h3 id="一、Initialization"><a href="#一、Initialization" class="headerlink" title="一、Initialization"></a>一、Initialization</h3><p>The driver must initialize at least the name and bus fields. It should<br>also initialize the devclass field (when it arrives), so it may obtain<br>the proper linkage internally. It should also initialize as many of<br>the callbacks as possible, though each is optional.</p>
<p>static struct device_driver eepro100_driver = {<br>       .name        = “eepro100”,<br>       .bus        = &amp;pci_bus_type,</p>
<pre><code>   .probe        = eepro100_probe,
   .remove        = eepro100_remove,
   .suspend        = eepro100_suspend,
   .resume        = eepro100_resume,</code></pre>
<p>};</p>
<p>struct pci_driver {<br>       const struct pci_device_id *id_table;<br>       struct device_driver      driver;<br>};</p>
<p>A definition that included bus-specific fields would look like<br>(using the eepro100 driver again):</p>
<p>static struct pci_driver eepro100_driver = {<br>       .id_table       = eepro100_pci_tbl,<br>       .driver           = {<br>        .name        = “eepro100”,<br>        .bus        = &amp;pci_bus_type,<br>        .probe        = eepro100_probe,<br>        .remove        = eepro100_remove,<br>        .suspend    = eepro100_suspend,<br>        .resume        = eepro100_resume,<br>       },<br>};</p>
<h3 id="二、Callbacks"><a href="#二、Callbacks" class="headerlink" title="二、Callbacks"></a>二、Callbacks</h3><p>int    (*probe)    (struct device * dev);</p>
<p>The probe() entry is called in task context, with the bus’s rwsem locked<br>and the driver partially bound to the device.  Drivers commonly use<br>container_of() to convert “dev” to a bus-specific type, both in probe()<br>and other routines.  That type often provides device resource data, such<br>as pci_dev.resource[] or platform_device.resources, which is used in<br>addition to dev-&gt;platform_data to initialize the driver.</p>
<p>This callback holds the driver-specific logic to bind the driver to a<br>given device.  That includes verifying that the device is present, that<br>it’s a version the driver can handle, that driver data structures can<br>be allocated and initialized, and that any hardware can be initialized.<br>Drivers often store a pointer to their state with dev_set_drvdata().<br>When the driver has successfully bound itself to that device, then probe()<br>returns zero and the driver model code will finish its part of binding<br>the driver to that device.</p>
<p>A driver’s probe() may return a negative errno value to indicate that<br>the driver did not bind to this device, in which case it should have<br>released all resources it allocated.</p>
<pre><code>int     (*remove)    (struct device * dev);</code></pre>
<p>remove is called to unbind a driver from a device. This may be<br>called if a device is physically removed from the system, if the<br>driver module is being unloaded, during a reboot sequence, or<br>in other cases.</p>
<p>It is up to the driver to determine if the device is present or<br>not. It should free any resources allocated specifically for the<br>device; i.e. anything in the device’s driver_data field. </p>
<p>If the device is still present, it should quiesce the device and place<br>it into a supported low-power state.</p>
<pre><code>int    (*suspend)    (struct device * dev, pm_message_t state);</code></pre>
<p>suspend is called to put the device in a low power state.</p>
<pre><code>int    (*resume)    (struct device * dev);</code></pre>
<p>Resume is used to bring a device back from a low power state.</p>
<h3 id="三、Attributes"><a href="#三、Attributes" class="headerlink" title="三、Attributes"></a>三、Attributes</h3><p>struct driver_attribute {<br>        struct attribute        attr;<br>        ssize_t (*show)(struct device_driver *driver, char *buf);<br>        ssize_t (*store)(struct device_driver *, const char * buf, size_t count);<br>};</p>
<p>Device drivers can export attributes via their sysfs directories.<br>Drivers can declare attributes using a DRIVER_ATTR_RW and DRIVER_ATTR_RO<br>macro that works identically to the DEVICE_ATTR_RW and DEVICE_ATTR_RO<br>macros.</p>
<p>DRIVER_ATTR_RW(debug);</p>
<p>This is equivalent to declaring:</p>
<p>struct driver_attribute driver_attr_debug;</p>
<p>This can then be used to add and remove the attribute from the<br>driver’s directory using:</p>
<p>int driver_create_file(struct device_driver *, const struct driver_attribute *);<br>void driver_remove_file(struct device_driver *, const struct driver_attribute *);</p>
<h3 id="四、数据结构"><a href="#四、数据结构" class="headerlink" title="四、数据结构"></a>四、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device_driver &#123;</span><br><span class="line">	const char		*name; //该driver的名称</span><br><span class="line">	struct bus_type		*bus; //该driver所驱动设备的总线设备。为什么driver需要记录总线设备的指针呢？因为内核要保证在driver运行前，设备所依赖的总线能够正确初始化。</span><br><span class="line"></span><br><span class="line">	struct module		*owner;</span><br><span class="line">	const char		*mod_name;	/* used <span class="keyword">for</span> built-in modules */</span><br><span class="line"></span><br><span class="line">	bool suppress_bind_attrs;	/* disables <span class="built_in">bind</span>/unbind via sysfs */ //<span class="built_in">bind</span>/unbind是从用户空间手动的为driver绑定/解绑定指定的设备的机制。这种机制是在bus.c中完成的</span><br><span class="line">	enum probe_type probe_type; //	Type of the probe (synchronous or asynchronous) to use</span><br><span class="line"></span><br><span class="line">	const struct of_device_id	*of_match_table;</span><br><span class="line">	const struct acpi_device_id	*acpi_match_table;</span><br><span class="line"></span><br><span class="line">	int (*probe) (struct device *dev);</span><br><span class="line">	int (*remove) (struct device *dev); device和driver之间的探测</span><br><span class="line">	void (*shutdown) (struct device *dev);</span><br><span class="line">	int (*<span class="built_in">suspend</span>) (struct device *dev, pm_message_t state);</span><br><span class="line">	int (*resume) (struct device *dev); //电源管理相关</span><br><span class="line">	const struct attribute_group **groups; //和struct device结构中的同名变量类似，driver也可以定义一些默认attribute，这样在将driver注册到内核中时，内核设备模型部分的代码（driver/base/driver.c）会自动将这些attribute添加到sysfs中。</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm; //Power management operations of the device <span class="built_in">which</span> matched</span><br><span class="line"> *		this driver</span><br><span class="line">	int (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">	struct driver_private *p; //driver core的私有数据指针，其它模块不能访问</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct driver_private &#123;</span><br><span class="line">	struct kobject kobj;</span><br><span class="line">	struct klist klist_devices;</span><br><span class="line">	struct klist_node knode_bus;</span><br><span class="line">	struct module_kobject *mkobj;</span><br><span class="line">	struct device_driver *driver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>attrbute</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* interface <span class="keyword">for</span> exporting device attributes */</span><br><span class="line">struct driver_attribute &#123;</span><br><span class="line">	struct attribute attr;</span><br><span class="line">	ssize_t (*show)(struct device_driver *driver, char *buf);</span><br><span class="line">	ssize_t (*store)(struct device_driver *driver, const char *buf,</span><br><span class="line">			 size_t count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __ATTR(_name, _mode, _show, _store) &#123;				\</span></span><br><span class="line">	.attr = &#123;.name = __stringify(_name),				\</span><br><span class="line">		 .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,		\</span><br><span class="line">	.show	= _show,						\</span><br><span class="line">	.store	= _store,						\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __ATTR_RW(_name) __ATTR(_name, 0644, _name##_show, _name##_store)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DRIVER_ATTR_RW(_name) \</span></span><br><span class="line">	struct driver_attribute driver_attr_<span class="comment">##_name = __ATTR_RW(_name)</span></span><br><span class="line"><span class="comment">#define DRIVER_ATTR_RO(_name) \</span></span><br><span class="line">	struct driver_attribute driver_attr_<span class="comment">##_name = __ATTR_RO(_name)</span></span><br><span class="line"><span class="comment">#define DRIVER_ATTR_WO(_name) \</span></span><br><span class="line">	struct driver_attribute driver_attr_<span class="comment">##_name = __ATTR_WO(_name)</span></span><br></pre></td></tr></table></figure>
<h3 id="五、API"><a href="#五、API" class="headerlink" title="五、API"></a>五、API</h3><p><strong>driver_register</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct device_driver *other;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!drv-&gt;bus-&gt;p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">	    (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">	    (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">			<span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">	<span class="keyword">if</span> (other) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">			<span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		<span class="built_in">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = bus_add_driver(drv);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		bus_remove_driver(drv);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(driver_register);</span><br></pre></td></tr></table></figure>
<p>在bus_add_driver这个函数里仍然去执行bus的probe，match函数，如果没定义就执行driver的probe函数。<br>driver_add_groups这个函数given a directory kobject, create a bunch of attribute groups。</p>
<h3 id="六、root-device"><a href="#六、root-device" class="headerlink" title="六、root device"></a>六、root device</h3><p>在sysfs中有这样一个目录：/sys/devices，系统中所有的设备，都归集在该目录下。有些设备，是通过device_register注册到Kernel并体现在/sys/devices/xxx/下。但有时候我们仅仅需要在/sys/devices/下注册一个目录，该目录不代表任何的实体设备，这时可以使用下面的接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Root device objects <span class="keyword">for</span> grouping under /sys/devices</span><br><span class="line"> */</span><br><span class="line">extern struct device *__root_device_register(const char *name,</span><br><span class="line">					     struct module *owner);</span><br><span class="line"></span><br><span class="line">/* This is a macro to avoid include problems with THIS_MODULE */</span><br><span class="line"><span class="comment">#define root_device_register(name) \</span></span><br><span class="line">	__root_device_register(name, THIS_MODULE)</span><br><span class="line">...</span><br><span class="line">struct device *__root_device_register(const char *name, struct module *owner)</span><br><span class="line">&#123;</span><br><span class="line">	struct root_device *root;</span><br><span class="line">	int err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	root = kzalloc(sizeof(struct root_device), GFP_KERNEL); //分配内存</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(err);</span><br><span class="line"></span><br><span class="line">	err = dev_set_name(&amp;root-&gt;dev, <span class="string">&quot;%s&quot;</span>, name);//设置名称</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		kfree(root);</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	root-&gt;dev.release = root_device_release;</span><br><span class="line"></span><br><span class="line">	err = device_register(&amp;root-&gt;dev); //注册设备</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		put_device(&amp;root-&gt;dev);</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_MODULES	/* gotta find a &quot;cleaner&quot; way to do this */</span></span><br><span class="line">	<span class="keyword">if</span> (owner) &#123;</span><br><span class="line">		struct module_kobject *mk = &amp;owner-&gt;mkobj;</span><br><span class="line"></span><br><span class="line">		err = sysfs_create_link(&amp;root-&gt;dev.kobj, &amp;mk-&gt;kobj, <span class="string">&quot;module&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			device_unregister(&amp;root-&gt;dev);</span><br><span class="line">			<span class="built_in">return</span> ERR_PTR(err);</span><br><span class="line">		&#125;</span><br><span class="line">		root-&gt;owner = owner;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> &amp;root-&gt;dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__root_device_register);</span><br></pre></td></tr></table></figure>
<h3 id="七、驱动开发步骤"><a href="#七、驱动开发步骤" class="headerlink" title="七、驱动开发步骤"></a>七、驱动开发步骤</h3><ol>
<li>分配一个struct device类型的变量，填充必要的信息后，把它注册到内核中</li>
<li>分配一个struct device_driver类型的变量，填充必要的信息后，把它注册到内核中</li>
</ol>
<p>说明：</p>
<ol>
<li> 一般情况下，Linux驱动开发很少直接使用device和device_driver，因为内核在它们之上又封装了一层，如soc device、platform device等等，而这些层次提供的接口更为简单、易用</li>
<li>内核提供很多struct device结构的操作接口（具体可以参考include/linux/device.h和drivers/base/core.c的代码），主要包括初始化（device_initialize）、注册到内核（device_register）、分配存储空间+初始化+注册到内核（device_create）等等，可以根据需要使用。</li>
<li>device和device_driver必须具备相同的名称，内核才能完成匹配操作，进而调用device_driver中的相应接口。这里的同名，作用范围是同一个bus下的所有device和device_driver</li>
<li>device和device_driver必须挂载在一个bus之下，该bus可以是实际存在的，也可以是虚拟的</li>
<li>driver开发者可以在struct device变量中，保存描述设备特征的信息，如寻址空间、依赖的GPIOs等，因为device指针会在执行probe等接口时传入，这时driver就可以根据这些信息，执行相应的逻辑操作了</li>
</ol>
<h3 id="八、probe的执行"><a href="#八、probe的执行" class="headerlink" title="八、probe的执行"></a>八、probe的执行</h3><p>设备驱动prove的时机有如下几种（分为自动触发和手动触发）：<br>将struct device类型的变量注册到内核中时自动触发（device_register，device_add，device_create_vargs，device_create）<br>将struct device_driver类型的变量注册到内核中时自动触发（driver_register）<br>手动查找同一bus下的所有device_driver，如果有和指定device同名的driver，执行probe操作（device_attach）<br>手动查找同一bus下的所有device，如果有和指定driver同名的device，执行probe操作（driver_attach）<br>自行调用driver的probe接口，并在该接口中将该driver绑定到某个device结构中—-即设置dev-&gt;driver（device_bind_driver）</p>
<p>说明：</p>
<ol>
<li>：probe动作实际是由bus模块（会在下一篇文章讲解）实现的，这不难理解：device和device_driver都是挂载在bus这根线上，因此只有bus最清楚应该为哪些device、哪些driver配对</li>
<li>每个bus都有一个drivers_autoprobe变量，用于控制是否在device或者driver注册时，自动probe。该变量默认为1（即自动probe），bus模块将它开放到sysfs中了，因而可在用户空间修改，进而控制probe行为</li>
</ol>
<h3 id="九、driver-attribute"><a href="#九、driver-attribute" class="headerlink" title="九、driver_attribute"></a>九、driver_attribute</h3><p>大多数时候，attribute文件的读写数据流为：vfs—-&gt;sysfs—-&gt;kobject—-&gt;attibute—-&gt;kobj_type—-&gt;sysfs_ops—-&gt;xxx_attribute，其中kobj_type、sysfs_ops和xxx_attribute都是由包含kobject的上层数据结构实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* sysfs interface <span class="keyword">for</span> exporting driver attributes */</span><br><span class="line">struct driver_attribute &#123;</span><br><span class="line">	struct attribute attr;</span><br><span class="line">	ssize_t (*show)(struct device_driver *driver, char *buf);</span><br><span class="line">	ssize_t (*store)(struct device_driver *driver, const char *buf,</span><br><span class="line">			 size_t count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __ATTR(_name, _mode, _show, _store) &#123;				\</span></span><br><span class="line">	.attr = &#123;.name = __stringify(_name),				\</span><br><span class="line">		 .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,		\</span><br><span class="line">	.show	= _show,						\</span><br><span class="line">	.store	= _store,						\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __ATTR_RW(_name) __ATTR(_name, 0644, _name##_show, _name##_store)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DRIVER_ATTR_RW(_name) \</span></span><br><span class="line">	struct driver_attribute driver_attr_<span class="comment">##_name = __ATTR_RW(_name)</span></span><br><span class="line"><span class="comment">#define DRIVER_ATTR_RO(_name) \</span></span><br><span class="line">	struct driver_attribute driver_attr_<span class="comment">##_name = __ATTR_RO(_name)</span></span><br><span class="line"><span class="comment">#define DRIVER_ATTR_WO(_name) \</span></span><br><span class="line">	struct driver_attribute driver_attr_<span class="comment">##_name = __ATTR_WO(_name)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-driverBus</title>
    <url>/2019/09/05/linux-kernel-driverBus/</url>
    <content><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>在Linux设备模型中，Bus（总线）是一类特殊的设备，它是连接处理器和其它设备之间的通道（channel）。为了方便设备模型的实现，内核规定，系统中的每个设备都要连接在一个Bus上，这个Bus可以是一个内部Bus、虚拟Bus或者Platform Bus。内核通过struct bus_type结构，抽象Bus，它是在include/linux/device.h中定义的。</p>
<h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct bus_type &#123;</span><br><span class="line">	const char		*name; //该bus的名称，会在sysfs中以目录的形式存在，如platform bus在sysfs中表现为<span class="string">&quot;/sys/bus/platform&quot;</span></span><br><span class="line">	const char		*dev_name; //该名称和_device和device driver所讲述的struct device结构中的init_name有关对有些设备而言（例如批量化的USB设备），设计者根本就懒得为它起名字的，而内核也支持这种懒惰，允许将设备的名字留空。这样当设备注册到内核后，设备模型的核心逻辑就会用<span class="string">&quot;bus-&gt;dev_name+device ID&quot;</span>的形式，为这样的设备生成一个名称。</span><br><span class="line">	struct device		*dev_root; //根据内核的注释，dev_root设备为bus的默认父设备（Default device to use as the parent），但在内核实际实现中，只和一个叫sub system的功能有关</span><br><span class="line">	const struct attribute_group **bus_groups;</span><br><span class="line">	const struct attribute_group **dev_groups;</span><br><span class="line">	const struct attribute_group **drv_groups;</span><br><span class="line"></span><br><span class="line">	int (*match)(struct device *dev, struct device_driver *drv); //个由具体的bus driver实现的回调函数。当任何属于该Bus的device或者device_driver添加到内核时，内核都会调用该接口，如果新加的device或device_driver匹配上了自己的另一半的话，该接口要返回非零值，此时Bus模块的核心逻辑就会执行后续的处理</span><br><span class="line">	int (*uevent)(struct device *dev, struct kobj_uevent_env *env); //uevent，一个由具体的bus driver实现的回调函数。当任何属于该Bus的device，发生添加、移除或者其它动作时，Bus模块的核心逻辑就会调用该接口，以便bus driver能够修改环境变量</span><br><span class="line">	int (*probe)(struct device *dev);</span><br><span class="line">	int (*remove)(struct device *dev); //probe、remove，这两个回调函数，和device_driver中的非常类似，但它们的存在是非常有意义的。可以想象一下，如果需要probe（其实就是初始化）指定的device话，需要保证该device所在的bus是被初始化过、确保能正确工作的。这就要就在执行device_driver的probe前，先执行它的bus的probe。remove的过程相反。</span><br><span class="line">	void (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*online)(struct device *dev);</span><br><span class="line">	int (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*<span class="built_in">suspend</span>)(struct device *dev, pm_message_t state);</span><br><span class="line">	int (*resume)(struct device *dev); //电源管理相关的实现</span><br><span class="line"></span><br><span class="line">	int (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm;</span><br><span class="line"></span><br><span class="line">	const struct iommu_ops *iommu_ops;</span><br><span class="line"></span><br><span class="line">	struct subsys_private *p; //一个struct subsys_private类型的指针</span><br><span class="line">	struct lock_class_key lock_key;</span><br><span class="line"></span><br><span class="line">	bool force_dma;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再看下struct subsys_private这个结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct subsys_private &#123;</span><br><span class="line">	struct kset subsys; //代表了本bus（如/sys/bus/spi），它下面可以包含其它的kset或者其它的kobject</span><br><span class="line">	struct kset *devices_kset; //包括本bus下所有的device</span><br><span class="line">	struct list_head interfaces; //是一个list head，用于保存该bus下所有的interface</span><br><span class="line">	struct mutex mutex;</span><br><span class="line"></span><br><span class="line">	struct kset *drivers_kset; //包括本bus下所有的device_driver</span><br><span class="line">	struct klist klist_devices; </span><br><span class="line">	struct klist klist_drivers; //klist_devices和klist_drivers是两个链表，分别保存了本bus下所有的device和device_driver的指针</span><br><span class="line">	struct blocking_notifier_head bus_notifier;</span><br><span class="line">	unsigned int drivers_autoprobe:1; //用于控制该bus下的drivers或者device是否自动probe</span><br><span class="line">	struct bus_type *bus;</span><br><span class="line"></span><br><span class="line">	struct kset glue_dirs;</span><br><span class="line">	struct class *class; //分别保存上层的bus或者class指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="三、相关操作"><a href="#三、相关操作" class="headerlink" title="三、相关操作"></a>三、相关操作</h3><p><strong>1. bus的注册</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static struct kset *bus_kset;</span><br><span class="line">int bus_register(struct bus_type *bus)</span><br><span class="line">&#123;</span><br><span class="line">	int retval;</span><br><span class="line">	struct subsys_private *priv;</span><br><span class="line">	struct lock_class_key *key = &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">	/* 为bus_type中struct subsys_private类型的指针分配空间，并更新priv-&gt;bus和bus-&gt;p两个指针为正确的值 */</span><br><span class="line">	priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	priv-&gt;bus = bus;</span><br><span class="line">	bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	/* 初始化priv-&gt;subsys.kobj的name、kset、ktype等字段，启动name就是该bus的name（它会体现在sysfs中），kset和ktype由bus模块实现，分别为bus_kset和bus_ktype */</span><br><span class="line">	retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe = 1;</span><br><span class="line"></span><br><span class="line">	/* 调用kset_register将priv-&gt;subsys注册到内核中，该接口同时会向sysfs中添加对应的目录（如/sys/bus/spi） */</span><br><span class="line">	retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/* 调用bus_create_file向bus目录下添加一个uevent attribute（如/sys/bus/spi/uevent） */</span><br><span class="line">	retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">	/* 调用kset_create_and_add分别向内核添加devices和device_drivers kset，同时会体现在sysfs中 */</span><br><span class="line">	priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, NULL,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		goto bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, NULL,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		goto bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">	/* 初始化priv指针中的mutex、klist_devices和klist_drivers等变量 */</span><br><span class="line">	__mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);</span><br><span class="line"></span><br><span class="line">	/* 调用add_probe_files接口，在bus下添加drivers_probe和drivers_autoprobe两个attribute（如/sys/bus/spi/drivers_probe和/sys/bus/spi/drivers_autoprobe），其中drivers_probe允许用户空间程序主动出发指定bus下的device_driver的probe动作，而drivers_autoprobe控制是否在device或device_driver添加到内核时，自动执行probe */</span><br><span class="line">	retval = add_probe_files(bus);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	/* 调用bus_add_groups */</span><br><span class="line">	retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto bus_groups_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">	remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">	bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">	kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">	kfree(bus-&gt;p);</span><br><span class="line">	bus-&gt;p = NULL;</span><br><span class="line">	<span class="built_in">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br><span class="line"></span><br><span class="line">int __init buses_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	bus_kset = kset_create_and_add(<span class="string">&quot;bus&quot;</span>, &amp;bus_uevent_ops, NULL);</span><br><span class="line">	<span class="keyword">if</span> (!bus_kset)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	system_kset = kset_create_and_add(<span class="string">&quot;system&quot;</span>, NULL, &amp;devices_kset-&gt;kobj);</span><br><span class="line">	<span class="keyword">if</span> (!system_kset)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2. device和device_driver的添加</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int bus_add_device(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct bus_type *bus = bus_get(dev-&gt;bus);</span><br><span class="line">	int error = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;</span>, bus-&gt;name, dev_name(dev));</span><br><span class="line">		/* device_add_groups */</span><br><span class="line">		error = device_add_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			goto out_put;</span><br><span class="line">		/* 调用sysfs_create_link接口，将该device在sysfs中的目录，链接到该bus的devices目录下，例如：</span><br><span class="line">		xxx<span class="comment"># ls /sys/bus/spi/devices/spi1.0 -l                                                        </span></span><br><span class="line">		lrwxrwxrwx root     root              2014-04-11 10:46 spi1.0 -&gt; ../../../devices/platform/s3c64xx-spi.1/spi_master/spi1/spi1.0</span><br><span class="line">		其中/sys/devices/…/spi1.0，为该device在sysfs中真正的位置，而为了方便管理，内核在该设备所在的bus的xxx_bus/devices目录中，创建了一个符号链接 */</span><br><span class="line">		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">						&amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			goto out_groups;</span><br><span class="line"></span><br><span class="line">		/* 调用sysfs_create_link接口，在该设备的sysfs目录中（如/sys/devices/platform/alarm/）中，创建一个指向该设备所在bus目录的链接，取名为subsystem，例如：</span><br><span class="line">		xxx <span class="comment"># ls /sys/devices/platform/alarm/subsystem -l                                                </span></span><br><span class="line">		lrwxrwxrwx root     root              2014-04-11 10:28 subsystem -&gt; ../../../bus/platform */</span><br><span class="line">		error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			goto out_subsys;</span><br><span class="line"></span><br><span class="line">		/* 把该设备指针保存在bus-&gt;priv-&gt;klist_devices中 */</span><br><span class="line">		klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">	sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_groups:</span><br><span class="line">	device_remove_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">out_put:</span><br><span class="line">	bus_put(dev-&gt;bus);</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">int bus_add_driver(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	struct bus_type *bus;</span><br><span class="line">	struct driver_private *priv;</span><br><span class="line">	int error = 0;</span><br><span class="line"></span><br><span class="line">	bus = bus_get(drv-&gt;bus);</span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	/* 为该driver的struct driver_private指针（priv）分配空间 */</span><br><span class="line">	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		goto out_put_bus;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 初始化其中的priv-&gt;klist_devices、priv-&gt;driver、priv-&gt;kobj.kset等变量，同时将该指针保存在device_driver的p处 */</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);</span><br><span class="line">	priv-&gt;driver = drv;</span><br><span class="line">	drv-&gt;p = priv;</span><br><span class="line">	/* 将driver的kset（priv-&gt;kobj.kset）设置为bus的drivers kset（bus-&gt;p-&gt;drivers_kset），这就意味着所有driver的kobject都位于bus-&gt;p-&gt;drivers_kset之下（寄/sys/bus/xxx/drivers目录下）*/</span><br><span class="line">	priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">	/* 以driver的名字为参数，调用kobject_init_and_add接口，在sysfs中注册driver的kobject，体现在/sys/bus/xxx/drivers/目录下，如/sys/bus/spi/drivers/spidev */</span><br><span class="line">	error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,</span><br><span class="line">				     <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto out_unregister;</span><br><span class="line"></span><br><span class="line">	/* 将该driver保存在bus的klist_drivers链表中，并根据drivers_autoprobe的值，选择是否调用driver_attach进行probe */</span><br><span class="line">	klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">		<span class="keyword">if</span> (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: probing driver %s asynchronously\n&quot;</span>,</span><br><span class="line">				drv-&gt;bus-&gt;name, drv-&gt;name);</span><br><span class="line">			async_schedule(driver_attach_async, drv);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			error = driver_attach(drv);</span><br><span class="line">			<span class="keyword">if</span> (error)</span><br><span class="line">				goto out_unregister;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">	/* 调用driver_create_file接口，在sysfs的该driver的目录下，创建uevent attribute */</span><br><span class="line">	error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		/* How the hell <span class="keyword">do</span> we get out of this pickle? Give up */</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 根据suppress_bind_attrs标志，决定是否在sysfs的该driver的目录下，创建<span class="built_in">bind</span>和unbind attribute */</span><br><span class="line">	<span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">		error = add_bind_files(drv);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;</span><br><span class="line">			/* Ditto */</span><br><span class="line">			printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">				__func__, drv-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">	kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">	/* drv-&gt;p is freed <span class="keyword">in</span> driver_release()  */</span><br><span class="line">	drv-&gt;p = NULL;</span><br><span class="line">out_put_bus:</span><br><span class="line">	bus_put(bus);</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3. driver的probe</strong><br>主要为bus_probe_device和driver_attach接口,这两个接口都是在drivers/base/base.h中声明，在drivers/base/bus.c中实现。这两个结构的行为类似，逻辑也很简单，既：搜索所在的bus，比对是否有同名的device_driver（或device），如果有并且该设备没有绑定Driver（注：这一点很重要，通过它，可以使同一个Driver，驱动相同名称的多个设备，后续在Platform设备的描述中会提及）则调用device_driver的probe接口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void bus_probe_device(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct bus_type *bus = dev-&gt;bus;</span><br><span class="line">	struct subsys_interface *sif;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus-&gt;p-&gt;drivers_autoprobe)</span><br><span class="line">		device_initial_probe(dev);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;bus-&gt;p-&gt;mutex);</span><br><span class="line">	list_for_each_entry(sif, &amp;bus-&gt;p-&gt;interfaces, node)</span><br><span class="line">		<span class="keyword">if</span> (sif-&gt;add_dev)</span><br><span class="line">			sif-&gt;add_dev(dev, sif);</span><br><span class="line">	mutex_unlock(&amp;bus-&gt;p-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>device_initial_probe调用__device_attach调用device_bind_driver调用driver_bound</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static void driver_bound(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (device_is_bound(dev)) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;%s: device %s already bound\n&quot;</span>,</span><br><span class="line">			__func__, kobject_name(&amp;dev-&gt;kobj));</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;driver: &#x27;%s&#x27;: %s: bound to device &#x27;%s&#x27;\n&quot;</span>, dev-&gt;driver-&gt;name,</span><br><span class="line">		 __func__, dev_name(dev));</span><br><span class="line"></span><br><span class="line">	klist_add_tail(&amp;dev-&gt;p-&gt;knode_driver, &amp;dev-&gt;driver-&gt;p-&gt;klist_devices);</span><br><span class="line">	device_links_driver_bound(dev);</span><br><span class="line"></span><br><span class="line">	device_pm_check_callbacks(dev);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Make sure the device is no longer <span class="keyword">in</span> one of the deferred lists and</span><br><span class="line">	 * kick off retrying all pending devices</span><br><span class="line">	 */</span><br><span class="line">	driver_deferred_probe_del(dev);</span><br><span class="line">	driver_deferred_probe_trigger();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">		blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					     BUS_NOTIFY_BOUND_DRIVER, dev);</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_BIND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>bus</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-dts.md</title>
    <url>/2019/12/27/linux-kernel-dts-md/</url>
    <content><![CDATA[<h3 id="一、-由stb生成device-nodes和truct-property结构体"><a href="#一、-由stb生成device-nodes和truct-property结构体" class="headerlink" title="一、 由stb生成device_nodes和truct property结构体"></a>一、 由stb生成device_nodes和truct property结构体</h3><p>其中device_node的定义如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device_node &#123;</span><br><span class="line">	const char *name;              /* node的名称，取最后一次“/”和“@”之间子串 */</span><br><span class="line">	const char *<span class="built_in">type</span>;              /* device_type的属性名称，没有为&lt;NULL&gt; */</span><br><span class="line">	phandle phandle;               /* phandle属性值 */</span><br><span class="line">	const char *full_name;        /* 指向该结构体结束的位置，存放node的路径全名，例如：/chosen */</span><br><span class="line">	struct fwnode_handle fwnode;</span><br><span class="line"> </span><br><span class="line">	struct	property *properties;  /* 指向该节点下的第一个属性，其他属性与该属性链表相接 */</span><br><span class="line">	struct	property *deadprops;   /* removed properties */</span><br><span class="line">	struct	device_node *parent;   /* 父节点 */</span><br><span class="line">	struct	device_node *child;    /* 子节点 */</span><br><span class="line">	struct	device_node *sibling;  /* 姊妹节点，与自己同等级的node */</span><br><span class="line">	struct	kobject kobj;            /* sysfs文件系统目录体现 */</span><br><span class="line">	unsigned long _flags;          /* 当前node状态标志位，见/include/linux/of.h line124-127 */</span><br><span class="line">	void	*data;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">struct property &#123;</span><br><span class="line">	char *name;                          /* property full name */</span><br><span class="line">	int length;                          /* property value length */</span><br><span class="line">	void *value;                         /* property value */</span><br><span class="line">	struct property *next;             /* next property under the same node */</span><br><span class="line">	unsigned long _flags;</span><br><span class="line">	unsigned int unique_id;</span><br><span class="line">	struct bin_attribute attr;        /* 属性文件，与sysfs文件系统挂接 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设备树解析从setup_arch开始调用unflatten_device_tree函数，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * unflatten_device_tree - create tree of device_nodes from flat blob</span><br><span class="line"> *</span><br><span class="line"> * unflattens the device-tree passed by the firmware, creating the</span><br><span class="line"> * tree of struct device_node. It also fills the <span class="string">&quot;name&quot;</span> and <span class="string">&quot;type&quot;</span></span><br><span class="line"> * pointers of the nodes so the normal device-tree walking <span class="built_in">functions</span></span><br><span class="line"> * can be used.</span><br><span class="line"> */</span><br><span class="line">void __init unflatten_device_tree(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * initial_boot_params指向Device Tree在内存中的首地址</span><br><span class="line">     * of_root在经过该函数处理之后，会指向根节点</span><br><span class="line">     */ early_init_dt_alloc_memory_arch是一个函数指针，为struct device_node和struct property结构体分配内存的回调函数（callback）</span><br><span class="line">	__unflatten_device_tree(initial_boot_params, &amp;of_root,</span><br><span class="line">				early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">	/* Get pointer to <span class="string">&quot;/chosen&quot;</span> and <span class="string">&quot;/aliases&quot;</span> nodes <span class="keyword">for</span> use everywhere */</span><br><span class="line">	of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * __unflatten_device_tree - create tree of device_nodes from flat blob</span><br><span class="line"> *</span><br><span class="line"> * unflattens a device-tree, creating the</span><br><span class="line"> * tree of struct device_node. It also fills the <span class="string">&quot;name&quot;</span> and <span class="string">&quot;type&quot;</span></span><br><span class="line"> * pointers of the nodes so the normal device-tree walking <span class="built_in">functions</span></span><br><span class="line"> * can be used.</span><br><span class="line"> * @blob: The blob to expand</span><br><span class="line"> * @mynodes: The device_node tree created by the call</span><br><span class="line"> * @dt_alloc: An allocator that provides a virtual address to memory</span><br><span class="line"> * <span class="keyword">for</span> the resulting tree</span><br><span class="line"> */</span><br><span class="line">static void __unflatten_device_tree(const void *blob,</span><br><span class="line">			     struct device_node **mynodes,</span><br><span class="line">			     void * (*dt_alloc)(u64 size, u64 align))</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long size;</span><br><span class="line">	int start;</span><br><span class="line">	void *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 得到Device Tree转换成struct device_node和struct property结构体需要分配的内存大小 */</span><br><span class="line">	/* First pass, scan <span class="keyword">for</span> size */</span><br><span class="line">	start = 0;</span><br><span class="line">	size = (unsigned long)unflatten_dt_node(blob, NULL, &amp;start, NULL, NULL, 0, <span class="literal">true</span>);</span><br><span class="line">	size = ALIGN(size, 4);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  size is %lx, allocating...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	/* Allocate memory <span class="keyword">for</span> the expanded device tree */</span><br><span class="line">	mem = dt_alloc(size + 4, __alignof__(struct device_node));</span><br><span class="line">	memset(mem, 0, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  unflattening %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	/* Second pass, <span class="keyword">do</span> actual unflattening */</span><br><span class="line">	start = 0;</span><br><span class="line">	unflatten_dt_node(blob, mem, &amp;start, NULL, mynodes, 0, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != 0xdeadbeef)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * unflatten_dt_node - Alloc and populate a device_node from the flat tree</span><br><span class="line"> * @blob: The parent device tree blob</span><br><span class="line"> * @mem: Memory chunk to use <span class="keyword">for</span> allocating device nodes and properties</span><br><span class="line"> * @poffset: pointer to node <span class="keyword">in</span> flat tree</span><br><span class="line"> * @dad: Parent struct device_node</span><br><span class="line"> * @nodepp: The device_node tree created by the call</span><br><span class="line"> * @fpsize: Size of the node path up at the current depth.</span><br><span class="line"> * @dryrun: If <span class="literal">true</span>, <span class="keyword">do</span> not allocate device nodes but still calculate needed</span><br><span class="line"> * memory size</span><br><span class="line"> */</span><br><span class="line">static void * unflatten_dt_node(const void *blob,</span><br><span class="line">				void *mem,</span><br><span class="line">				int *poffset,</span><br><span class="line">				struct device_node *dad,</span><br><span class="line">				struct device_node **nodepp,</span><br><span class="line">				unsigned long fpsize,</span><br><span class="line">				bool dryrun)</span><br><span class="line">&#123;</span><br><span class="line">	const __be32 *p;</span><br><span class="line">	struct device_node *np;</span><br><span class="line">	struct property *pp, **prev_pp = NULL;</span><br><span class="line">	const char *pathp;</span><br><span class="line">	unsigned int l, allocl;</span><br><span class="line">	static int depth;</span><br><span class="line">	int old_depth;</span><br><span class="line">	int offset;</span><br><span class="line">	int has_name = 0;</span><br><span class="line">	int new_format = 0;</span><br><span class="line"></span><br><span class="line">    /* 获取node节点的name指针到pathp中 */</span><br><span class="line">	pathp = fdt_get_name(blob, *poffset, &amp;l);</span><br><span class="line">	<span class="keyword">if</span> (!pathp)</span><br><span class="line">		<span class="built_in">return</span> mem;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;</span><br><span class="line"></span><br><span class="line">	/* version 0x10 has a more compact unit name here instead of the full</span><br><span class="line">	 * path. we accumulate the full path size using <span class="string">&quot;fpsize&quot;</span>, we<span class="string">&#x27;ll rebuild</span></span><br><span class="line"><span class="string">	 * it later. We detect this because the first character of the name is</span></span><br><span class="line"><span class="string">	 * not &#x27;</span>/<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if ((*pathp) != &#x27;</span>/<span class="string">&#x27;) &#123;</span></span><br><span class="line"><span class="string">		new_format = 1;</span></span><br><span class="line"><span class="string">		if (fpsize == 0) &#123;</span></span><br><span class="line"><span class="string">			/* root node: special case. fpsize accounts for path</span></span><br><span class="line"><span class="string">			 * plus terminating zero. root node only has &#x27;</span>/<span class="string">&#x27;, so</span></span><br><span class="line"><span class="string">			 * fpsize should be 2, but we want to avoid the first</span></span><br><span class="line"><span class="string">			 * level nodes to have two &#x27;</span>/<span class="string">&#x27; so we use fpsize 1 here</span></span><br><span class="line"><span class="string">			 */</span></span><br><span class="line"><span class="string">			fpsize = 1;</span></span><br><span class="line"><span class="string">			allocl = 2;</span></span><br><span class="line"><span class="string">			l = 1;</span></span><br><span class="line"><span class="string">			pathp = &quot;&quot;;</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			/* account for &#x27;</span>/<span class="string">&#x27; and path size minus terminal 0</span></span><br><span class="line"><span class="string">			 * already in &#x27;</span>l<span class="string">&#x27;</span></span><br><span class="line"><span class="string">			 */</span></span><br><span class="line"><span class="string">			fpsize += l;</span></span><br><span class="line"><span class="string">			allocl = fpsize;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">    /* 分配struct device_node内存，包括路径全称大小 */</span></span><br><span class="line"><span class="string">	np = unflatten_dt_alloc(&amp;mem, sizeof(struct device_node) + allocl,</span></span><br><span class="line"><span class="string">				__alignof__(struct device_node));</span></span><br><span class="line"><span class="string">	if (!dryrun) &#123;</span></span><br><span class="line"><span class="string">		char *fn;</span></span><br><span class="line"><span class="string">		of_node_init(np);</span></span><br><span class="line"><span class="string">        /* 填充full_name，full_name指向该node节点的全路径名称字符串 */</span></span><br><span class="line"><span class="string">		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);</span></span><br><span class="line"><span class="string">		if (new_format) &#123;</span></span><br><span class="line"><span class="string">			/* rebuild full path for new format */</span></span><br><span class="line"><span class="string">			if (dad &amp;&amp; dad-&gt;parent) &#123;</span></span><br><span class="line"><span class="string">				strcpy(fn, dad-&gt;full_name);</span></span><br><span class="line"><span class="string">#ifdef DEBUG</span></span><br><span class="line"><span class="string">				if ((strlen(fn) + l + 1) != allocl) &#123;</span></span><br><span class="line"><span class="string">					pr_debug(&quot;%s: p: %d, l: %d, a: %d\n&quot;,</span></span><br><span class="line"><span class="string">						pathp, (int)strlen(fn),</span></span><br><span class="line"><span class="string">						l, allocl);</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">				fn += strlen(fn);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			*(fn++) = &#x27;</span>/<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		memcpy(fn, pathp, l);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* 节点挂接到相应的父节点、子节点和姊妹节点 */</span></span><br><span class="line"><span class="string">		prev_pp = &amp;np-&gt;properties;</span></span><br><span class="line"><span class="string">		if (dad != NULL) &#123;</span></span><br><span class="line"><span class="string">			np-&gt;parent = dad;</span></span><br><span class="line"><span class="string">			np-&gt;sibling = dad-&gt;child;</span></span><br><span class="line"><span class="string">			dad-&gt;child = np;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">    /* 处理该node节点下面所有的property */</span></span><br><span class="line"><span class="string">	/* process properties */</span></span><br><span class="line"><span class="string">	for (offset = fdt_first_property_offset(blob, *poffset);</span></span><br><span class="line"><span class="string">	     (offset &gt;= 0);</span></span><br><span class="line"><span class="string">	     (offset = fdt_next_property_offset(blob, offset))) &#123;</span></span><br><span class="line"><span class="string">		const char *pname;</span></span><br><span class="line"><span class="string">		u32 sz;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if (!(p = fdt_getprop_by_offset(blob, offset, &amp;pname, &amp;sz))) &#123;</span></span><br><span class="line"><span class="string">			offset = -FDT_ERR_INTERNAL;</span></span><br><span class="line"><span class="string">			break;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if (pname == NULL) &#123;</span></span><br><span class="line"><span class="string">			pr_info(&quot;Can&#x27;</span>t find property name <span class="keyword">in</span> list !\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			break;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		if (strcmp(pname, &quot;</span>name<span class="string">&quot;) == 0)</span></span><br><span class="line"><span class="string">			has_name = 1;</span></span><br><span class="line"><span class="string">		pp = unflatten_dt_alloc(&amp;mem, sizeof(struct property),</span></span><br><span class="line"><span class="string">					__alignof__(struct property));</span></span><br><span class="line"><span class="string">		if (!dryrun) &#123;</span></span><br><span class="line"><span class="string">			/* We accept flattened tree phandles either in</span></span><br><span class="line"><span class="string">			 * ePAPR-style &quot;</span>phandle<span class="string">&quot; properties, or the</span></span><br><span class="line"><span class="string">			 * legacy &quot;</span>linux,phandle<span class="string">&quot; properties.  If both</span></span><br><span class="line"><span class="string">			 * appear and have different values, things</span></span><br><span class="line"><span class="string">			 * will get weird.  Don&#x27;t do that. */</span></span><br><span class="line"><span class="string">			if ((strcmp(pname, &quot;</span>phandle<span class="string">&quot;) == 0) ||</span></span><br><span class="line"><span class="string">			    (strcmp(pname, &quot;</span>linux,phandle<span class="string">&quot;) == 0)) &#123;</span></span><br><span class="line"><span class="string">				if (np-&gt;phandle == 0)</span></span><br><span class="line"><span class="string">					np-&gt;phandle = be32_to_cpup(p);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			/* And we process the &quot;</span>ibm,phandle<span class="string">&quot; property</span></span><br><span class="line"><span class="string">			 * used in pSeries dynamic device tree</span></span><br><span class="line"><span class="string">			 * stuff */</span></span><br><span class="line"><span class="string">			if (strcmp(pname, &quot;</span>ibm,phandle<span class="string">&quot;) == 0)</span></span><br><span class="line"><span class="string">				np-&gt;phandle = be32_to_cpup(p);</span></span><br><span class="line"><span class="string">			pp-&gt;name = (char *)pname;</span></span><br><span class="line"><span class="string">			pp-&gt;length = sz;</span></span><br><span class="line"><span class="string">			pp-&gt;value = (__be32 *)p;</span></span><br><span class="line"><span class="string">			*prev_pp = pp;</span></span><br><span class="line"><span class="string">			prev_pp = &amp;pp-&gt;next;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	/* with version 0x10 we may not have the name property, recreate</span></span><br><span class="line"><span class="string">	 * it here from the unit name if absent</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">    /* 为每个node节点添加一个name的属性 */</span></span><br><span class="line"><span class="string">	if (!has_name) &#123;</span></span><br><span class="line"><span class="string">		const char *p1 = pathp, *ps = pathp, *pa = NULL;</span></span><br><span class="line"><span class="string">		int sz;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* 属性name的value值为node节点的名称，取“/”和“@”之间的子串 */</span></span><br><span class="line"><span class="string">		while (*p1) &#123;</span></span><br><span class="line"><span class="string">			if ((*p1) == &#x27;@&#x27;)</span></span><br><span class="line"><span class="string">				pa = p1;</span></span><br><span class="line"><span class="string">			if ((*p1) == &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">				ps = p1 + 1;</span></span><br><span class="line"><span class="string">			p1++;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		if (pa &lt; ps)</span></span><br><span class="line"><span class="string">			pa = p1;</span></span><br><span class="line"><span class="string">		sz = (pa - ps) + 1;</span></span><br><span class="line"><span class="string">		pp = unflatten_dt_alloc(&amp;mem, sizeof(struct property) + sz,</span></span><br><span class="line"><span class="string">					__alignof__(struct property));</span></span><br><span class="line"><span class="string">		if (!dryrun) &#123;</span></span><br><span class="line"><span class="string">			pp-&gt;name = &quot;</span>name<span class="string">&quot;;</span></span><br><span class="line"><span class="string">			pp-&gt;length = sz;</span></span><br><span class="line"><span class="string">			pp-&gt;value = pp + 1;</span></span><br><span class="line"><span class="string">			*prev_pp = pp;</span></span><br><span class="line"><span class="string">			prev_pp = &amp;pp-&gt;next;</span></span><br><span class="line"><span class="string">			memcpy(pp-&gt;value, ps, sz - 1);</span></span><br><span class="line"><span class="string">			((char *)pp-&gt;value)[sz - 1] = 0;</span></span><br><span class="line"><span class="string">			pr_debug(&quot;</span>fixed up name <span class="keyword">for</span> %s -&gt; %s\n<span class="string">&quot;, pathp,</span></span><br><span class="line"><span class="string">				(char *)pp-&gt;value);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">    /* 填充device_node结构体中的name和type成员 */</span></span><br><span class="line"><span class="string">	if (!dryrun) &#123;</span></span><br><span class="line"><span class="string">		*prev_pp = NULL;</span></span><br><span class="line"><span class="string">		np-&gt;name = of_get_property(np, &quot;</span>name<span class="string">&quot;, NULL);</span></span><br><span class="line"><span class="string">		np-&gt;type = of_get_property(np, &quot;</span>device_type<span class="string">&quot;, NULL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if (!np-&gt;name)</span></span><br><span class="line"><span class="string">			np-&gt;name = &quot;</span>&lt;NULL&gt;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">		if (!np-&gt;type)</span></span><br><span class="line"><span class="string">			np-&gt;type = &quot;</span>&lt;NULL&gt;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	old_depth = depth;</span></span><br><span class="line"><span class="string">	*poffset = fdt_next_node(blob, *poffset, &amp;depth);</span></span><br><span class="line"><span class="string">	if (depth &lt; 0)</span></span><br><span class="line"><span class="string">		depth = 0;</span></span><br><span class="line"><span class="string">    /* 递归调用node节点下面的子节点 */</span></span><br><span class="line"><span class="string">	while (*poffset &gt; 0 &amp;&amp; depth &gt; old_depth)</span></span><br><span class="line"><span class="string">		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,</span></span><br><span class="line"><span class="string">					fpsize, dryrun);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (*poffset &lt; 0 &amp;&amp; *poffset != -FDT_ERR_NOTFOUND)</span></span><br><span class="line"><span class="string">		pr_err(&quot;</span>unflatten: error %d processing FDT\n<span class="string">&quot;, *poffset);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Reverse the child list. Some drivers assumes node order matches .dts</span></span><br><span class="line"><span class="string">	 * node order</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (!dryrun &amp;&amp; np-&gt;child) &#123;</span></span><br><span class="line"><span class="string">		struct device_node *child = np-&gt;child;</span></span><br><span class="line"><span class="string">		np-&gt;child = NULL;</span></span><br><span class="line"><span class="string">		while (child) &#123;</span></span><br><span class="line"><span class="string">			struct device_node *next = child-&gt;sibling;</span></span><br><span class="line"><span class="string">			child-&gt;sibling = np-&gt;child;</span></span><br><span class="line"><span class="string">			np-&gt;child = child;</span></span><br><span class="line"><span class="string">			child = next;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (nodepp)</span></span><br><span class="line"><span class="string">		*nodepp = np;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return mem;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过以上函数处理就得到了所有的struct device_node结构体，为每一个node都会自动添加一个名称为“name”的property</p>
<h3 id="二、-platform-device和device-node绑定"><a href="#二、-platform-device和device-node绑定" class="headerlink" title="二、 platform_device和device_node绑定"></a>二、 platform_device和device_node绑定</h3><p>platform_device和device_node的绑定过程</p>
<pre><code class="bash">static int __init arm64_device_init(void)
&#123;
    if (of_have_populated_dt()) &#123;
        of_iommu_init();
        of_platform_populate(NULL, of_default_bus_match_table,
                     NULL, NULL);
    &#125; else if (acpi_disabled) &#123;
        pr_crit(&quot;Device tree not populated\n&quot;);
    &#125;
    return 0;
&#125;
arch_initcall_sync(arm64_device_init);
...
/**
 * of_platform_populate() - Populate platform_devices from device tree data
 * @root: parent of the first level to probe or NULL for the root of the tree
 * @matches: match table, NULL to use the default
 * @lookup: auxdata table for matching id and platform_data with device nodes
 * @parent: parent to hook devices from, NULL for toplevel
 *
 * Similar to of_platform_bus_probe(), this function walks the device tree
 * and creates devices from nodes.  It differs in that it follows the modern
 * convention of requiring all device nodes to have a &#39;compatible&#39; property,
 * and it is suitable for creating devices which are children of the root
 * node (of_platform_bus_probe will only create children of the root which
 * are selected by the @matches argument).
 *
 * New board support should be using this function instead of
 * of_platform_bus_probe().
 *
 * Returns 0 on success, &lt; 0 on failure.
 */
int of_platform_populate(struct device_node *root,
            const struct of_device_id *matches,
            const struct of_dev_auxdata *lookup,
            struct device *parent)
&#123;
    struct device_node *child;
    int rc = 0;

    /* 获取根节点 */
    root = root ? of_node_get(root) : of_find_node_by_path(&quot;/&quot;);
    if (!root)
        return -EINVAL;

    /* 为根节点下面的每一个节点创建platform_device结构体 */
    for_each_child_of_node(root, child) &#123;
        rc = of_platform_bus_create(child, matches, lookup, parent, true);
        if (rc) &#123;
            of_node_put(child);
            break;
        &#125;
    &#125;
    /* 更新device_node flag标志位 */
    of_node_set_flag(root, OF_POPULATED_BUS);

    of_node_put(root);
    return rc;
&#125;
...
/**
 * of_platform_bus_create() - Create a device for a node and its children.
 * @bus: device node of the bus to instantiate
 * @matches: match table for bus nodes
 * @lookup: auxdata table for matching id and platform_data with device nodes
 * @parent: parent for new device, or NULL for top level.
 * @strict: require compatible property
 *
 * Creates a platform_device for the provided device_node, and optionally
 * recursively create devices for all the child nodes.
 */
static int of_platform_bus_create(struct device_node *bus,
                  const struct of_device_id *matches,
                  const struct of_dev_auxdata *lookup,
                  struct device *parent, bool strict)
&#123;
    const struct of_dev_auxdata *auxdata;
    struct device_node *child;
    struct platform_device *dev;
    const char *bus_id = NULL;
    void *platform_data = NULL;
    int rc = 0;

    /* 只有包含&quot;compatible&quot;属性的node节点才会生成相应的platform_device结构体 */
    /* Make sure it has a compatible property */
    if (strict &amp;&amp; (!of_get_property(bus, &quot;compatible&quot;, NULL))) &#123;
        pr_debug(&quot;%s() - skipping %s, no compatible prop\n&quot;,
             __func__, bus-&gt;full_name);
        return 0;
    &#125;

    auxdata = of_dev_lookup(lookup, bus);
    if (auxdata) &#123;
        bus_id = auxdata-&gt;name;
        platform_data = auxdata-&gt;platform_data;
    &#125;

    if (of_device_is_compatible(bus, &quot;arm,primecell&quot;)) &#123;
        /*
         * Don&#39;t return an error here to keep compatibility with older
         * device tree files.
         */
        of_amba_device_create(bus, bus_id, platform_data, parent);
        return 0;
    &#125;

    /* 
     * 针对节点下面得到status = &quot;ok&quot; 或者status = &quot;okay&quot;或者不存在status属性的
     * 节点分配内存并填充platform_device结构体
     */
    dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);
    if (!dev || !of_match_node(matches, bus))
        return 0;

    /* 递归调用节点解析函数，为子节点继续生成platform_device结构体，前提是父节点
     * 的“compatible” = “simple-bus”，也就是匹配of_default_bus_match_table结构体中的数据
     */
    for_each_child_of_node(bus, child) &#123;
        pr_debug(&quot;   create child: %s\n&quot;, child-&gt;full_name);
        rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);
        if (rc) &#123;
            of_node_put(child);
            break;
        &#125;
    &#125;
    of_node_set_flag(bus, OF_POPULATED_BUS);
    return rc;
&#125;
当of_platform_populate()函数执行完毕，kernel就为DTB中所有包含compatible属性名的第一级node创建platform_device结构体，并向平台设备总线注册设备信息。如果第一级node的compatible属性值等于“simple-bus”、“simple-mfd”或者&quot;arm,amba-bus&quot;的话，kernel会继续为当前node的第二级包含compatible属性的node创建platform_device结构体，并注册设备。Linux系统下的设备大多都是挂载在平台总线下的，因此在平台总线被注册后，会根据of_root节点的树结构，去寻找该总线的子节点，所有的子节点将被作为设备注册到该总线上。
</code></pre>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>dts</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-i2c</title>
    <url>/2019/09/13/linux-kernel-i2c/</url>
    <content><![CDATA[<h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * i2c_adapter is the structure used to identify a physical i2c bus along</span><br><span class="line"> * with the access algorithms necessary to access it.</span><br><span class="line"> */</span><br><span class="line">struct i2c_adapter &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	/* 该I2C bus支持哪些类型的slave device，只有匹配的slave device才能和bus绑定。具体的类型包括（可参考include/linux/i2c.h中的定义和注释）：</span><br><span class="line">    I2C_CLASS_HWMON，硬件监控类，如lm_sensors等；</span><br><span class="line">    I2C_CLASS_DDC，DDC是数字显示通道（Digital Display Channel）的意思， 通常用于显示设备信息的获取；</span><br><span class="line">    I2C_CLASS_SPD，存储类的模组；</span><br><span class="line">    I2C_CLASS_DEPRECATED，不再使用的class */</span><br><span class="line">	unsigned int class;		  /* classes to allow probing <span class="keyword">for</span> */</span><br><span class="line">	const struct i2c_algorithm *algo; /* the algorithm to access the bus */</span><br><span class="line">	void *algo_data;</span><br><span class="line"></span><br><span class="line">	/* data fields that are valid <span class="keyword">for</span> all devices	*/</span><br><span class="line">	const struct i2c_lock_operations *lock_ops;</span><br><span class="line">	struct rt_mutex bus_lock;</span><br><span class="line">	struct rt_mutex mux_lock;</span><br><span class="line"></span><br><span class="line">	int timeout;			/* <span class="keyword">in</span> jiffies */</span><br><span class="line">	/* 基于I2C传输的特性，不一定每一次总线访问（发送或者接收数据）都会成功，在传输失败的时候，可以选择重试。重试的逻辑由I2C core自行完成，但I2C controller driver需要设定重试的次数，这就是retries字段的意义。另外，有些consumer对结果的返回是有时间要求的，因此不能无节制的重试，timeout字段（单位为jiffies）在retries基础上，增加了时间限制，超过这个时间，就不能重试了。</span><br><span class="line">	*/</span><br><span class="line">	int retries;</span><br><span class="line">	struct device dev;		/* the adapter device */</span><br><span class="line"></span><br><span class="line">	/* 该I2C bus的ID，会体现在sysfs中（/sys/bus/i2c/devices/i2c-n中的‘n’），可由I2C controller driver在注册adapter时指定，或者通过DTS解析（后面会介绍），或者自动分配 */</span><br><span class="line">	int nr;</span><br><span class="line">	char name[48];</span><br><span class="line">	struct completion dev_released;</span><br><span class="line"></span><br><span class="line">	struct mutex userspace_clients_lock;</span><br><span class="line">	struct list_head userspace_clients;</span><br><span class="line"></span><br><span class="line">	struct i2c_bus_recovery_info *bus_recovery_info;</span><br><span class="line">	const struct i2c_adapter_quirks *quirks;</span><br><span class="line"></span><br><span class="line">	struct irq_domain *host_notify_domain;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">```bash</span><br><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">	/* If an adapter algorithm can<span class="string">&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="string">	   to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="string">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="string">	   using common I2C messages */</span></span><br><span class="line"><span class="string">	/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="string">	   processed, or a negative value on error */</span></span><br><span class="line"><span class="string">	/* I2C协议有关的数据传输接口，输入参数是struct i2c_msg类型（可参考2.3小节的介绍）的数组（大小由num指定）。返回值是成功传输的msg的个数，如有错误返回负值 */</span></span><br><span class="line"><span class="string">	int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span></span><br><span class="line"><span class="string">			   int num);</span></span><br><span class="line"><span class="string">	/* SMBUS有关的数据传输接口，如果为NULL，I2C core会尝试使用master_xfer模拟 */</span></span><br><span class="line"><span class="string">	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span></span><br><span class="line"><span class="string">			   unsigned short flags, char read_write,</span></span><br><span class="line"><span class="string">			   u8 command, int size, union i2c_smbus_data *data);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* To determine what the adapter supports */</span></span><br><span class="line"><span class="string">	/* 通过一个bitmap，告诉调用者该I2C adapter支持的功能 */</span></span><br><span class="line"><span class="string">	u32 (*functionality) (struct i2c_adapter *);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#if IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="string">	int (*reg_slave)(struct i2c_client *client);</span></span><br><span class="line"><span class="string">	int (*unreg_slave)(struct i2c_client *client);</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">	__u16 addr;	/* slave address			*/ //I2C slave device的地址</span><br><span class="line">	__u16 flags;  //数据传输可携带的flag，包括（具体可参考include/uapi/linux/							i2c.h中的定义和注释）：</span><br><span class="line">    				 I2C_M_TEN，支持10-bit的slave地址；</span><br><span class="line">     				I2C_M_RD，此次传输是读操作；</span><br><span class="line">    				 其它flag，下面再详细描述。</span><br><span class="line"><span class="comment">#define I2C_M_RD		0x0001	/* read data, from slave to master */</span></span><br><span class="line">					/* I2C_M_RD is guaranteed to be 0x0001! */</span><br><span class="line"><span class="comment">#define I2C_M_TEN		0x0010	/* this is a ten bit chip address */</span></span><br><span class="line"><span class="comment">#define I2C_M_DMA_SAFE		0x0200	/* the buffer of this message is DMA safe */</span></span><br><span class="line">					/* makes only sense <span class="keyword">in</span> kernelspace */</span><br><span class="line">					/* userspace buffers are copied anyway */</span><br><span class="line"><span class="comment">#define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */</span></span><br><span class="line"><span class="comment">#define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="line"><span class="comment">#define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="line"><span class="comment">#define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="line"><span class="comment">#define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_NOSTART */</span></span><br><span class="line"><span class="comment">#define I2C_M_STOP		0x8000	/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="line">	__u16 len;		/* msg length				*/ //数据传输的长度，单位为byte</span><br><span class="line">	__u8 *buf;		/* pointer to msg data			*/ //数据buf</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、API"><a href="#二、API" class="headerlink" title="二、API"></a>二、API</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">extern int i2c_add_adapter(struct i2c_adapter *);</span><br><span class="line">extern void i2c_del_adapter(struct i2c_adapter *);</span><br><span class="line">extern int i2c_add_numbered_adapter(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">extern int i2c_register_driver(struct module *, struct i2c_driver *);</span><br><span class="line">extern void i2c_del_driver(struct i2c_driver *);</span><br><span class="line"></span><br><span class="line">/* use a define to avoid include chaining to get THIS_MODULE */</span><br><span class="line"><span class="comment">#define i2c_add_driver(driver) \</span></span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver)</span><br><span class="line"></span><br><span class="line">extern struct i2c_client *i2c_use_client(struct i2c_client *client);</span><br><span class="line">extern void i2c_release_client(struct i2c_client *client);</span><br><span class="line"></span><br><span class="line">/* call the i2c_client-&gt;<span class="built_in">command</span>() of all attached clients with</span><br><span class="line"> * the given arguments */</span><br><span class="line">extern void i2c_clients_command(struct i2c_adapter *adap,</span><br><span class="line">				unsigned int cmd, void *arg);</span><br><span class="line"></span><br><span class="line">extern struct i2c_adapter *i2c_get_adapter(int nr);</span><br><span class="line">extern void i2c_put_adapter(struct i2c_adapter *adap);</span><br><span class="line">extern unsigned int i2c_adapter_depth(struct i2c_adapter *adapter);</span><br><span class="line">/* Return the functionality mask */</span><br><span class="line">static inline u32 i2c_get_functionality(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> adap-&gt;algo-&gt;functionality(adap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Return 1 <span class="keyword">if</span> adapter supports everything we need, 0 <span class="keyword">if</span> not. */</span><br><span class="line">static inline int i2c_check_functionality(struct i2c_adapter *adap, u32 func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> (func &amp; i2c_get_functionality(adap)) == func;</span><br><span class="line">&#125;</span><br><span class="line">/* Return the adapter number <span class="keyword">for</span> a specific adapter */</span><br><span class="line">static inline int i2c_adapter_id(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> adap-&gt;nr;</span><br><span class="line">&#125;</span><br><span class="line">extern struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）i2c_add_adapter和i2c_add_numbered_adapter是I2C adapter的注册接口，它们的区别是：i2c_add_adapter会自动分配adapter ID（adapter-&gt;nr，见2.1），i2c_add_numbered_adapter则可以指定ID（adapter-&gt;nr需要时有效值，否则会调用i2c_add_adapter自动分配）。</span><br><span class="line"></span><br><span class="line">2）i2c_del_adapter将I2C adapter从内核中删除。</span><br><span class="line"></span><br><span class="line">3）i2c_get_functionality获取指定adapter所支持的功能，i2c_check_functionality可用于检查指定adapter是否具备指定功能。</span><br><span class="line"></span><br><span class="line">4）i2c_adapter_id可以获取指定adapter的ID。</span><br><span class="line"></span><br><span class="line">5）i2c_get_adapter通过ID获得指定adapter的指针，由于该接口会尝试调用try_module_get增加模块的引用计数，因此使用完毕后，需要调用i2c_put_adapter将引用计数减去。</span><br><span class="line"></span><br><span class="line">6）of_find_i2c_adapter_by_node，通过device的device_node查找相应的adapter结构，使用完后需要调用put_device将adapter-&gt;dev所在的模块引用计数减去。</span><br></pre></td></tr></table></figure>
<p>下面详细看下几个具体函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev = &amp;adapter-&gt;dev;</span><br><span class="line">	int id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">		/* 该方法会通过DTS中的<span class="built_in">alias</span>解析指定I2C adapter的ID */</span><br><span class="line">		id = of_alias_get_id(dev-&gt;of_node, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (id &gt;= 0) &#123;</span><br><span class="line">			adapter-&gt;nr = id;</span><br><span class="line">			<span class="built_in">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	/* 分配adapter ID */</span><br><span class="line">	id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">		       __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (WARN(id &lt; 0, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="built_in">return</span> id;</span><br><span class="line"></span><br><span class="line">	adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> i2c_register_adapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_add_adapter);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	int res = -EINVAL;</span><br><span class="line"></span><br><span class="line">	/* Can<span class="string">&#x27;t register until after driver model init */</span></span><br><span class="line"><span class="string">	if (WARN_ON(!is_registered)) &#123;</span></span><br><span class="line"><span class="string">		res = -EAGAIN;</span></span><br><span class="line"><span class="string">		goto out_list;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Sanity checks */</span></span><br><span class="line"><span class="string">	if (WARN(!adap-&gt;name[0], &quot;i2c adapter has no name&quot;))</span></span><br><span class="line"><span class="string">		goto out_list;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!adap-&gt;algo) &#123;</span></span><br><span class="line"><span class="string">		pr_err(&quot;adapter &#x27;</span>%s<span class="string">&#x27;: no algo supplied!\n&quot;, adap-&gt;name);</span></span><br><span class="line"><span class="string">		goto out_list;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!adap-&gt;lock_ops)</span></span><br><span class="line"><span class="string">		adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	rt_mutex_init(&amp;adap-&gt;bus_lock);</span></span><br><span class="line"><span class="string">	rt_mutex_init(&amp;adap-&gt;mux_lock);</span></span><br><span class="line"><span class="string">	mutex_init(&amp;adap-&gt;userspace_clients_lock);</span></span><br><span class="line"><span class="string">	INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Set default timeout to 1 second if not already set */</span></span><br><span class="line"><span class="string">	if (adap-&gt;timeout == 0)</span></span><br><span class="line"><span class="string">		adap-&gt;timeout = HZ;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* register soft irqs for Host Notify */</span></span><br><span class="line"><span class="string">	res = i2c_setup_host_notify_irq_domain(adap);</span></span><br><span class="line"><span class="string">	if (res) &#123;</span></span><br><span class="line"><span class="string">		pr_err(&quot;adapter &#x27;</span>%s<span class="string">&#x27;: can&#x27;</span>t create Host Notify IRQs (%d)\n<span class="string">&quot;,</span></span><br><span class="line"><span class="string">		       adap-&gt;name, res);</span></span><br><span class="line"><span class="string">		goto out_list;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* 设置i2c名称 */</span></span><br><span class="line"><span class="string">	dev_set_name(&amp;adap-&gt;dev, &quot;</span>i2c-%d<span class="string">&quot;, adap-&gt;nr);</span></span><br><span class="line"><span class="string">	adap-&gt;dev.bus = &amp;i2c_bus_type;</span></span><br><span class="line"><span class="string">	adap-&gt;dev.type = &amp;i2c_adapter_type;</span></span><br><span class="line"><span class="string">	/* 注册i2c设备 */</span></span><br><span class="line"><span class="string">	res = device_register(&amp;adap-&gt;dev);</span></span><br><span class="line"><span class="string">	if (res) &#123;</span></span><br><span class="line"><span class="string">		pr_err(&quot;</span>adapter <span class="string">&#x27;%s&#x27;</span>: can<span class="string">&#x27;t register device (%d)\n&quot;, adap-&gt;name, res);</span></span><br><span class="line"><span class="string">		goto out_list;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	res = of_i2c_setup_smbus_alert(adap);</span></span><br><span class="line"><span class="string">	if (res)</span></span><br><span class="line"><span class="string">		goto out_reg;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span></span><br><span class="line"><span class="string">	pm_suspend_ignore_children(&amp;adap-&gt;dev, true);</span></span><br><span class="line"><span class="string">	pm_runtime_enable(&amp;adap-&gt;dev);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifdef CONFIG_I2C_COMPAT</span></span><br><span class="line"><span class="string">	res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span></span><br><span class="line"><span class="string">				       adap-&gt;dev.parent);</span></span><br><span class="line"><span class="string">	if (res)</span></span><br><span class="line"><span class="string">		dev_warn(&amp;adap-&gt;dev,</span></span><br><span class="line"><span class="string">			 &quot;Failed to create compatibility class link\n&quot;);</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	i2c_init_recovery(adap);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* create pre-declared device nodes */</span></span><br><span class="line"><span class="string">	of_i2c_register_devices(adap);</span></span><br><span class="line"><span class="string">	i2c_acpi_register_devices(adap);</span></span><br><span class="line"><span class="string">	i2c_acpi_install_space_handler(adap);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span></span><br><span class="line"><span class="string">		i2c_scan_static_board_info(adap);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Notify drivers */</span></span><br><span class="line"><span class="string">	mutex_lock(&amp;core_lock);</span></span><br><span class="line"><span class="string">	bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;core_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out_reg:</span></span><br><span class="line"><span class="string">	init_completion(&amp;adap-&gt;dev_released);</span></span><br><span class="line"><span class="string">	device_unregister(&amp;adap-&gt;dev);</span></span><br><span class="line"><span class="string">	wait_for_completion(&amp;adap-&gt;dev_released);</span></span><br><span class="line"><span class="string">out_list:</span></span><br><span class="line"><span class="string">	mutex_lock(&amp;core_lock);</span></span><br><span class="line"><span class="string">	idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;core_lock);</span></span><br><span class="line"><span class="string">	return res;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="三、编写I2C-controller驱动的步骤"><a href="#三、编写I2C-controller驱动的步骤" class="headerlink" title="三、编写I2C controller驱动的步骤"></a>三、编写I2C controller驱动的步骤</h3><p>了解了I2C adapter有关的数据结构和API之后，编写I2C控制器驱动就简单多了，主要步骤如下：</p>
<ol>
<li><p>定义一个struct i2c_algorithm变量，并根据I2C controller的特性，实现其中的回调函数。</p>
</li>
<li><p>在DTS文件（一般都放到DTSI）中，定义I2C controller相关的DTS node，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2c0: i2c@44e0b000 &#123;</span><br><span class="line">  4:         compatible = <span class="string">&quot;ti,omap4-i2c&quot;</span>;</span><br><span class="line">  5:         <span class="comment">#address-cells = &lt;1&gt;;</span></span><br><span class="line">  6:         <span class="comment">#size-cells = &lt;0&gt;;</span></span><br><span class="line">  7:         ti,hwmods = <span class="string">&quot;i2c1&quot;</span>;</span><br><span class="line">  8:         reg = &lt;0x44e0b000 0x1000&gt;;</span><br><span class="line">  9:         interrupts = &lt;70&gt;;</span><br><span class="line"> 10:         status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"> 11: &#125;;</span><br><span class="line"> 12: </span><br><span class="line"> 13: i2c1: i2c@4802a000 &#123;</span><br><span class="line"> 14:         compatible = <span class="string">&quot;ti,omap4-i2c&quot;</span>;</span><br><span class="line"> 15:         <span class="comment">#address-cells = &lt;1&gt;;</span></span><br><span class="line"> 16:         <span class="comment">#size-cells = &lt;0&gt;;</span></span><br><span class="line"> 17:         ti,hwmods = <span class="string">&quot;i2c2&quot;</span>;</span><br><span class="line"> 18:         reg = &lt;0x4802a000 0x1000&gt;;</span><br><span class="line"> 19:         interrupts = &lt;71&gt;;</span><br><span class="line"> 20:         status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"> 21: &#125;;</span><br><span class="line"> 22: </span><br><span class="line"> 23: ...</span><br></pre></td></tr></table></figure></li>
<li><p>在drives/i2c/busses目录下，以i2c-xxx.c的命名方式，编写I2C controller的platform driver,并提供match id、probe、remove等接口。</p>
</li>
<li><p>在platform driver的probe接口中，分配一个adapter结构，并进行必要的初始化操作后，调用i2c_add_adapter或者i2c_add_numbered_adapter接口，将其注册到kernel中即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-input</title>
    <url>/2020/03/15/linux-kernel-input/</url>
    <content><![CDATA[<p>一、概述<br>input 子系统分为 input 驱动<br>层、 input 核心层、 input 事件处理层，最终给用户空间提供可访问的设备节点<br><img src="/picture/input.png" alt="input"></p>
<p>二、输入核心<br>input输入子系统中的所有源码都放在 drivers\input 这个目录中，input.c文件就是核心层的源代码文件。在input目录中还可以看到一些文件夹，例如gameport、joystick<br>keyboard、misc、mouse….，这些文件夹里面存放的就是属于这类的input输入设备的设备驱动源代码，可以理解为input输入子系统的下层，input目录下的evdev.c、joydev.c、mousedev.c..分别对应上层的各个不同的handler的源代码<br>代码如下：</p>
<ul>
<li><p>input_init</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	err = class_register(&amp;input_class);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = input_proc_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		goto fail1;</span><br><span class="line"></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),</span><br><span class="line">				     INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line">		goto fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line"> fail2:	input_proc_exit();</span><br><span class="line"> fail1:	class_unregister(&amp;input_class);</span><br><span class="line">	<span class="built_in">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心层提供给设备驱动层的接口函数<br>input设备驱动框架留给设备驱动层的接口函数主要有3个：<br>input_allocate_device。分配一块input_dev结构体类型大小的内存<br>input_set_capability。设置输入设备可以上报哪些输入事件<br>input_register_device。向input核心层注册设备</p>
</li>
<li><p>input_allocate_device</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void)</span><br><span class="line">&#123;</span><br><span class="line">	static atomic_t input_no = ATOMIC_INIT(-1);</span><br><span class="line">	struct input_dev *dev;</span><br><span class="line"></span><br><span class="line">	dev = kzalloc(sizeof(struct input_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (dev) &#123;</span><br><span class="line">		dev-&gt;dev.type = &amp;input_dev_type;</span><br><span class="line">		dev-&gt;dev.class = &amp;input_class;</span><br><span class="line">		device_initialize(&amp;dev-&gt;dev);</span><br><span class="line">		mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">		spin_lock_init(&amp;dev-&gt;event_lock);</span><br><span class="line">		init_timer(&amp;dev-&gt;timer);</span><br><span class="line">		INIT_LIST_HEAD(&amp;dev-&gt;h_list);</span><br><span class="line">		INIT_LIST_HEAD(&amp;dev-&gt;node);</span><br><span class="line"></span><br><span class="line">		dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;input%lu&quot;</span>,</span><br><span class="line">			     (unsigned long)atomic_inc_return(&amp;input_no));</span><br><span class="line"></span><br><span class="line">		__module_get(THIS_MODULE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>input_set_capability</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void input_set_capability(struct input_dev *dev, unsigned int <span class="built_in">type</span>, unsigned int code)</span><br><span class="line">&#123;</span><br><span class="line">	switch (<span class="built_in">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> EV_KEY:</span><br><span class="line">		__set_bit(code, dev-&gt;keybit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_REL:</span><br><span class="line">		__set_bit(code, dev-&gt;relbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_ABS:</span><br><span class="line">		input_alloc_absinfo(dev);</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">			<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">		__set_bit(code, dev-&gt;absbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_MSC:</span><br><span class="line">		__set_bit(code, dev-&gt;mscbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SW:</span><br><span class="line">		__set_bit(code, dev-&gt;swbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_LED:</span><br><span class="line">		__set_bit(code, dev-&gt;ledbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SND:</span><br><span class="line">		__set_bit(code, dev-&gt;sndbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_FF:</span><br><span class="line">		__set_bit(code, dev-&gt;ffbit);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_PWR:</span><br><span class="line">		/* <span class="keyword">do</span> nothing */</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		pr_err(<span class="string">&quot;input_set_capability: unknown type %u (code %u)\n&quot;</span>,</span><br><span class="line">		       <span class="built_in">type</span>, code);</span><br><span class="line">		dump_stack();</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__set_bit(<span class="built_in">type</span>, dev-&gt;evbit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input_set_capability函数一次只能设置一个具体事件，如果设备可以上报多个事件，则需要重复调用这个函数来进行设置，例如：<br>input_set_capability(dev, EV_KEY, KEY_Q);         // 至于函数内部是怎么设置的，将会在后面进行分析。<br>input_set_capability(dev, EV_KEY, KEY_W);<br>input_set_capability(dev, EV_KEY, KEY_E);</p>
</li>
<li><p>input_register_device</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_devres *devres = NULL;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">	unsigned int packet_size;</span><br><span class="line">	const char *path;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">		devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">				      sizeof(struct input_devres), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!devres)</span><br><span class="line">			<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		devres-&gt;input = dev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Every input device generates EV_SYN/SYN_REPORT events. */</span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	/* Make sure that bitmasks not mentioned <span class="keyword">in</span> dev-&gt;evbit are clean. */</span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">		dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">	dev-&gt;max_vals = dev-&gt;hint_events_per_packet + 2;</span><br><span class="line">	dev-&gt;vals = kcalloc(dev-&gt;max_vals, sizeof(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		goto err_devres_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If delay and period are pre-set by the driver, <span class="keyword">then</span> autorepeating</span><br><span class="line">	 * is handled by the driver itself and we don<span class="string">&#x27;t do it in input.c.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span></span><br><span class="line"><span class="string">		input_enable_softrepeat(dev, 250, 33);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!dev-&gt;getkeycode)</span></span><br><span class="line"><span class="string">		dev-&gt;getkeycode = input_default_getkeycode;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!dev-&gt;setkeycode)</span></span><br><span class="line"><span class="string">		dev-&gt;setkeycode = input_default_setkeycode;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	error = device_add(&amp;dev-&gt;dev);</span></span><br><span class="line"><span class="string">	if (error)</span></span><br><span class="line"><span class="string">		goto err_free_vals;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span></span><br><span class="line"><span class="string">	pr_info(&quot;%s as %s\n&quot;,</span></span><br><span class="line"><span class="string">		dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;,</span></span><br><span class="line"><span class="string">		path ? path : &quot;N/A&quot;);</span></span><br><span class="line"><span class="string">	kfree(path);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	error = mutex_lock_interruptible(&amp;input_mutex);</span></span><br><span class="line"><span class="string">	if (error)</span></span><br><span class="line"><span class="string">		goto err_device_del;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	list_for_each_entry(handler, &amp;input_handler_list, node)</span></span><br><span class="line"><span class="string">		input_attach_handler(dev, handler);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	input_wakeup_procfs_readers();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;input_mutex);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (dev-&gt;devres_managed) &#123;</span></span><br><span class="line"><span class="string">		dev_dbg(dev-&gt;dev.parent, &quot;%s: registering %s with devres.\n&quot;,</span></span><br><span class="line"><span class="string">			__func__, dev_name(&amp;dev-&gt;dev));</span></span><br><span class="line"><span class="string">		devres_add(dev-&gt;dev.parent, devres);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err_device_del:</span></span><br><span class="line"><span class="string">	device_del(&amp;dev-&gt;dev);</span></span><br><span class="line"><span class="string">err_free_vals:</span></span><br><span class="line"><span class="string">	kfree(dev-&gt;vals);</span></span><br><span class="line"><span class="string">	dev-&gt;vals = NULL;</span></span><br><span class="line"><span class="string">err_devres_free:</span></span><br><span class="line"><span class="string">	devres_free(devres);</span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>input_attach_handler</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">	const struct input_device_id *id;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	id = input_match_device(handler, dev);</span><br><span class="line">	<span class="keyword">if</span> (!id)</span><br><span class="line">		<span class="built_in">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">	<span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">		pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input_attach_handler就是input_register_device函数中用来对下层的设备驱动和上层的handler进行匹配的一个函数，只有匹配成功之后就会调用上层handler中的connect函数<br>进行连接绑定。input_attach_handler函数做的事情有两件：调用input_match_device函数进行设备与handler的匹配、匹配成功调用handler的连接函数进行连接<br>核心层提供给事件驱动层的接口函数:在input输入核心层向事件驱动层提供的接口主要有两个：<br>input_register_handler。事件驱动层向核心层注册handler<br>input_register_handle。事件驱动层向核心层注册handle。   注意上面的是handler，这里是handle，不一样.</p>
</li>
<li><p>input_register_handler</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int input_register_handler(struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_dev *dev;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过分析了上面的input_register_device和这里的input_register_handler函数可以知道：注册设备的时候，不一定是先注册了handler才能够注册设备。当注册设备时，会先将<br>设备挂接到设备管理链表(input_dev_list)上，然后再去遍历input_handler_list链表匹配hander。同样对于handler注册的时候，也会先将handler挂接到handler管理链表<br>(input_handler_list)上，然后再去遍历input_dev_list链表匹配设备。所以从这里可以看出来，这种机制好像之前说过的platform总线下设备和驱动的匹配过程。<br>而且一个input_dev可以与多个handler匹配成功，从而可以在sysfs中创建多个设备文件，也可以在/dev/目录下创建多个设备节点，并且他们的次设备号是不一样的，这个很好理解。<br>所以就是导致一个设备对应多个次设备号，那这样有没有错呢？当然是没有错的。例如在我们的Ubuntu中，/dev/input/event3 和 /dev/input/mouse1 都是对应鼠标这个设备</p>
</li>
<li><p>input_register_handle<br>这个函数的作用就是注册一个handle，也就是实现上图中的将各个handle连接起来构成一个环形的结构，再调用这个函数之前已经将handle中的dev和handler已经是填充好了的，</p>
</li>
</ul>
<p><img src="/picture/input_dev.png" alt="input"></p>
<p>具体的这个函数代码就不去分析了<br>从本质上讲，input_dev与handler是多对多的关系，从上图可以看出来，一个input_dev可以对应多个handler，一个handler也可以对应多个input_dev。因为在匹配的时候，<br>一个input_dev会与所有的handler都进行匹配的，并不是匹配成功一次就退出。<br>从图中可以看出来，一个handle就是用来记录系统中一对匹配成功的handler和device，我们可以从这个handle出发得到handler的信息，还可以得到device的信息。所以正因为有这样的<br>功能，所以可以由handler经过handle最终获取到device的信息，同理也可以从device从发经过handle最终获取到handler的信息。这种运用方法将会在后面的分析中看到</p>
<p>总结：<br>(1)创建设备类、注册字符设备<br>(2)向设备驱动层提供注册接口<br>(3)提供上层handler和下层device之间的匹配函数<br>(4)向上层提供注册handler的接口</p>
<p>三、输入事件驱动<br>以event为例</p>
<ul>
<li>evdev_init<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static struct input_handler evdev_handler = &#123;</span><br><span class="line">	.event		= evdev_event,</span><br><span class="line">	.events		= evdev_events,</span><br><span class="line">	.connect	= evdev_connect,</span><br><span class="line">	.disconnect	= evdev_disconnect,</span><br><span class="line">	.legacy_minors	= <span class="literal">true</span>,</span><br><span class="line">	.minor		= EVDEV_MINOR_BASE,</span><br><span class="line">	.name		= <span class="string">&quot;evdev&quot;</span>,</span><br><span class="line">	.id_table	= evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
/sys/devices/virtual/input/input0  这个设备是在注册input_dev时创建的，而input0/event0就是在handler和input_dev匹配成功之后创建的，也会在/dev/目录</li>
</ul>
<p>四、总结<br>(1)其实下层可以上报的事件都在我们的内核中是定义好的，我们都可以上报这些事，但是input子系统的上层输入事件驱动层的各个handler只能够处理某一些事件（event除外），<br>例如joy handler只能处理摇杆类型的事件，key handler只能处理键盘，内部实现的原理就是会在核心层做handler和device匹配的过程。如果我们的上报的事件与多个handler都<br>能够匹配成功，那么绑定之后核心层会向这多个handler都上报事件，再由handler上报给应用层。</p>
<p>(2)input设备注册的流程:<br>下层通过调用核心层的函数来向子系统注册input输入设备<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>input_register_device</p>
<pre><code>device_add:  /sys/devices/virtual/input/input0

链表挂接: input_dev-&gt;node    -------&gt;  input_dev_list

input_attach_handler                          //  进行input_dev和handler之间的匹配

    调用handler-&gt;connect进行连接

        构建evdev结构体，加入evdev_table数组

        input_register_handle

        device_add:  /sys/devices/virtual/input/input0/event0</code></pre>
<p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>(3)handler注册流程</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>input_register_handler</p>
<pre><code>input_table[handler-&gt;minor &gt;&gt; 5] = handler

链表挂接:  handler-&gt;node  -----&gt;   input_handler_list

input_attach_handler

    handler-&gt;connect                  // 调用handler的connect函数进行连接</code></pre>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>(4)事件如何传递到应用层</p>
<p>input子系统下层通过调用input_event函数项核心层上报数据</p>
<p>input_event</p>
<pre><code>input_handle_event

    input_pass_event

        handler-&gt;event()            //  最终会调用到handler 中的event函数

            evdev_pass_event

                client-&gt;buffer[client-&gt;head++] = *event;     //  会将input输入事件数据存放在evdev_client结构体中的缓冲去中</code></pre>
<p>当我们的应用层通过open打开event0这个设备节点时最终会调用到input_init函数中注册的字符设备input时注册的file_operations-&gt;open() 函数</p>
<p>input_open_file</p>
<pre><code>handler = input_table[iminor(inode) &gt;&gt; 5]

handler-&gt;fops-&gt;open()          

    evdev = evdev_table[i];

    evdev_open_device

        input_open_device

            input_dev-&gt;open()         //  最终就是执行input设备中的open函数

    file-&gt;private_data = evdev_client; </code></pre>
<p>所以当我们在应用层调用read函数时，最终会调用到handler-&gt;fops-&gt;read函数</p>
<p>evdev_read</p>
<pre><code>evdev_fetch_next_event

    *event = client-&gt;buffer[client-&gt;tail++]      //  将evdev_client-&gt;buffer中的数据取走

input_event_to_user

    copy_to_user                  //  拷贝到用户空间</code></pre>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-kobject</title>
    <url>/2019/09/04/linux-kernel-kobject/</url>
    <content><![CDATA[<h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><p><strong>kobject定义</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct kobject &#123;</span><br><span class="line">	const char		*name;  //该Kobject的名称，同时也是sysfs中的目录名称</span><br><span class="line">	struct list_head	entry;  //用于将Kobject加入到Kset中的list_head。</span><br><span class="line">	struct kobject		*parent;  //指向parent kobject，以此形成层次结构（在sysfs就表现为目录结构）。</span><br><span class="line">	struct kset		*kset;  //该kobject属于的Kset。可以为NULL。如果存在，且没有指定parent，则会把Kset作为parent（别忘了Kset是一个特殊的Kobject）。</span><br><span class="line">	struct kobj_type	*ktype;  //该Kobject属于的kobj_type。每个Kobject必须有一个ktype，否则Kernel会提示错误。</span><br><span class="line">	struct kernfs_node	*sd; /* sysfs directory entry */  //该Kobject在sysfs中的表示。</span><br><span class="line">	struct kref		kref;  //struct kref类型（在include/linux/kref.h中定义）的变量，为一个可用于原子操作的引用计数。</span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">	struct delayed_work	release;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	unsigned int state_initialized:1; //指示该Kobject是否已经初始化，以在Kobject的Init，Put，Add等操作时进行异常校验。</span><br><span class="line">	unsigned int state_in_sysfs:1; //指示该Kobject是否已在sysfs中呈现，以便在自动注销时从sysfs中移除。</span><br><span class="line">	unsigned int state_add_uevent_sent:1;</span><br><span class="line">	unsigned int state_remove_uevent_sent:1; //记录是否已经向用户空间发送ADD uevent，如果有，且没有发送remove uevent，则在自动注销时，补发REMOVE uevent，以便让用户空间正确处理。</span><br><span class="line">	unsigned int uevent_suppress:1; //如果该字段为1，则表示忽略所有上报的uevent事件。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>kset定义</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct kset &#123;</span><br><span class="line">	struct list_head list; //用于保存该kset下所有的kobject的链表。</span><br><span class="line">	spinlock_t list_lock; //用于保存该kset下所有的kobject的链表。</span><br><span class="line">	struct kobject kobj;  //该kset自己的kobject（kset是一个特殊的kobject，也会在sysfs中以目录的形式体现）。</span><br><span class="line">	const struct kset_uevent_ops *uevent_ops; //该kset的uevent操作函数集。当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。因此，如果一个kobject不属于任何kset时，是不允许发送uevent的。</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><strong>kobj_type定义</strong><br>One important point cannot be overstated: every kobject must have a release() method, and the kobject must persist (in a consistent state) until that method is called. If these constraints are not met, the code is flawed.  Note that the kernel will warn you if you forget to provide a release() method.  Do not try to get rid of this warning by providing an “empty” release function; you will be mocked mercilessly by the kobject maintainer if you attempt this.<br>Interestingly, the release() method is not stored in the kobject itself; instead, it is associated with the ktype. So let us introduce struct kobj_type::</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct kobj_type &#123;</span><br><span class="line">	void (*release)(struct kobject *kobj); //通过该回调函数，可以将包含该种类型kobject的数据结构的内存空间释放掉。</span><br><span class="line">	const struct sysfs_ops *sysfs_ops; //该种类型的Kobject的sysfs文件系统接口。</span><br><span class="line">	struct attribute **default_attrs; //该种类型的Kobject的atrribute列表（所谓attribute，就是sysfs文件系统中的一个文件）。将会在Kobject添加到内核时，一并注册到sysfs中。</span><br><span class="line">	const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);</span><br><span class="line">	const void *(*namespace)(struct kobject *kobj); //child_ns_type/namespace和文件系统（sysfs）的命名空间有关</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This structure is used to describe a particular type of kobject (or, more correctly, of containing object). Every kobject needs to have an associated kobj_type structure; a pointer to that structure must be specified when you call kobject_init() or kobject_init_and_add().</p>
<h3 id="二、kobject-kset-ktype关系"><a href="#二、kobject-kset-ktype关系" class="headerlink" title="二、kobject kset ktype关系"></a>二、kobject kset ktype关系</h3><p>Kobject是基本数据类型，每个Kobject都会在”/sys/“文件系统中以目录的形式出现。</p>
<p>Ktype代表Kobject（严格地讲，是包含了Kobject的数据结构）的属性操作集合（由于通用性，多个Kobject可能共用同一个属性操作集，因此把Ktype独立出来了）。<br>注3：在设备模型中，ktype的命名和解释，都非常抽象，理解起来非常困难，后面会详细说明。</p>
<p>Kset是一个特殊的Kobject（因此它也会在”/sys/“文件系统中以目录的形式出现），它用来集合相似的Kobject（这些Kobject可以是相同属性的，也可以不同属性的）。</p>
<h3 id="三、API接口"><a href="#三、API接口" class="headerlink" title="三、API接口"></a>三、API接口</h3><h4 id="kobject接口"><a href="#kobject接口" class="headerlink" title="kobject接口"></a>kobject接口</h4><p><strong>kobject_init</strong><br>The ktype is required for a kobject to be created properly, as every kobject must have an associated kobj_type.After calling kobject_init(), to register the kobject with sysfs, the function kobject_add() must be called:: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void kobject_init(struct kobject *kobj, struct kobj_type *ktype)</span><br><span class="line">&#123;</span><br><span class="line">	char *err_str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kobj) &#123; //参数检查kobj不为空</span><br><span class="line">		err_str = <span class="string">&quot;invalid kobject pointer!&quot;</span>;</span><br><span class="line">		goto error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ktype) &#123; //参数检查ktype不为空</span><br><span class="line">		err_str = <span class="string">&quot;must have a ktype to be initialized properly!\n&quot;</span>;</span><br><span class="line">		goto error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (kobj-&gt;state_initialized) &#123; //检查是否已经初始化过了</span><br><span class="line">		/* <span class="keyword">do</span> not error out as sometimes we can recover */</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;kobject (%p): tried to init an initialized &quot;</span></span><br><span class="line">		       <span class="string">&quot;object, something is seriously wrong.\n&quot;</span>, kobj);</span><br><span class="line">		dump_stack();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kobject_init_internal(kobj);&#123;</span><br><span class="line">		<span class="keyword">if</span> (!kobj)</span><br><span class="line">			<span class="built_in">return</span>;</span><br><span class="line">		kref_init(&amp;kobj-&gt;kref); //设置引用计数，原子操作</span><br><span class="line">		INIT_LIST_HEAD(&amp;kobj-&gt;entry);</span><br><span class="line">		kobj-&gt;state_in_sysfs = 0;</span><br><span class="line">		kobj-&gt;state_add_uevent_sent = 0;</span><br><span class="line">		kobj-&gt;state_remove_uevent_sent = 0;</span><br><span class="line">		kobj-&gt;state_initialized = 1;</span><br><span class="line">		kobj-&gt;ktype = ktype;</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	printk(KERN_ERR <span class="string">&quot;kobject (%p): %s\n&quot;</span>, kobj, err_str);</span><br><span class="line">	dump_stack();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kobject_init);</span><br></pre></td></tr></table></figure>
<p><strong>kobject_add</strong><br>This sets up the parent of the kobject and the name for the kobject properly.  If the kobject is to be associated with a specific kset, kobj-&gt;kset must be assigned before calling kobject_add().  If a kset is associated with a kobject, then the parent for the kobject can be set to NULL in the call to kobject_add() and then the kobject’s parent will be the kset itself.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int kobject_add(struct kobject *kobj, struct kobject *parent,</span><br><span class="line">		const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kobj) //参数检查kobj不为空</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kobj-&gt;state_initialized) &#123; //检查是否已经初始化过了</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;kobject &#x27;%s&#x27; (%p): tried to add an &quot;</span></span><br><span class="line">		       <span class="string">&quot;uninitialized object, something is seriously wrong.\n&quot;</span>,</span><br><span class="line">		       kobject_name(kobj), kobj);</span><br><span class="line">		dump_stack();</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	retval = kobject_add_varg(kobj, parent, fmt, args);&#123;</span><br><span class="line">		int retval;</span><br><span class="line"></span><br><span class="line">		retval = kobject_set_name_vargs(kobj, fmt, vargs); //设置kobject-&gt;name</span><br><span class="line">		<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">			printk(KERN_ERR <span class="string">&quot;kobject: can not set name properly!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span> retval;</span><br><span class="line">		&#125;</span><br><span class="line">		kobj-&gt;parent = parent;</span><br><span class="line">		<span class="built_in">return</span> kobject_add_internal(kobj);</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kobject_add);</span><br></pre></td></tr></table></figure>
<p><strong>kobject_add_internal</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int kobject_add_internal(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	int error = 0;</span><br><span class="line">	struct kobject *parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kobj) //一如既往的参数检查，后面不再提了</span><br><span class="line">		<span class="built_in">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kobj-&gt;name || !kobj-&gt;name[0]) &#123;</span><br><span class="line">		WARN(1, <span class="string">&quot;kobject: (%p): attempted to be registered with empty &quot;</span></span><br><span class="line">			 <span class="string">&quot;name!\n&quot;</span>, kobj);</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parent = kobject_get(kobj-&gt;parent); //增加kobj-&gt;parent的引用计数</span><br><span class="line"></span><br><span class="line">	/* join kset <span class="keyword">if</span> <span class="built_in">set</span>, use it as parent <span class="keyword">if</span> we <span class="keyword">do</span> not already have one */</span><br><span class="line">	<span class="keyword">if</span> (kobj-&gt;kset) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!parent) //如果该kobject没有parent，却存在kset，则将它的parent设为kset</span><br><span class="line">			parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj); //增加kset的引用计数</span><br><span class="line">		kobj_kset_join(kobj); //将kobj加入kset</span><br><span class="line">		kobj-&gt;parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: parent: &#x27;%s&#x27;, set: &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">		 kobject_name(kobj), kobj, __func__,</span><br><span class="line">		 parent ? kobject_name(parent) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>,</span><br><span class="line">		 kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	error = create_dir(kobj); //调用sysfs的相关接口，在sysfs下创建该kobject对应的目录</span><br><span class="line">	<span class="keyword">if</span> (error) &#123; //出错处理，需要将之前的操作都恢复到操作之前的状态</span><br><span class="line">		kobj_kset_leave(kobj);</span><br><span class="line">		kobject_put(parent);</span><br><span class="line">		kobj-&gt;parent = NULL;</span><br><span class="line"></span><br><span class="line">		/* be noisy on error issues */</span><br><span class="line">		<span class="keyword">if</span> (error == -EEXIST)</span><br><span class="line">			WARN(1, <span class="string">&quot;%s failed for %s with &quot;</span></span><br><span class="line">			     <span class="string">&quot;-EEXIST, don&#x27;t try to register things with &quot;</span></span><br><span class="line">			     <span class="string">&quot;the same name in the same directory.\n&quot;</span>,</span><br><span class="line">			     __func__, kobject_name(kobj));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			WARN(1, <span class="string">&quot;%s failed for %s (error: %d parent: %s)\n&quot;</span>,</span><br><span class="line">			     __func__, kobject_name(kobj), error,</span><br><span class="line">			     parent ? kobject_name(parent) : <span class="string">&quot;&#x27;none&#x27;&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		kobj-&gt;state_in_sysfs = 1;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kobject_create</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const struct sysfs_ops kobj_sysfs_ops = &#123;</span><br><span class="line">	.show	= kobj_attr_show,</span><br><span class="line">	.store	= kobj_attr_store,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(kobj_sysfs_ops);</span><br><span class="line">...</span><br><span class="line">static struct kobj_type dynamic_kobj_ktype = &#123;</span><br><span class="line">	.release	= dynamic_kobj_release, //调用kfree释放内存</span><br><span class="line">	.sysfs_ops	= &amp;kobj_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">struct kobject *kobject_create(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">	kobj = kzalloc(sizeof(*kobj), GFP_KERNEL); //分配内存</span><br><span class="line">	<span class="keyword">if</span> (!kobj)</span><br><span class="line">		<span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	kobject_init(kobj, &amp;dynamic_kobj_ktype);//用dynamic_kobj_ktype为参数初始化</span><br><span class="line">	<span class="built_in">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kobject_create_and_add</strong><br>Sometimes all that a developer wants is a way to create a simple directory in the sysfs hierarchy, and not have to mess with the whole complication of ksets, show and store functions, and other details.  This is the one exception where a single kobject should be created.  To create such an entry, use the function::</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)</span><br><span class="line">&#123;</span><br><span class="line">	struct kobject *kobj;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	kobj = kobject_create(); //create</span><br><span class="line">	<span class="keyword">if</span> (!kobj)</span><br><span class="line">		<span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	retval = kobject_add(kobj, parent, <span class="string">&quot;%s&quot;</span>, name); //add</span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;%s: kobject_add error: %d\n&quot;</span>,</span><br><span class="line">		       __func__, retval);</span><br><span class="line">		kobject_put(kobj);</span><br><span class="line">		kobj = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> kobj;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kobject_create_and_add);</span><br></pre></td></tr></table></figure>
<p><strong>kobject_get</strong><br>A successful call to kobject_get() will increment the kobject’s reference counter and return the pointer to the kobject.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ject *kobject_get(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">			WARN(1, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">			       <span class="string">&quot;initialized, yet kobject_get() is being &quot;</span></span><br><span class="line">			       <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">		kref_get(&amp;kobj-&gt;kref);//增加引用计数</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> kobj;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kobject_get);</span><br></pre></td></tr></table></figure>
<p><strong>kobject_put</strong><br> When a reference is released, the call to kobject_put() will decrement the reference count and, possibly, free the object.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void kobject_put(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">			WARN(1, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">			       <span class="string">&quot;initialized, yet kobject_put() is being &quot;</span></span><br><span class="line">			       <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">		kref_put(&amp;kobj-&gt;kref, kobject_release);//减少引用计数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kobject_put);</span><br></pre></td></tr></table></figure>
<h4 id="四、kset"><a href="#四、kset" class="headerlink" title="四、kset"></a>四、kset</h4><p><strong>kset_init</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void kset_init(struct kset *k)</span><br><span class="line">&#123;</span><br><span class="line">	kobject_init_internal(&amp;k-&gt;kobj); //kobj初始化也调用这个函数</span><br><span class="line">	INIT_LIST_HEAD(&amp;k-&gt;list); //初始化列表</span><br><span class="line">	spin_lock_init(&amp;k-&gt;list_lock); //上锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kset_register</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int kset_register(struct kset *k)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!k)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	kset_init(k); //调用kset_init，上面那个函数</span><br><span class="line">	err = kobject_add_internal(&amp;k-&gt;kobj); //将kobj加入到kset</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="built_in">return</span> err;</span><br><span class="line">	kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD); //这个是uevent在下一章列出</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kset_register);</span><br></pre></td></tr></table></figure>
<h3 id="五、例程"><a href="#五、例程" class="headerlink" title="五、例程"></a>五、例程</h3><p>sample/kobject/kobject-example.c<br>sample/kobject/kset-example.c</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>kobject</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-leds</title>
    <url>/2019/09/10/linux-kernel-leds/</url>
    <content><![CDATA[<h3 id="一、System-Controller-Registers-R-W-driver"><a href="#一、System-Controller-Registers-R-W-driver" class="headerlink" title="一、System Controller Registers R/W driver"></a>一、System Controller Registers R/W driver</h3><p>System controller node represents a register region containing a set<br>of miscellaneous registers. The registers are not cohesive enough to<br>represent as any specific type of device. The typical use-case is for<br>some other node’s driver, or platform-specific code, to acquire a<br>reference to the syscon node (e.g. by phandle, node path, or search<br>using a specific compatible value), interrogate the node (or associated<br>OS driver) to determine the location of the registers, and access the<br>registers directly.</p>
<p>Required properties:</p>
<ul>
<li>compatible: Should contain “syscon”.</li>
<li>reg: the register region can be accessed from syscon</li>
</ul>
<p>Optional property:</p>
<ul>
<li>reg-io-width: the size (in bytes) of the IO accesses that should be<br>performed on the device.</li>
</ul>
<p>Examples:<br>gpr: iomuxc-gpr@020e0000 {<br>    compatible = “fsl,imx6q-iomuxc-gpr”, “syscon”;<br>    reg = &lt;0x020e0000 0x38&gt;;<br>};</p>
<h3 id="二、Device-Tree-Bindings-for-Register-Bit-LEDs"><a href="#二、Device-Tree-Bindings-for-Register-Bit-LEDs" class="headerlink" title="二、Device Tree Bindings for Register Bit LEDs"></a>二、Device Tree Bindings for Register Bit LEDs</h3><p>Register bit leds are used with syscon multifunctional devices<br>where single bits in a certain register can turn on/off a<br>single LED. The register bit LEDs appear as children to the<br>syscon device, with the proper compatible string. For the<br>syscon bindings see:<br>Documentation/devicetree/bindings/mfd/syscon.txt</p>
<p>Each LED is represented as a sub-node of the syscon device. Each<br>node’s name represents the name of the corresponding LED.</p>
<h4 id="三、LED-sub-node-properties"><a href="#三、LED-sub-node-properties" class="headerlink" title="三、LED sub-node properties:"></a>三、LED sub-node properties:</h4><p>Required properties:</p>
<ul>
<li>compatible : must be “register-bit-led”</li>
<li>offset : register offset to the register controlling this LED</li>
<li>mask : bit mask for the bit controlling this LED in the register<br>typically 0x01, 0x02, 0x04 …</li>
</ul>
<p>Optional properties:</p>
<ul>
<li>label : (optional)<br>see Documentation/devicetree/bindings/leds/common.txt</li>
<li>linux,default-trigger : (optional)<br>see Documentation/devicetree/bindings/leds/common.txt</li>
<li>default-state: (optional) The initial state of the LED<br>see Documentation/devicetree/bindings/leds/common.txt</li>
</ul>
<h4 id="四、Example"><a href="#四、Example" class="headerlink" title="四、Example:"></a>四、Example:</h4><p>syscon: syscon@10000000 {<br>    compatible = “arm,realview-pb1176-syscon”, “syscon”;<br>    reg = &lt;0x10000000 0x1000&gt;;</p>
<pre><code>led@08.0 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x01&gt;;
    label = &quot;versatile:0&quot;;
    linux,default-trigger = &quot;heartbeat&quot;;
    default-state = &quot;on&quot;;
&#125;;
led@08.1 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x02&gt;;
    label = &quot;versatile:1&quot;;
    linux,default-trigger = &quot;mmc0&quot;;
    default-state = &quot;off&quot;;
&#125;;
led@08.2 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x04&gt;;
    label = &quot;versatile:2&quot;;
    linux,default-trigger = &quot;cpu0&quot;;
    default-state = &quot;off&quot;;
&#125;;
led@08.3 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x08&gt;;
    label = &quot;versatile:3&quot;;
    default-state = &quot;off&quot;;
&#125;;
led@08.4 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x10&gt;;
    label = &quot;versatile:4&quot;;
    default-state = &quot;off&quot;;
&#125;;
led@08.5 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x20&gt;;
    label = &quot;versatile:5&quot;;
    default-state = &quot;off&quot;;
&#125;;
led@08.6 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x40&gt;;
    label = &quot;versatile:6&quot;;
    default-state = &quot;off&quot;;
&#125;;
led@08.7 &#123;
    compatible = &quot;register-bit-led&quot;;
    offset = &lt;0x08&gt;;
    mask = &lt;0x80&gt;;
    label = &quot;versatile:7&quot;;
    default-state = &quot;off&quot;;
&#125;;</code></pre>
<p>};</p>
<h3 id="无、LED-handling-under-Linux"><a href="#无、LED-handling-under-Linux" class="headerlink" title="无、LED handling under Linux"></a>无、LED handling under Linux</h3><p>In its simplest form, the LED class just allows control of LEDs from<br>userspace. LEDs appear in /sys/class/leds/. The maximum brightness of the<br>LED is defined in max_brightness file. The brightness file will set the brightness<br>of the LED (taking a value 0-max_brightness). Most LEDs don’t have hardware<br>brightness support so will just be turned on for non-zero brightness settings.</p>
<p>The class also introduces the optional concept of an LED trigger. A trigger<br>is a kernel based source of led events. Triggers can either be simple or<br>complex. A simple trigger isn’t configurable and is designed to slot into<br>existing subsystems with minimal additional code. Examples are the disk-activity,<br>nand-disk and sharpsl-charge triggers. With led triggers disabled, the code<br>optimises away.</p>
<p>Complex triggers whilst available to all LEDs have LED specific<br>parameters and work on a per LED basis. The timer trigger is an example.<br>The timer trigger will periodically change the LED brightness between<br>LED_OFF and the current brightness setting. The “on” and “off” time can<br>be specified via /sys/class/leds/<device>/delay_{on,off} in milliseconds.<br>You can change the brightness value of a LED independently of the timer<br>trigger. However, if you set the brightness value to LED_OFF it will<br>also disable the timer trigger.</p>
<p>You can change triggers in a similar manner to the way an IO scheduler<br>is chosen (via /sys/class/leds/<device>/trigger). Trigger specific<br>parameters can appear in /sys/class/leds/<device> once a given trigger is<br>selected.</p>
<h3 id="六、Brightness-setting-API"><a href="#六、Brightness-setting-API" class="headerlink" title="六、Brightness setting API"></a>六、Brightness setting API</h3><p>LED subsystem core exposes following API for setting brightness:</p>
<pre><code>- led_set_brightness : it is guaranteed not to sleep, passing LED_OFF stops
    blinking,
- led_set_brightness_sync : for use cases when immediate effect is desired -
    it can block the caller for the time required for accessing
    device registers and can sleep, passing LED_OFF stops hardware
    blinking, returns -EBUSY if software blink fallback is enabled.</code></pre>
<h3 id="七、Hardware-accelerated-blink-of-LEDs"><a href="#七、Hardware-accelerated-blink-of-LEDs" class="headerlink" title="七、Hardware accelerated blink of LEDs"></a>七、Hardware accelerated blink of LEDs</h3><p>Some LEDs can be programmed to blink without any CPU interaction. To<br>support this feature, a LED driver can optionally implement the<br>blink_set() function (see &lt;linux/leds.h&gt;). To set an LED to blinking,<br>however, it is better to use the API function led_blink_set(), as it<br>will check and implement software fallback if necessary.</p>
<p>To turn off blinking, use the API function led_brightness_set()<br>with brightness value LED_OFF, which should stop any software<br>timers that may have been required for blinking.</p>
<p>The blink_set() function should choose a user friendly blinking value<br>if it is called with *delay_on==0 &amp;&amp; *delay_off==0 parameters. In this<br>case the driver should give back the chosen value through delay_on and<br>delay_off parameters to the leds subsystem.</p>
<p>Setting the brightness to zero with brightness_set() callback function<br>should completely turn off the LED and cancel the previously programmed<br>hardware blinking function, if any.</p>
<h3 id="八、关于builtin-platform-driver"><a href="#八、关于builtin-platform-driver" class="headerlink" title="八、关于builtin_platform_driver"></a>八、关于builtin_platform_driver</h3><p>以syscon_led为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static struct platform_driver syscon_led_driver = &#123;</span><br><span class="line">	.probe		= syscon_led_probe,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;leds-syscon&quot;</span>,</span><br><span class="line">		.of_match_table = of_syscon_leds_match,</span><br><span class="line">		.suppress_bind_attrs = <span class="literal">true</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">builtin_platform_driver(syscon_led_driver);</span><br></pre></td></tr></table></figure>
<p>将其展开builtin_platform_driver</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define builtin_platform_driver(syscon_led_driver) \</span></span><br><span class="line">	builtin_driver(syscon_led_driver, platform_driver_register)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define platform_driver_register(drv) \</span></span><br><span class="line">	__platform_driver_register(drv, THIS_MODULE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define builtin_driver(syscon_led_driver, platform_driver_register, ...) \</span></span><br><span class="line">static int __init syscon_led_driver_init(void) \</span><br><span class="line">&#123; \</span><br><span class="line">	<span class="built_in">return</span> platform_driver_register(&amp;(syscon_led_driver) , <span class="comment">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">device_initcall(syscon_led_driver_init);</span><br></pre></td></tr></table></figure>
<p>下面接着看device_initcall(syscon_led_driver_init);这个宏</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define device_initcall(syscon_led_driver_init)		__define_initcall(syscon_led_driver_init, 6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define __define_initcall(syscon_led_driver_init, 6) \</span></span><br><span class="line">	static initcall_t __initcall_syscon_led_driver_init6 __used \</span><br><span class="line">	__attribute__((__section__(<span class="string">&quot;.initcall6.init&quot;</span>))) = syscon_led_driver_init;</span><br><span class="line"></span><br><span class="line">.initcall6.init在vmlinux.lds文件里的__initcall6_start段里，通过搜索又发现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern initcall_t __initcall_start[];</span><br><span class="line">extern initcall_t __initcall0_start[];</span><br><span class="line">extern initcall_t __initcall1_start[];</span><br><span class="line">extern initcall_t __initcall2_start[];</span><br><span class="line">extern initcall_t __initcall3_start[];</span><br><span class="line">extern initcall_t __initcall4_start[];</span><br><span class="line">extern initcall_t __initcall5_start[];</span><br><span class="line">extern initcall_t __initcall6_start[];</span><br><span class="line">extern initcall_t __initcall7_start[];</span><br><span class="line">extern initcall_t __initcall_end[];</span><br><span class="line"></span><br><span class="line">static initcall_t *initcall_levels[] __initdata = &#123;</span><br><span class="line">	__initcall0_start,</span><br><span class="line">	__initcall1_start,</span><br><span class="line">	__initcall2_start,</span><br><span class="line">	__initcall3_start,</span><br><span class="line">	__initcall4_start,</span><br><span class="line">	__initcall5_start,</span><br><span class="line">	__initcall6_start,</span><br><span class="line">	__initcall7_start,</span><br><span class="line">	__initcall_end,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __init do_initcall_level(int level)</span><br><span class="line">&#123;</span><br><span class="line">	initcall_t *fn;</span><br><span class="line"></span><br><span class="line">	strcpy(initcall_command_line, saved_command_line);</span><br><span class="line">	parse_args(initcall_level_names[level],</span><br><span class="line">		   initcall_command_line, __start___param,</span><br><span class="line">		   __stop___param - __start___param,</span><br><span class="line">		   level, level,</span><br><span class="line">		   NULL, &amp;repair_env_string);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++)</span><br><span class="line">		do_one_initcall(*fn);</span><br><span class="line">&#125;</span><br><span class="line">在main函数里按照level先后循序进行调用</span><br></pre></td></tr></table></figure>
<p>最终就是调用platform_driver_register(&amp;(syscon_led_driver)）这个函数注册platform_driver。</p>
<h3 id="九、DEVICE-ATTR-RW"><a href="#九、DEVICE-ATTR-RW" class="headerlink" title="九、DEVICE_ATTR_RW"></a>九、DEVICE_ATTR_RW</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static DEVICE_ATTR_RW(brightness);</span><br><span class="line"></span><br><span class="line"><span class="comment">#define DEVICE_ATTR_RW(brightness) \</span></span><br><span class="line">	struct device_attribute dev_attr_brightness = __ATTR_RW(brightness)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __ATTR_RW(brightness) __ATTR(brightness, 0644, brightness_show, brightness_store)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define __ATTR(brightness, 0644, brightness_show, brightness_store) &#123;				\</span></span><br><span class="line">	.attr = &#123;.name = __stringify(brightness),				\</span><br><span class="line">		 .mode = VERIFY_OCTAL_PERMISSIONS(0644) &#125;,		\</span><br><span class="line">	.show	= brightness_show,						\</span><br><span class="line">	.store	= brightness_store,						\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终得到 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device_attribute dev_attr_brightness = &#123;				\</span><br><span class="line">	.attr = &#123;.name = __stringify(brightness),				\</span><br><span class="line">		 .mode = VERIFY_OCTAL_PERMISSIONS(0644) &#125;,		\</span><br><span class="line">	.show	= brightness_show,						\</span><br><span class="line">	.store	= brightness_store,						\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理其他DEVICE_ATTR_RO，也是同样的展开流程。</p>
<h3 id="十、led-class-led-core-led-syscon"><a href="#十、led-class-led-core-led-syscon" class="headerlink" title="十、led_class,led_core,led_syscon"></a>十、led_class,led_core,led_syscon</h3><p>led的驱动主要涉及这三个文件，其中led_syscon是具体实现，注册了platform_driver，提供底层操作接口，led_core提供了一层封装接口给led_class使用，他通过led_classdev结构体调用brightness_set，brightness_set_blocking等接口实现底层操作，而led_class提供了与sysfs的接口实现通过文件对具体设备的操作，主要体现在DEVICE_ATTR_RW这个属性上，用户空间可以通过sysfs访问这个文件从而操作硬件</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>leds</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-pinmux.md</title>
    <url>/2019/12/28/linux-kernel-pinmux-md/</url>
    <content><![CDATA[<h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct pinctrl - per-device pin control state holder</span><br><span class="line"> * @node: global list node</span><br><span class="line"> * @dev: the device using this pin control handle</span><br><span class="line"> * @states: a list of states <span class="keyword">for</span> this device</span><br><span class="line"> * @state: the current state</span><br><span class="line"> * @dt_maps: the mapping table chunks dynamically parsed from device tree <span class="keyword">for</span></span><br><span class="line"> *	this device, <span class="keyword">if</span> any</span><br><span class="line"> * @users: reference count</span><br><span class="line"> */</span><br><span class="line">struct pinctrl &#123;</span><br><span class="line">	struct list_head node;    //系统中的所有device的pin control state holder被挂入到了一个全局链表中</span><br><span class="line">	struct device *dev;       //该pin control state holder对应的device</span><br><span class="line">	struct list_head states;  //该设备的所有的状态被挂入到这个链表中</span><br><span class="line">	struct pinctrl_state *state;//当前的pin control state</span><br><span class="line">	struct list_head dt_maps; //mapping table</span><br><span class="line">	struct kref users;        //reference count</span><br><span class="line">&#125;;</span><br><span class="line">。。。</span><br><span class="line">/**</span><br><span class="line"> * struct pinctrl_state - a pinctrl state <span class="keyword">for</span> a device</span><br><span class="line"> * @node: list node <span class="keyword">for</span> struct pinctrl<span class="string">&#x27;s @states field</span></span><br><span class="line"><span class="string"> * @name: the name of this state</span></span><br><span class="line"><span class="string"> * @settings: a list of settings for this state</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">struct pinctrl_state &#123;</span></span><br><span class="line"><span class="string">	struct list_head node;     //挂入链表头的节点</span></span><br><span class="line"><span class="string">	const char *name;          //该state的名字</span></span><br><span class="line"><span class="string">	struct list_head settings; //属于该状态的所有的settings</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">。。。</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * struct pinctrl_setting - an individual mux or config setting</span></span><br><span class="line"><span class="string"> * @node: list node for struct pinctrl_settings&#x27;</span>s @settings field</span><br><span class="line"> * @<span class="built_in">type</span>: the <span class="built_in">type</span> of setting</span><br><span class="line"> * @pctldev: pin control device handling to be programmed. Not used <span class="keyword">for</span></span><br><span class="line"> *   PIN_MAP_TYPE_DUMMY_STATE.</span><br><span class="line"> * @dev_name: the name of the device using this state</span><br><span class="line"> * @data: Data specific to the setting <span class="built_in">type</span></span><br><span class="line"> */</span><br><span class="line">struct pinctrl_setting &#123;</span><br><span class="line">	struct list_head node;</span><br><span class="line">	enum pinctrl_map_type <span class="built_in">type</span>;</span><br><span class="line">	struct pinctrl_dev *pctldev;</span><br><span class="line">	const char *dev_name;</span><br><span class="line">	union &#123;</span><br><span class="line">		struct pinctrl_setting_mux mux;</span><br><span class="line">		struct pinctrl_setting_configs configs;</span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">enum pinctrl_map_type &#123;</span><br><span class="line">	PIN_MAP_TYPE_INVALID,</span><br><span class="line">	PIN_MAP_TYPE_DUMMY_STATE,</span><br><span class="line">	PIN_MAP_TYPE_MUX_GROUP,    //功能复用的setting</span><br><span class="line">	PIN_MAP_TYPE_CONFIGS_PIN,  //设定单一一个pin的电气特性</span><br><span class="line">	PIN_MAP_TYPE_CONFIGS_GROUP,//设定单pin group的电气特性</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * struct pinctrl_map_mux - mapping table content <span class="keyword">for</span> MAP_TYPE_MUX_GROUP</span><br><span class="line"> * @group: the name of the group whose mux <span class="keyword">function</span> is to be configured. This</span><br><span class="line"> *	field may be left NULL, and the first applicable group <span class="keyword">for</span> the <span class="keyword">function</span></span><br><span class="line"> *	will be used.</span><br><span class="line"> * @<span class="keyword">function</span>: the mux <span class="keyword">function</span> to select <span class="keyword">for</span> the group</span><br><span class="line"> */</span><br><span class="line">struct pinctrl_map_mux &#123;</span><br><span class="line">	const char *group;    //setting所对应的group selector</span><br><span class="line">	const char *<span class="keyword">function</span>; //该setting所对应的<span class="keyword">function</span> selector</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * struct pinctrl_map_configs - mapping table content <span class="keyword">for</span> MAP_TYPE_CONFIGS_*</span><br><span class="line"> * @group_or_pin: the name of the pin or group whose configuration parameters</span><br><span class="line"> *	are to be configured.</span><br><span class="line"> * @configs: a pointer to an array of config parameters/values to program into</span><br><span class="line"> *	hardware. Each individual pin controller defines the format and meaning</span><br><span class="line"> *	of config parameters.</span><br><span class="line"> * @num_configs: the number of entries <span class="keyword">in</span> array @configs</span><br><span class="line"> */</span><br><span class="line">struct pinctrl_map_configs &#123;</span><br><span class="line">	const char *group_or_pin;    //该pin或者pin group的名字</span><br><span class="line">	unsigned long *configs;      //要设定的值的列表。这个值被用来写入HW</span><br><span class="line">	unsigned num_configs;        //列表中值的个数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h3><p>devm_pinctrl_get和pinctrl_get。这两个接口都是获取设备（设备模型中的struct device）的pin control state holder（struct pinctrl）。pin control state holder不是静态定义的，一般在第一次调用该函数的时候会动态创建。创建一个pin control state holder是一个大工程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct devm_pinctrl_get() - Resource managed pinctrl_get()</span><br><span class="line"> * @dev: the device to obtain the handle <span class="keyword">for</span></span><br><span class="line"> *</span><br><span class="line"> * If there is a need to explicitly destroy the returned struct pinctrl,</span><br><span class="line"> * devm_pinctrl_put() should be used, rather than plain pinctrl_put().</span><br><span class="line"> */</span><br><span class="line">struct pinctrl *devm_pinctrl_get(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct pinctrl **ptr, *p;</span><br><span class="line"></span><br><span class="line">	ptr = devres_alloc(devm_pinctrl_release, sizeof(*ptr), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	p = pinctrl_get(dev);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">		*ptr = p;</span><br><span class="line">		devres_add(dev, ptr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		devres_free(ptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * pinctrl_get() - retrieves the pinctrl handle <span class="keyword">for</span> a device</span><br><span class="line"> * @dev: the device to obtain the handle <span class="keyword">for</span></span><br><span class="line"> */</span><br><span class="line">struct pinctrl *pinctrl_get(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct pinctrl *p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!dev))</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * See <span class="keyword">if</span> somebody <span class="keyword">else</span> (such as the device core) has already</span><br><span class="line">	 * obtained a handle to the pinctrl <span class="keyword">for</span> this device. In that <span class="keyword">case</span>,</span><br><span class="line">	 * <span class="built_in">return</span> another pointer to it.</span><br><span class="line">	 */</span><br><span class="line">	p = find_pinctrl(dev);</span><br><span class="line">	<span class="keyword">if</span> (p != NULL) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;obtain a copy of previously claimed pinctrl\n&quot;</span>);</span><br><span class="line">		kref_get(&amp;p-&gt;users);</span><br><span class="line">		<span class="built_in">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> create_pinctrl(dev);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">static struct pinctrl *create_pinctrl(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct pinctrl *p;</span><br><span class="line">	const char *devname;</span><br><span class="line">	struct pinctrl_maps *maps_node;</span><br><span class="line">	int i;</span><br><span class="line">	struct pinctrl_map const *map;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * create the state cookie holder struct pinctrl <span class="keyword">for</span> each</span><br><span class="line">	 * mapping, this is what consumers will get when requesting</span><br><span class="line">	 * a pin control handle with pinctrl_get()</span><br><span class="line">	 */</span><br><span class="line">    // 分配pin control state holder占用的内存并初始化</span><br><span class="line">	p = kzalloc(sizeof(*p), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (p == NULL) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;failed to alloc struct pinctrl\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;states);</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;dt_maps);</span><br><span class="line"></span><br><span class="line">    /* mapping table这个database的建立也是动态的，当第一次调用pin control state holder的get函数的时候，就会通过调用pinctrl_dt_to_map来建立该  * device需要的mapping entry</span><br><span class="line">     */</span><br><span class="line">	ret = pinctrl_dt_to_map(p);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">		kfree(p);</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">	/* Iterate over the pin control maps to locate the right ones */</span><br><span class="line">	for_each_maps(maps_node, i, map) &#123;</span><br><span class="line">		/* Map must be <span class="keyword">for</span> this device */</span><br><span class="line">		<span class="keyword">if</span> (strcmp(map-&gt;dev_name, devname))</span><br><span class="line">			<span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">		ret = add_setting(p, map);  //分析一个mapping entry，把这个setting的代码加入到holder中</span><br><span class="line">		/*</span><br><span class="line">		 * At this point the adding of a setting may:</span><br><span class="line">		 *</span><br><span class="line">		 * - Defer, <span class="keyword">if</span> the pinctrl device is not yet available</span><br><span class="line">		 * - Fail, <span class="keyword">if</span> the pinctrl device is not yet available,</span><br><span class="line">		 *   AND the setting is a hog. We cannot defer that, since</span><br><span class="line">		 *   the hog will kick <span class="keyword">in</span> immediately after the device</span><br><span class="line">		 *   is registered.</span><br><span class="line">		 *</span><br><span class="line">		 * If the error returned was not -EPROBE_DEFER <span class="keyword">then</span> we</span><br><span class="line">		 * accumulate the errors to see <span class="keyword">if</span> we end up with</span><br><span class="line">		 * an -EPROBE_DEFER later, as that is the worst <span class="keyword">case</span>.</span><br><span class="line">		 */</span><br><span class="line">		<span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">			pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">			mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line">			<span class="built_in">return</span> ERR_PTR(ret);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">		/* If some other error than deferral occured, <span class="built_in">return</span> here */</span><br><span class="line">		pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kref_init(&amp;p-&gt;users);</span><br><span class="line"></span><br><span class="line">    /* 把这个新增加的pin control state holder加入到全局链表中 */</span><br><span class="line">	/* Add the pinctrl handle to the global list */</span><br><span class="line">	mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">	list_add_tail(&amp;p-&gt;node, &amp;pinctrl_list);</span><br><span class="line">	mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>devm_pinctrl_put和pinctrl_put。devm_pinctrl_get和pinctrl_get获取句柄的时候申请了很多资源，在devm_pinctrl_put和pinctrl_put可以释放。需要注意的是多次调用get函数不会重复分配资源，只会reference count加一，在put中referrenct count减一，当count＝＝0的时候才释放该device的pin control state holder持有的所有资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * devm_pinctrl_put() - Resource managed pinctrl_put()</span><br><span class="line"> * @p: the pinctrl handle to release</span><br><span class="line"> *</span><br><span class="line"> * Deallocate a struct pinctrl obtained via devm_pinctrl_get(). Normally</span><br><span class="line"> * this <span class="keyword">function</span> will not need to be called and the resource management</span><br><span class="line"> * code will ensure that the resource is freed.</span><br><span class="line"> */</span><br><span class="line">void devm_pinctrl_put(struct pinctrl *p)</span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON(devres_release(p-&gt;dev, devm_pinctrl_release,</span><br><span class="line">			       devm_pinctrl_match, p));</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">/**</span><br><span class="line"> * devres_release - Find a device resource and destroy it, calling release</span><br><span class="line"> * @dev: Device to find resource from</span><br><span class="line"> * @release: Look <span class="keyword">for</span> resources associated with this release <span class="keyword">function</span></span><br><span class="line"> * @match: Match <span class="keyword">function</span> (optional)</span><br><span class="line"> * @match_data: Data <span class="keyword">for</span> the match <span class="keyword">function</span></span><br><span class="line"> *</span><br><span class="line"> * Find the latest devres of @dev associated with @release and <span class="keyword">for</span></span><br><span class="line"> * <span class="built_in">which</span> @match returns 1.  If @match is NULL, it<span class="string">&#x27;s considered to</span></span><br><span class="line"><span class="string"> * match all.  If found, the resource is removed atomically, the</span></span><br><span class="line"><span class="string"> * release function called and the resource freed.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * RETURNS:</span></span><br><span class="line"><span class="string"> * 0 if devres is found and freed, -ENOENT if not found.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">int devres_release(struct device *dev, dr_release_t release,</span></span><br><span class="line"><span class="string">		   dr_match_t match, void *match_data)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	void *res;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	res = devres_remove(dev, release, match, match_data);</span></span><br><span class="line"><span class="string">	if (unlikely(!res))</span></span><br><span class="line"><span class="string">		return -ENOENT;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	(*release)(dev, res);</span></span><br><span class="line"><span class="string">	devres_free(res);</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>pinctrl_lookup_state。根据state name在pin control state holder找到对应的pin control state。具体的state是各个device自己定义的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * pinctrl_lookup_state() - retrieves a state handle from a pinctrl handle</span><br><span class="line"> * @p: the pinctrl handle to retrieve the state from</span><br><span class="line"> * @name: the state name to retrieve</span><br><span class="line"> */</span><br><span class="line">struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p,</span><br><span class="line">						 const char *name)</span><br><span class="line">&#123;</span><br><span class="line">	struct pinctrl_state *state;</span><br><span class="line"></span><br><span class="line">	state = find_state(p, name);</span><br><span class="line">	<span class="keyword">if</span> (!state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pinctrl_dummy_state) &#123;</span><br><span class="line">			/* create dummy state */</span><br><span class="line">			dev_dbg(p-&gt;dev, <span class="string">&quot;using pinctrl dummy state (%s)\n&quot;</span>,</span><br><span class="line">				name);</span><br><span class="line">			state = create_state(p, name);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			state = ERR_PTR(-ENODEV);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">#define PINCTRL_STATE_DEFAULT &quot;default&quot;</span></span><br><span class="line"><span class="comment">#define PINCTRL_STATE_IDLE &quot;idle&quot;</span></span><br><span class="line"><span class="comment">#define PINCTRL_STATE_SLEEP &quot;sleep&quot;</span></span><br></pre></td></tr></table></figure>
<p>pinctrl_select_state。设定一个具体的pin control state接口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * pinctrl_select_state() - select/activate/program a pinctrl state to HW</span><br><span class="line"> * @p: the pinctrl handle <span class="keyword">for</span> the device that requests configuration</span><br><span class="line"> * @state: the state handle to select/activate/program</span><br><span class="line"> */</span><br><span class="line">int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == state)</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> pinctrl_commit_state(p, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与gpio交互"><a href="#与gpio交互" class="headerlink" title="与gpio交互"></a>与gpio交互</h3><p>pinctrl_request_gpio。该接口主要用来申请GPIO。GPIO也是一种资源，使用前应该request，使用完毕后释放。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * pinctrl_request_gpio() - request a single pin to be used as GPIO</span><br><span class="line"> * @gpio: the GPIO pin number from the GPIO subsystem number space</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> should *ONLY* be used from gpiolib-based GPIO drivers,</span><br><span class="line"> * as part of their gpio_request() semantics, platforms and individual drivers</span><br><span class="line"> * shall *NOT* request GPIO pins to be muxed <span class="keyword">in</span>.</span><br><span class="line"> */</span><br><span class="line">int pinctrl_request_gpio(unsigned gpio)  //里传入的是GPIO 的ID</span><br><span class="line">&#123;</span><br><span class="line">	struct pinctrl_dev *pctldev;</span><br><span class="line">	struct pinctrl_gpio_range *range;</span><br><span class="line">	int ret;</span><br><span class="line">	int pin;</span><br><span class="line"></span><br><span class="line">	ret = pinctrl_get_device_gpio_range(gpio, &amp;pctldev, &amp;range);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pinctrl_ready_for_gpio_range(gpio))</span><br><span class="line">			ret = 0;</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;pctldev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	/* Convert to the pin controllers number space */</span><br><span class="line">	pin = gpio_to_pin(range, gpio);</span><br><span class="line"></span><br><span class="line">    /* 这里主要是进行复用功能的设定，毕竟GPIO也是引脚的一个特定的功能。pinmux_request_gpio函数的作用主要有两个，一个是在core driver中标记该pin已经  * 用作GPIO了，这样，如果有模块后续request该资源，那么core driver可以拒绝不合理的要求。第二步就是调用底层pin controller driver的callback函   * 数，进行底层寄存器相关的操作。</span><br><span class="line">     */</span><br><span class="line">	ret = pinmux_request_gpio(pctldev, range, pin, gpio);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;pctldev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据GPIO ID找到该ID对应的pin control device（struct pinctrl_dev）和GPIO rang（pinctrl_gpio_range）。在core driver中，每个low level的pin controller device都被映射成一个struct pinctrl_dev，并形成链表，链表头就是pinctrldev_list。由于实际的硬件设计（例如GPIO block被分成若干个GPIO 的bank，每个bank就对应一个HW GPIO Controller Block），一个pin control device要管理的GPIO ID是分成区域的，每个区域用struct pinctrl_gpio_range来抽象，在low level 的pin controller初始化的时候（具体参考samsung_pinctrl_register的代码），会调用pinctrl_add_gpio_range将每个GPIO bank表示的gpio range挂入到pin control device的range list中（gpio_ranges成员）。pinctrl_gpio_range 的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct pinctrl_gpio_range - each pin controller can provide subranges of</span><br><span class="line"> * the GPIO number space to be handled by the controller</span><br><span class="line"> * @node: list node <span class="keyword">for</span> internal use</span><br><span class="line"> * @name: a name <span class="keyword">for</span> the chip <span class="keyword">in</span> this range</span><br><span class="line"> * @id: an ID number <span class="keyword">for</span> the chip <span class="keyword">in</span> this range</span><br><span class="line"> * @base: base offset of the GPIO range</span><br><span class="line"> * @pin_base: base pin number of the GPIO range <span class="keyword">if</span> pins == NULL</span><br><span class="line"> * @pins: enumeration of pins <span class="keyword">in</span> GPIO range or NULL</span><br><span class="line"> * @npins: number of pins <span class="keyword">in</span> the GPIO range, including the base number</span><br><span class="line"> * @gc: an optional pointer to a gpio_chip</span><br><span class="line"> */</span><br><span class="line">struct pinctrl_gpio_range &#123;</span><br><span class="line">	struct list_head node;</span><br><span class="line">	const char *name;</span><br><span class="line">	unsigned int id;       //GPIO chip ID</span><br><span class="line">	unsigned int base;     //该range中的起始GPIO ID</span><br><span class="line">	unsigned int pin_base; //在线性映射的情况下，这是起始的pin base</span><br><span class="line">	unsigned const *pins;  //在非线性映射的时候，这是table是pin到GPIO的lookup table</span><br><span class="line">	unsigned int npins;    //这个range有多少个GPIO引脚</span><br><span class="line">	struct gpio_chip *gc;  //-每个GPIO bank都是一个gpio chip，对应一个GPIO range</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pinctrl_free_gpio。有申请就有释放，这是pinctrl_request_gpio的逆函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void pinctrl_free_gpio(unsigned gpio)</span><br><span class="line">&#123;</span><br><span class="line">	struct pinctrl_dev *pctldev;</span><br><span class="line">	struct pinctrl_gpio_range *range;</span><br><span class="line">	int ret;</span><br><span class="line">	int pin;</span><br><span class="line"></span><br><span class="line">	ret = pinctrl_get_device_gpio_range(gpio, &amp;pctldev, &amp;range);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_lock(&amp;pctldev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	/* Convert to the pin controllers number space */</span><br><span class="line">	pin = gpio_to_pin(range, gpio);</span><br><span class="line"></span><br><span class="line">	pinmux_free_gpio(pctldev, pin, range);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;pctldev-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_free_gpio);</span><br></pre></td></tr></table></figure>
<p>pinctrl_gpio_direction_input和pinctrl_gpio_direction_output。为已经指定为GPIO功能的引脚设定方向，输入或者输出。代码很简单，不再赘述。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * pinctrl_gpio_direction_input() - request a GPIO pin to go into input mode</span><br><span class="line"> * @gpio: the GPIO pin number from the GPIO subsystem number space</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> should *ONLY* be used from gpiolib-based GPIO drivers,</span><br><span class="line"> * as part of their gpio_direction_input() semantics, platforms and individual</span><br><span class="line"> * drivers shall *NOT* touch pin control GPIO calls.</span><br><span class="line"> */</span><br><span class="line">int pinctrl_gpio_direction_input(unsigned gpio)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> pinctrl_gpio_direction(gpio, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * pinctrl_gpio_direction_output() - request a GPIO pin to go into output mode</span><br><span class="line"> * @gpio: the GPIO pin number from the GPIO subsystem number space</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> should *ONLY* be used from gpiolib-based GPIO drivers,</span><br><span class="line"> * as part of their gpio_direction_output() semantics, platforms and individual</span><br><span class="line"> * drivers shall *NOT* touch pin control GPIO calls.</span><br><span class="line"> */</span><br><span class="line">int pinctrl_gpio_direction_output(unsigned gpio)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> pinctrl_gpio_direction(gpio, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、与驱动模型有关接口"><a href="#四、与驱动模型有关接口" class="headerlink" title="四、与驱动模型有关接口"></a>四、与驱动模型有关接口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int really_probe(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	int local_trigger_count = atomic_read(&amp;deferred_trigger_count);</span><br><span class="line"></span><br><span class="line">	atomic_inc(&amp;probe_count);</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">	WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</span><br><span class="line"></span><br><span class="line">	dev-&gt;driver = drv;</span><br><span class="line"></span><br><span class="line">	/* If using pinctrl, <span class="built_in">bind</span> pins now before probing */</span><br><span class="line">	ret = pinctrl_bind_pins(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		goto probe_failed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, dev_name(dev));</span><br><span class="line">		goto probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">		ret = dev-&gt;pm_domain-&gt;activate(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto probe_failed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;probe(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pinctrl_init_done(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">		dev-&gt;pm_domain-&gt;sync(dev);</span><br><span class="line"></span><br><span class="line">	driver_bound(dev);</span><br><span class="line">	ret = 1;</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">	goto <span class="keyword">done</span>;</span><br><span class="line"></span><br><span class="line">probe_failed:</span><br><span class="line">	devres_release_all(dev);</span><br><span class="line">	driver_sysfs_remove(dev);</span><br><span class="line">	dev-&gt;driver = NULL;</span><br><span class="line">	dev_set_drvdata(dev, NULL);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">		dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line"></span><br><span class="line">	switch (ret) &#123;</span><br><span class="line">	<span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">		/* Driver requested deferred probing */</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add(dev);</span><br><span class="line">		/* Did a trigger occur <span class="keyword">while</span> probing? Need to re-trigger <span class="keyword">if</span> yes */</span><br><span class="line">		<span class="keyword">if</span> (local_trigger_count != atomic_read(&amp;deferred_trigger_count))</span><br><span class="line">			driver_deferred_probe_trigger();</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	<span class="keyword">case</span> -ENODEV:</span><br><span class="line">	<span class="keyword">case</span> -ENXIO:</span><br><span class="line">		pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">			 drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	default:</span><br><span class="line">		/* driver matched but the probe failed */</span><br><span class="line">		printk(KERN_WARNING</span><br><span class="line">		       <span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">		       drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * Ignore errors returned by -&gt;probe so that the next driver can try</span><br><span class="line">	 * its luck.</span><br><span class="line">	 */</span><br><span class="line">	ret = 0;</span><br><span class="line"><span class="keyword">done</span>:</span><br><span class="line">	atomic_dec(&amp;probe_count);</span><br><span class="line">	wake_up(&amp;probe_waitqueue);</span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">/**</span><br><span class="line"> * pinctrl_bind_pins() - called by the device core before probe</span><br><span class="line"> * @dev: the device that is just about to probe</span><br><span class="line"> */</span><br><span class="line">int pinctrl_bind_pins(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* struct device数据结构有一个pins的成员，它描述了和该设备相关的pin control的信息 </span><br><span class="line">     * struct dev_pin_info &#123;</span><br><span class="line">     *     struct pinctrl *p;－－－－－－－－－－－－该device对应的pin control state holder</span><br><span class="line">     *     struct pinctrl_state *default_state;－－－－缺省状态</span><br><span class="line">     *     struct pinctrl_state *sleep_state;－－－－－电源管理相关的状态</span><br><span class="line">     *     struct pinctrl_state *idle_state;－－－－－电源管理相关的状态</span><br><span class="line">     * &#125;;</span><br><span class="line">     */</span><br><span class="line">	dev-&gt;pins = devm_kzalloc(dev, sizeof(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;pins)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    /* 调用devm_pinctrl_get获取该device对应的 pin control state holder句柄 */</span><br><span class="line">	dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;p)) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no pinctrl handle\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(dev-&gt;pins-&gt;p);</span><br><span class="line">		goto cleanup_alloc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 搜索default state，sleep state，idle state并记录在本device中 */</span><br><span class="line">	dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_DEFAULT);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;default_state)) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no default pinctrl state\n&quot;</span>);</span><br><span class="line">		ret = 0;</span><br><span class="line">		goto cleanup_get;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;pins-&gt;init_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_INIT);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;init_state)) &#123;</span><br><span class="line">		/* Not supplying this state is perfectly legal */</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no init pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ret = pinctrl_select_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					   dev-&gt;pins-&gt;default_state);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;init_state);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;failed to activate initial pinctrl state\n&quot;</span>);</span><br><span class="line">		goto cleanup_get;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_PM</span></span><br><span class="line">	/*</span><br><span class="line">	 * If power management is enabled, we also look <span class="keyword">for</span> the optional</span><br><span class="line">	 * sleep and idle pin states, with semantics as defined <span class="keyword">in</span></span><br><span class="line">	 * &lt;linux/pinctrl/pinctrl-state.h&gt;</span><br><span class="line">	 */</span><br><span class="line">	dev-&gt;pins-&gt;sleep_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_SLEEP);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;sleep_state))</span><br><span class="line">		/* Not supplying this state is perfectly legal */</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no sleep pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;pins-&gt;idle_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_IDLE);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;idle_state))</span><br><span class="line">		/* Not supplying this state is perfectly legal */</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no idle pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If no pinctrl handle or default state was found <span class="keyword">for</span> this device,</span><br><span class="line">	 * <span class="built_in">let</span><span class="string">&#x27;s explicitly free the pin container in the device, there is</span></span><br><span class="line"><span class="string">	 * no point in keeping it around.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">cleanup_get:</span></span><br><span class="line"><span class="string">	devm_pinctrl_put(dev-&gt;pins-&gt;p);</span></span><br><span class="line"><span class="string">cleanup_alloc:</span></span><br><span class="line"><span class="string">	devm_kfree(dev, dev-&gt;pins);</span></span><br><span class="line"><span class="string">	dev-&gt;pins = NULL;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Only return deferrals */</span></span><br><span class="line"><span class="string">	if (ret != -EPROBE_DEFER)</span></span><br><span class="line"><span class="string">		ret = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>pinmux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-platform</title>
    <url>/2019/09/05/linux-kernel-platform/</url>
    <content><![CDATA[<h3 id="一、Platform-devices"><a href="#一、Platform-devices" class="headerlink" title="一、Platform devices"></a>一、Platform devices</h3><p>Platform devices are devices that typically appear as autonomous<br>entities in the system. This includes legacy port-based devices and<br>host bridges to peripheral buses, and most controllers integrated<br>into system-on-chip platforms.  What they usually have in common<br>is direct addressing from a CPU bus.  Rarely, a platform_device will<br>be connected through a segment of some other kind of bus; but its<br>registers will still be directly addressable.</p>
<p>Platform devices are given a name, used in driver binding, and a<br>list of resources such as addresses and IRQs.</p>
<p>struct platform_device {<br>    const char    *name;<br>    u32        id;<br>    struct device    dev;<br>    u32        num_resources;<br>    struct resource    *resource;<br>};</p>
<h3 id="二、Platform-drivers"><a href="#二、Platform-drivers" class="headerlink" title="二、Platform drivers"></a>二、Platform drivers</h3><p>Platform drivers follow the standard driver model convention, where<br>discovery/enumeration is handled outside the drivers, and drivers<br>provide probe() and remove() methods.  They support power management<br>and shutdown notifications using the standard conventions.</p>
<p>struct platform_driver {<br>    int (*probe)(struct platform_device *);<br>    int (*remove)(struct platform_device *);<br>    void (*shutdown)(struct platform_device *);<br>    int (*suspend)(struct platform_device *, pm_message_t state);<br>    int (*suspend_late)(struct platform_device *, pm_message_t state);<br>    int (*resume_early)(struct platform_device *);<br>    int (*resume)(struct platform_device *);<br>    struct device_driver driver;<br>};</p>
<p>Note that probe() should in general verify that the specified device hardware<br>actually exists; sometimes platform setup code can’t be sure.  The probing<br>can use device resources, including clocks, and device platform_data.</p>
<p>Platform drivers register themselves the normal way:</p>
<pre><code>int platform_driver_register(struct platform_driver *drv);</code></pre>
<p>Or, in common situations where the device is known not to be hot-pluggable,<br>the probe() routine can live in an init section to reduce the driver’s<br>runtime memory footprint:</p>
<pre><code>int platform_driver_probe(struct platform_driver *drv,
          int (*probe)(struct platform_device *))</code></pre>
<p>Kernel modules can be composed of several platform drivers. The platform core<br>provides helpers to register and unregister an array of drivers:</p>
<pre><code>int __platform_register_drivers(struct platform_driver * const *drivers,
                  unsigned int count, struct module *owner);
void platform_unregister_drivers(struct platform_driver * const *drivers,
                 unsigned int count);</code></pre>
<p>If one of the drivers fails to register, all drivers registered up to that<br>point will be unregistered in reverse order. Note that there is a convenience<br>macro that passes THIS_MODULE as owner parameter:</p>
<pre><code>#define platform_register_drivers(drivers, count)</code></pre>
<h3 id="三、Device-Enumeration"><a href="#三、Device-Enumeration" class="headerlink" title="三、Device Enumeration"></a>三、Device Enumeration</h3><p>As a rule, platform specific (and often board-specific) setup code will<br>register platform devices:</p>
<pre><code>int platform_device_register(struct platform_device *pdev);

int platform_add_devices(struct platform_device **pdevs, int ndev);</code></pre>
<p>The general rule is to register only those devices that actually exist,<br>but in some cases extra devices might be registered.  For example, a kernel<br>might be configured to work with an external network adapter that might not<br>be populated on all boards, or likewise to work with an integrated controller<br>that some boards might not hook up to any peripherals.</p>
<p>In some cases, boot firmware will export tables describing the devices<br>that are populated on a given board.   Without such tables, often the<br>only way for system setup code to set up the correct devices is to build<br>a kernel for a specific target board.  Such board-specific kernels are<br>common with embedded and custom systems development.</p>
<p>In many cases, the memory and IRQ resources associated with the platform<br>device are not enough to let the device’s driver work.  Board setup code<br>will often provide additional information using the device’s platform_data<br>field to hold additional information.</p>
<p>Embedded systems frequently need one or more clocks for platform devices,<br>which are normally kept off until they’re actively needed (to save power).<br>System setup also associates those clocks with the device, so that that<br>calls to clk_get(&amp;pdev-&gt;dev, clock_name) return them as needed.</p>
<h3 id="四、Device-Naming-and-Driver-Binding"><a href="#四、Device-Naming-and-Driver-Binding" class="headerlink" title="四、Device Naming and Driver Binding"></a>四、Device Naming and Driver Binding</h3><p>The platform_device.dev.bus_id is the canonical name for the devices.<br>It’s built from two components:</p>
<pre><code>* platform_device.name ... which is also used to for driver matching.

* platform_device.id ... the device instance number, or else &quot;-1&quot;
  to indicate there&#39;s only one.</code></pre>
<p>These are concatenated, so name/id “serial”/0 indicates bus_id “serial.0”, and<br>“serial/3” indicates bus_id “serial.3”; both would use the platform_driver<br>named “serial”.  While “my_rtc”/-1 would be bus_id “my_rtc” (no instance id)<br>and use the platform_driver called “my_rtc”.</p>
<p>Driver binding is performed automatically by the driver core, invoking<br>driver probe() after finding a match between device and driver.  If the<br>probe() succeeds, the driver and device are bound as usual.  There are<br>three different ways to find such a match:</p>
<pre><code>- Whenever a device is registered, the drivers for that bus are
  checked for matches.  Platform devices should be registered very
  early during system boot.

- When a driver is registered using platform_driver_register(), all
  unbound devices on that bus are checked for matches.  Drivers
  usually register later during booting, or by module loading.

- Registering a driver using platform_driver_probe() works just like
  using platform_driver_register(), except that the driver won&#39;t
  be probed later if another device registers.  (Which is OK, since
  this interface is only for use with non-hotpluggable devices.)</code></pre>
<h3 id="五、Early-Platform-Devices-and-Drivers"><a href="#五、Early-Platform-Devices-and-Drivers" class="headerlink" title="五、Early Platform Devices and Drivers"></a>五、Early Platform Devices and Drivers</h3><p>The early platform interfaces provide platform data to platform device<br>drivers early on during the system boot. The code is built on top of the<br>early_param() command line parsing and can be executed very early on.</p>
<p>Example: “earlyprintk” class early serial console in 6 steps</p>
<ol>
<li>Registering early platform device data</li>
</ol>
<p>The architecture code registers platform device data using the function<br>early_platform_add_devices(). In the case of early serial console this<br>should be hardware configuration for the serial port. Devices registered<br>at this point will later on be matched against early platform drivers.</p>
<ol start="2">
<li>Parsing kernel command line</li>
</ol>
<p>The architecture code calls parse_early_param() to parse the kernel<br>command line. This will execute all matching early_param() callbacks.<br>User specified early platform devices will be registered at this point.<br>For the early serial console case the user can specify port on the<br>kernel command line as “earlyprintk=serial.0” where “earlyprintk” is<br>the class string, “serial” is the name of the platform driver and<br>0 is the platform device id. If the id is -1 then the dot and the<br>id can be omitted.</p>
<ol start="3">
<li>Installing early platform drivers belonging to a certain class</li>
</ol>
<p>The architecture code may optionally force registration of all early<br>platform drivers belonging to a certain class using the function<br>early_platform_driver_register_all(). User specified devices from<br>step 2 have priority over these. This step is omitted by the serial<br>driver example since the early serial driver code should be disabled<br>unless the user has specified port on the kernel command line.</p>
<ol start="4">
<li>Early platform driver registration</li>
</ol>
<p>Compiled-in platform drivers making use of early_platform_init() are<br>automatically registered during step 2 or 3. The serial driver example<br>should use early_platform_init(“earlyprintk”, &amp;platform_driver).</p>
<ol start="5">
<li>Probing of early platform drivers belonging to a certain class</li>
</ol>
<p>The architecture code calls early_platform_driver_probe() to match<br>registered early platform devices associated with a certain class with<br>registered early platform drivers. Matched devices will get probed().<br>This step can be executed at any point during the early boot. As soon<br>as possible may be good for the serial port case.</p>
<ol start="6">
<li>Inside the early platform driver probe()</li>
</ol>
<p>The driver code needs to take special care during early boot, especially<br>when it comes to memory allocation and interrupt registration. The code<br>in the probe() function can use is_early_platform_device() to check if<br>it is called at early platform device or at the regular platform device<br>time. The early serial driver performs register_console() at this point.</p>
<h3 id="六、概述"><a href="#六、概述" class="headerlink" title="六、概述"></a>六、概述</h3><p>paltform设备对Linux驱动工程师是非常重要的，因为我们编写的大多数设备驱动，都是为了驱动plaftom设备。本文我们就来看看Platform设备在内核中的实现。<br>Platform设备在内核中的实现主要包括三个部分：</p>
<ul>
<li>Platform Bus，基于底层bus模块，抽象出一个虚拟的Platform bus，用于挂载Platform设备；</li>
<li>Platform Device，基于底层device模块，抽象出Platform Device，用于表示Platform设备；</li>
<li>Platform Driver，基于底层device_driver模块，抽象出Platform Driver，用于驱动Platform设备。</li>
</ul>
<h3 id="七、数据结构"><a href="#七、数据结构" class="headerlink" title="七、数据结构"></a>七、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">	const char	*name; //设备名称和struct device结构中的init_name意义相同。实际上，该名称在设备注册时，会拷贝到dev.init_name中</span><br><span class="line">	int		id;  //设备ID，设备驱动的probe，依赖于名称，Linux采取的策略是：在bus的设备链表中查找device，和对应的device_driver比对name，如果相同，则查看该设备是否已经绑定了driver（查看其dev-&gt;driver指针是否为空），如果已绑定，则不会执行probe动作，如果没有绑定，则以该device的指针为参数，调用driver的probe接口。</span><br><span class="line">因此，在driver的probe接口中，通过判断设备的ID，可以知道此次驱动的设备是哪个</span><br><span class="line">	bool		id_auto; //指示在注册设备时，是否自动赋予ID值</span><br><span class="line">	struct device	dev; //真正的设备（Platform设备只是一个特殊的设备，因此其核心逻辑还是由底层的模块实现）</span><br><span class="line">	u32		num_resources;</span><br><span class="line">	struct resource	*resource; //该设备的资源描述，由struct resource（include/linux/ioport.h）结构抽象。在Linux中，系统资源包括I/O、Memory、Register、IRQ、DMA、Bus等多种类型。这些资源大多具有独占性，不允许多个设备同时使用，因此Linux内核提供了一些API，用于分配、管理这些资源。</span><br><span class="line">当某个设备需要使用某些资源时，只需利用struct resource组织这些资源（如名称、类型、起始、结束地址等），并保存在该设备的resource指针中即可。然后在设备probe时，设备需求会调用资源管理接口，分配、使用这些资源。而内核的资源管理逻辑，可以判断这些资源是否已被使用、是否可被使用等等</span><br><span class="line"></span><br><span class="line">	const struct platform_device_id	*id_entry; //和内核模块相关的内容</span><br><span class="line">	char *driver_override; /* Driver name to force a match */</span><br><span class="line"></span><br><span class="line">	/* MFD cell pointer */</span><br><span class="line">	struct mfd_cell *mfd_cell; //和MFD设备相关的内容</span><br><span class="line"></span><br><span class="line">	/* arch specific additions */</span><br><span class="line">	struct pdev_archdata	archdata; //它的目的是为了保存一些architecture相关的数据</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">struct platform_driver &#123;</span><br><span class="line">	int (*probe)(struct platform_device *);</span><br><span class="line">	int (*remove)(struct platform_device *);</span><br><span class="line">	void (*shutdown)(struct platform_device *);</span><br><span class="line">	int (*<span class="built_in">suspend</span>)(struct platform_device *, pm_message_t state);</span><br><span class="line">	int (*resume)(struct platform_device *);</span><br><span class="line">	struct device_driver driver;</span><br><span class="line">	const struct platform_device_id *id_table;</span><br><span class="line">	bool prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="八、API"><a href="#八、API" class="headerlink" title="八、API"></a>八、API</h3><p><strong>init</strong><br>初始化函数调用流程是<br> start_kernel-&gt;reset_init-&gt;kernel_init-&gt;do_basic_setup-&gt;driver_init-&gt;platform_bus_init</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct bus_type platform_bus_type = &#123;</span><br><span class="line">	.name		= <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">	.dev_groups	= platform_dev_groups,</span><br><span class="line">	.match		= platform_match,</span><br><span class="line">	.uevent		= platform_uevent,</span><br><span class="line">	.pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">	.force_dma	= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br><span class="line">...</span><br><span class="line">int __init platform_bus_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	/* 清除所有和Early device/driver相关的代码。因为执行到这里的时候，证明系统已经完成了Early阶段的启动，转而进行正常的设备初始化、启动操作，所以不再需要Early Platform相关的东西 */</span><br><span class="line">	early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">	/* 注册一个名称为platform_bus的设备，该设备的定义非常简单，只包含init_name（为“platform”）。该步骤会在sysfs中创建“/sys/devices/platform/”目录，所有的Platform设备，都会包含在此目录下 */</span><br><span class="line">	error = device_register(&amp;platform_bus);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line">	/* 注册一个名称为platform_bus_type的bus */</span><br><span class="line">	error =  bus_register(&amp;platform_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		device_unregister(&amp;platform_bus);</span><br><span class="line">	of_platform_register_reconfig_notifier();</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Early platform device/driver<br>内核启动时，要完成一定的初始化操作之后，才会处理device和driver的注册及probe，因此在这之前，常规的platform设备是无法使用的。但是在Linux中，有些设备需要尽早使用（如在启动过程中充当console输出的serial设备），所以platform模块提供了一种称作Early platform device/driver的机制，允许驱动开发人员，在开发驱动时，向内核注册可在内核早期启动过程中使用的driver</p>
<p><strong>platform device和platform driver的注册</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int platform_device_add(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	int i, ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pdev) //参数检查</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	/* 如果该设备没有指定父设备，将其父设备设置为platform_bus，即“/sys/devices/platform/”所代表的设备，这时该设备的sysfs目录即为“/sys/devices/platform/xxx_device”。*/</span><br><span class="line">	<span class="keyword">if</span> (!pdev-&gt;dev.parent)</span><br><span class="line">		pdev-&gt;dev.parent = &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">	/* 将该设备的bus指定为platform_bus_type */</span><br><span class="line">	pdev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line"></span><br><span class="line">	/* 根据设备的ID，修改或者设置设备的名称。对于多个同名的设备，可以使用ID区分，在这里将实际名称修改为“name.id”的形式。 */</span><br><span class="line">	switch (pdev-&gt;id) &#123;</span><br><span class="line">	default:</span><br><span class="line">		dev_set_name(&amp;pdev-&gt;dev, <span class="string">&quot;%s.%d&quot;</span>, pdev-&gt;name,  pdev-&gt;id);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PLATFORM_DEVID_NONE:</span><br><span class="line">		dev_set_name(&amp;pdev-&gt;dev, <span class="string">&quot;%s&quot;</span>, pdev-&gt;name);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PLATFORM_DEVID_AUTO:</span><br><span class="line">		/*</span><br><span class="line">		 * Automatically allocated device ID. We mark it as such so</span><br><span class="line">		 * that we remember it must be freed, and we append a suffix</span><br><span class="line">		 * to avoid namespace collision with explicit IDs.</span><br><span class="line">		 */</span><br><span class="line">		ret = ida_simple_get(&amp;platform_devid_ida, 0, 0, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">			goto err_out;</span><br><span class="line">		pdev-&gt;id = ret;</span><br><span class="line">		pdev-&gt;id_auto = <span class="literal">true</span>;</span><br><span class="line">		dev_set_name(&amp;pdev-&gt;dev, <span class="string">&quot;%s.%d.auto&quot;</span>, pdev-&gt;name, pdev-&gt;id);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 调用resource模块的 insert_resource 接口，将该设备需要使用的resource统一管理起来（我们知道，在这之前，只是声明了本设备需要使用哪些resource，但resource模块并不知情，也就无从管理，因此需要告知） */</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; pdev-&gt;num_resources; i++) &#123;</span><br><span class="line">		struct resource *p, *r = &amp;pdev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r-&gt;name == NULL)</span><br><span class="line">			r-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">		p = r-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">				p = &amp;iomem_resource;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">				p = &amp;ioport_resource;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p &amp;&amp; insert_resource(p, r)) &#123;</span><br><span class="line">			dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to claim resource %d: %pR\n&quot;</span>, i, r);</span><br><span class="line">			ret = -EBUSY;</span><br><span class="line">			goto failed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Registering platform device &#x27;%s&#x27;. Parent at %s\n&quot;</span>,</span><br><span class="line">		 dev_name(&amp;pdev-&gt;dev), dev_name(pdev-&gt;dev.parent));</span><br><span class="line"></span><br><span class="line">	/* 调用device_add接口，将内嵌的struct device变量添加到内核中 */</span><br><span class="line">	ret = device_add(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == 0)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line"> failed:</span><br><span class="line">	<span class="keyword">if</span> (pdev-&gt;id_auto) &#123;</span><br><span class="line">		ida_simple_remove(&amp;platform_devid_ida, pdev-&gt;id);</span><br><span class="line">		pdev-&gt;id = PLATFORM_DEVID_AUTO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (--i &gt;= 0) &#123;</span><br><span class="line">		struct resource *r = &amp;pdev-&gt;resource[i];</span><br><span class="line">		<span class="keyword">if</span> (r-&gt;parent)</span><br><span class="line">			release_resource(r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> err_out:</span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_device_add);</span><br><span class="line">...</span><br><span class="line">int __platform_driver_register(struct platform_driver *drv,</span><br><span class="line">				struct module *owner)</span><br><span class="line">&#123;</span><br><span class="line">	drv-&gt;driver.owner = owner;</span><br><span class="line">	/* 将该driver的bus指定为platform_bus_type */</span><br><span class="line">	drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">	/* 如果该platform driver提供了probe、remove、shutdown等回调函数，将该它内嵌的struct driver变量的probe、remove、shutdown等指针，设置为platform模块提供函数，包括platform_drv_probe、platform_drv_remove和platform_drv_shutdown。因为probe等动作会从struct driver变量开始，经过platform_drv_xxx等接口的转接，就可以到达platform diver自身的回调函数中。 */</span><br><span class="line">	drv-&gt;driver.probe = platform_drv_probe;</span><br><span class="line">	drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">	drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">	/* 调用driver_register接口，将内嵌的struct driver变量添加到内核中 */</span><br><span class="line">	<span class="built_in">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__platform_driver_register);</span><br><span class="line">...</span><br><span class="line">int __platform_register_drivers(struct platform_driver * const *drivers,</span><br><span class="line">				unsigned int count, struct module *owner)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;registering platform driver %ps\n&quot;</span>, drivers[i]);</span><br><span class="line"></span><br><span class="line">		/* 调用__platform_driver_register这个函数*/</span><br><span class="line">		err = __platform_driver_register(drivers[i], owner);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; 0) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;failed to register platform driver %ps: %d\n&quot;</span>,</span><br><span class="line">			       drivers[i], err);</span><br><span class="line">			goto error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">while</span> (i--) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;unregistering platform driver %ps\n&quot;</span>, drivers[i]);</span><br><span class="line">		platform_driver_unregister(drivers[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__platform_register_drivers);</span><br></pre></td></tr></table></figure>
<p><strong>probe</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int platform_drv_probe(struct device *_dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct platform_driver *drv = to_platform_driver(_dev-&gt;driver);</span><br><span class="line">	struct platform_device *dev = to_platform_device(_dev);</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = of_clk_set_defaults(_dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = dev_pm_domain_attach(_dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != -EPROBE_DEFER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">			ret = drv-&gt;probe(dev); //调用驱动的probe</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				dev_pm_domain_detach(_dev, <span class="literal">true</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			/* don<span class="string">&#x27;t fail if just dev_pm_domain_attach failed */</span></span><br><span class="line"><span class="string">			ret = 0;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (drv-&gt;prevent_deferred_probe &amp;&amp; ret == -EPROBE_DEFER) &#123;</span></span><br><span class="line"><span class="string">		dev_warn(_dev, &quot;probe deferral not supported\n&quot;);</span></span><br><span class="line"><span class="string">		ret = -ENXIO;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>platform_device_register、platform_device_unregister，Platform设备的注册/注销接口，和底层的device_register等接口类似。</p>
<p>arch_setup_pdev_archdata，设置platform_device变量中的archdata指针。</p>
<p>platform_get_resource、platform_get_irq、platform_get_resource_byname、platform_get_irq_byname，通过这些接口，可以获取platform_device变量中的resource信息，以及直接获取IRQ的number等等。</p>
<p>platform_device_register_full、platform_device_register_resndata、platform_device_register_simple、platform_device_register_data，其它形式的设备注册。调用者只需要提供一些必要的信息，如name、ID、resource等，Platform模块就会自动分配一个struct platform_device变量，填充内容后，注册到内核中。</p>
<p>platform_device_alloc，以name和id为参数，动态分配一个struct platform_device变量。</p>
<p>platform_device_add_resources，向platform device中增加资源描述。</p>
<p>platform_device_add_data，向platform device中添加自定义的数据（保存在pdev-&gt;dev.platform_data指针中）。</p>
<p>platform_device_add、platform_device_del、platform_device_put，其它操作接口。<br>platform_driver_registe、platform_driver_unregister，platform driver的注册、注销接口。</p>
<p>platform_driver_probe，主动执行probe动作。</p>
<p>platform_set_drvdata、platform_get_drvdata，设置或者获取driver保存在device变量中的私有数据。</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>platform</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-pwm</title>
    <url>/2019/09/12/linux-kernel-pwm/</url>
    <content><![CDATA[<p>This provides an overview about the Linux PWM interface</p>
<p>PWMs are commonly used for controlling LEDs, fans or vibrators in<br>cell phones. PWMs with a fixed purpose have no need implementing<br>the Linux PWM API (although they could). However, PWMs are often<br>found as discrete devices on SoCs which have no fixed purpose. It’s<br>up to the board designer to connect them to LEDs or fans. To provide<br>this kind of flexibility the generic PWM API exists.</p>
<h3 id="一、Identifying-PWMs"><a href="#一、Identifying-PWMs" class="headerlink" title="一、Identifying PWMs"></a>一、Identifying PWMs</h3><p>Users of the legacy PWM API use unique IDs to refer to PWM devices.</p>
<p>Instead of referring to a PWM device via its unique ID, board setup code<br>should instead register a static mapping that can be used to match PWM<br>consumers to providers, as given in the following example::</p>
<pre><code>static struct pwm_lookup board_pwm_lookup[] = &#123;
    PWM_LOOKUP(&quot;tegra-pwm&quot;, 0, &quot;pwm-backlight&quot;, NULL,
           50000, PWM_POLARITY_NORMAL),
&#125;;

static void __init board_init(void)
&#123;
    ...
    pwm_add_table(board_pwm_lookup, ARRAY_SIZE(board_pwm_lookup));
    ...
&#125;</code></pre>
<h3 id="二、Using-PWMs"><a href="#二、Using-PWMs" class="headerlink" title="二、Using PWMs"></a>二、Using PWMs</h3><p>Legacy users can request a PWM device using pwm_request() and free it<br>after usage with pwm_free().</p>
<p>New users should use the pwm_get() function and pass to it the consumer<br>device or a consumer name. pwm_put() is used to free the PWM device. Managed<br>variants of these functions, devm_pwm_get() and devm_pwm_put(), also exist.</p>
<p>After being requested, a PWM has to be configured using::</p>
<pre><code>int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state);</code></pre>
<p>This API controls both the PWM period/duty_cycle config and the<br>enable/disable state.</p>
<p>The pwm_config(), pwm_enable() and pwm_disable() functions are just wrappers<br>around pwm_apply_state() and should not be used if the user wants to change<br>several parameter at once. For example, if you see pwm_config() and<br>pwm_{enable,disable}() calls in the same function, this probably means you<br>should switch to pwm_apply_state().</p>
<p>The PWM user API also allows one to query the PWM state with pwm_get_state().</p>
<p>In addition to the PWM state, the PWM API also exposes PWM arguments, which<br>are the reference PWM config one should use on this PWM.<br>PWM arguments are usually platform-specific and allows the PWM user to only<br>care about dutycycle relatively to the full period (like, duty = 50% of the<br>period). struct pwm_args contains 2 fields (period and polarity) and should<br>be used to set the initial PWM config (usually done in the probe function<br>of the PWM user). PWM arguments are retrieved with pwm_get_args().</p>
<h3 id="三、Using-PWMs-with-the-sysfs-interface"><a href="#三、Using-PWMs-with-the-sysfs-interface" class="headerlink" title="三、Using PWMs with the sysfs interface"></a>三、Using PWMs with the sysfs interface</h3><p>If CONFIG_SYSFS is enabled in your kernel configuration a simple sysfs<br>interface is provided to use the PWMs from userspace. It is exposed at<br>/sys/class/pwm/. Each probed PWM controller/chip will be exported as<br>pwmchipN, where N is the base of the PWM chip. Inside the directory you<br>will find:</p>
<p>  npwm<br>    The number of PWM channels this chip supports (read-only).</p>
<p>  export<br>    Exports a PWM channel for use with sysfs (write-only).</p>
<p>  unexport<br>   Unexports a PWM channel from sysfs (write-only).</p>
<p>The PWM channels are numbered using a per-chip index from 0 to npwm-1.</p>
<p>When a PWM channel is exported a pwmX directory will be created in the<br>pwmchipN directory it is associated with, where X is the number of the<br>channel that was exported. The following properties will then be available:</p>
<p>  period<br>    The total period of the PWM signal (read/write).<br>    Value is in nanoseconds and is the sum of the active and inactive<br>    time of the PWM.</p>
<p>  duty_cycle<br>    The active time of the PWM signal (read/write).<br>    Value is in nanoseconds and must be less than the period.</p>
<p>  polarity<br>    Changes the polarity of the PWM signal (read/write).<br>    Writes to this property only work if the PWM chip supports changing<br>    the polarity. The polarity can only be changed if the PWM is not<br>    enabled. Value is the string “normal” or “inversed”.</p>
<p>  enable<br>    Enable/disable the PWM signal (read/write).</p>
<pre><code>- 0 - disabled
- 1 - enabled</code></pre>
<h3 id="四、Implementing-a-PWM-driver"><a href="#四、Implementing-a-PWM-driver" class="headerlink" title="四、Implementing a PWM driver"></a>四、Implementing a PWM driver</h3><p>Currently there are two ways to implement pwm drivers. Traditionally<br>there only has been the barebone API meaning that each driver has<br>to implement the pwm_*() functions itself. This means that it’s impossible<br>to have multiple PWM drivers in the system. For this reason it’s mandatory<br>for new drivers to use the generic PWM framework.</p>
<p>A new PWM controller/chip can be added using pwmchip_add() and removed<br>again with pwmchip_remove(). pwmchip_add() takes a filled in struct<br>pwm_chip as argument which provides a description of the PWM chip, the<br>number of PWM devices provided by the chip and the chip-specific<br>implementation of the supported PWM operations to the framework.</p>
<p>When implementing polarity support in a PWM driver, make sure to respect the<br>signal conventions in the PWM framework. By definition, normal polarity<br>characterizes a signal starts high for the duration of the duty cycle and<br>goes low for the remainder of the period. Conversely, a signal with inversed<br>polarity starts low for the duration of the duty cycle and goes high for the<br>remainder of the period.</p>
<p>Drivers are encouraged to implement -&gt;apply() instead of the legacy<br>-&gt;enable(), -&gt;disable() and -&gt;config() methods. Doing that should provide<br>atomicity in the PWM config workflow, which is required when the PWM controls<br>a critical device (like a regulator).</p>
<p>The implementation of -&gt;get_state() (a method used to retrieve initial PWM<br>state) is also encouraged for the same reason: letting the PWM user know<br>about the current PWM state would allow him to avoid glitches.</p>
<h3 id="五、Locking"><a href="#五、Locking" class="headerlink" title="五、Locking"></a>五、Locking</h3><p>The PWM core list manipulations are protected by a mutex, so pwm_request()<br>and pwm_free() may not be called from an atomic context. Currently the<br>PWM core does not enforce any locking to pwm_enable(), pwm_disable() and<br>pwm_config(), so the calling context is currently driver specific. This<br>is an issue derived from the former barebone API and should be fixed soon.</p>
<h3 id="六、数据结构"><a href="#六、数据结构" class="headerlink" title="六、数据结构"></a>六、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct pwm_state &#123;</span><br><span class="line">	unsigned int period;</span><br><span class="line">	unsigned int duty_cycle;</span><br><span class="line">	enum pwm_polarity polarity;</span><br><span class="line">	bool enabled;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pwm_device &#123;</span><br><span class="line">	const char *label;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	unsigned int hwpwm;</span><br><span class="line">	unsigned int pwm;</span><br><span class="line">	struct pwm_chip *chip;</span><br><span class="line">	void *chip_data;</span><br><span class="line"></span><br><span class="line">	struct pwm_args args;</span><br><span class="line">	struct pwm_state state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pwm_ops &#123;</span><br><span class="line">	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);</span><br><span class="line">	void (*free)(struct pwm_chip *chip, struct pwm_device *pwm); //不再使用。</span><br><span class="line">	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,</span><br><span class="line">		      int duty_ns, int period_ns); //配置pwm device的频率、占空比。必须提供！</span><br><span class="line">	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,</span><br><span class="line">			    enum pwm_polarity polarity); //设置pwm信号的极性。可选，具体需要参考of_pwm_n_cells的定义</span><br><span class="line">	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,</span><br><span class="line">		       struct pwm_capture *result, unsigned long timeout);</span><br><span class="line">	int (*<span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line">		)(struct pwm_chip *chip, struct pwm_device *pwm);</span><br><span class="line">	void (*<span class="built_in">disable</span>)(struct pwm_chip *chip, struct pwm_device *pwm); //使能/禁止pwm信号输出。必须提供！</span><br><span class="line">	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,</span><br><span class="line">		     struct pwm_state *state);</span><br><span class="line">	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,</span><br><span class="line">			  struct pwm_state *state);</span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_FS</span></span><br><span class="line">	void (*dbg_show)(struct pwm_chip *chip, struct seq_file *s);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	struct module *owner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pwm_chip &#123;</span><br><span class="line">	struct device *dev;  //该pwm chip对应的设备，一般由pwm driver对应的platform驱动指定。必须提供！</span><br><span class="line">	struct list_head list;</span><br><span class="line">	const struct pwm_ops *ops; //操作PWM设备的回调函数，后面会详细介绍。必须提供！</span><br><span class="line">	int base;</span><br><span class="line">	unsigned int npwm; //该pwm chip可以支持的pwm channel（也可以称作pwm device由struct pwm_device表示）个数，kernel会根据该number，分配相应个数的struct pwm_device结构，保存在pwms指针中。必须提供！</span><br><span class="line"></span><br><span class="line">	struct pwm_device *pwms; //保存所有pwm device的数组，kernel会自行分配，不需要driver关心。</span><br><span class="line"></span><br><span class="line">	struct pwm_device * (*of_xlate)(struct pwm_chip *pc,</span><br><span class="line">					const struct of_phandle_args *args); //用于解析consumer中指定的、pwm信息的DTS node的回调函数</span><br><span class="line">	unsigned int of_pwm_n_cells; //该PWM chip所提供的DTS node的cell，一般是2或者3，例如：为3时，consumer需要在DTS指定pwm number、pwm period和pwm flag三种信息（如2.1中的介绍）；为2时，没有flag信息。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="七、API"><a href="#七、API" class="headerlink" title="七、API"></a>七、API</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static inline int pwm_config(struct pwm_device *pwm, int duty_ns,</span><br><span class="line">			     int period_ns)</span><br><span class="line">&#123;</span><br><span class="line">	struct pwm_state state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pwm)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (duty_ns &lt; 0 || period_ns &lt; 0)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pwm_get_state(pwm, &amp;state);</span><br><span class="line">	<span class="keyword">if</span> (state.duty_cycle == duty_ns &amp;&amp; state.period == period_ns)</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	state.duty_cycle = duty_ns;</span><br><span class="line">	state.period = period_ns;</span><br><span class="line">	<span class="built_in">return</span> pwm_apply_state(pwm, &amp;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pwm_apply_state调用具体driver的apply，例如pwm_sun4i里的sun4i_pwm_apply函数，这个函数将实现具体的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static inline int pwm_enable(struct pwm_device *pwm)</span><br><span class="line">&#123;</span><br><span class="line">	struct pwm_state state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pwm)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pwm_get_state(pwm, &amp;state);</span><br><span class="line">	<span class="keyword">if</span> (state.enabled)</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	state.enabled = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">return</span> pwm_apply_state(pwm, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pwm_disable(struct pwm_device *pwm)</span><br><span class="line">&#123;</span><br><span class="line">	struct pwm_state state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pwm)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	pwm_get_state(pwm, &amp;state);</span><br><span class="line">	<span class="keyword">if</span> (!state.enabled)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	state.enabled = <span class="literal">false</span>;</span><br><span class="line">	pwm_apply_state(pwm, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline int pwm_set_polarity(struct pwm_device *pwm,</span><br><span class="line">				   enum pwm_polarity polarity)</span><br><span class="line">&#123;</span><br><span class="line">	struct pwm_state state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pwm)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pwm_get_state(pwm, &amp;state);</span><br><span class="line">	<span class="keyword">if</span> (state.polarity == polarity)</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Changing the polarity of a running PWM without adjusting the</span><br><span class="line">	 * dutycycle/period value is a bit risky (can introduce glitches).</span><br><span class="line">	 * Return -EBUSY <span class="keyword">in</span> this <span class="keyword">case</span>.</span><br><span class="line">	 * Note that this is allowed when using pwm_apply_state() because</span><br><span class="line">	 * the user specifies all the parameters.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (state.enabled)</span><br><span class="line">		<span class="built_in">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	state.polarity = polarity;</span><br><span class="line">	<span class="built_in">return</span> pwm_apply_state(pwm, &amp;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四个函数都是修改配置信息最后调用driver的apply函数</p>
<p>在sun4i_pwm_probe函数里需要调用pwmchip_add添加到kernel，具体函数如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int sun4i_pwm_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	struct sun4i_pwm_chip *pwm;</span><br><span class="line">	struct resource *res;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/* 分配sun4i_pwm_chip空间 */</span><br><span class="line">	pwm = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*pwm), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pwm)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	pwm-&gt;data = of_device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!pwm-&gt;data)</span><br><span class="line">		<span class="built_in">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	/* 分配io资源*/</span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">	pwm-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(pwm-&gt;base))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(pwm-&gt;base);</span><br><span class="line"></span><br><span class="line">	pwm-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, NULL);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(pwm-&gt;clk))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(pwm-&gt;clk);</span><br><span class="line"></span><br><span class="line">	pwm-&gt;chip.dev = &amp;pdev-&gt;dev;</span><br><span class="line">	pwm-&gt;chip.ops = &amp;sun4i_pwm_ops;</span><br><span class="line">	pwm-&gt;chip.base = -1;</span><br><span class="line">	pwm-&gt;chip.npwm = pwm-&gt;data-&gt;npwm;</span><br><span class="line">	pwm-&gt;chip.of_xlate = of_pwm_xlate_with_flags;</span><br><span class="line">	pwm-&gt;chip.of_pwm_n_cells = 3;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;pwm-&gt;ctrl_lock);</span><br><span class="line"></span><br><span class="line">	ret = pwmchip_add(&amp;pwm-&gt;chip);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to add PWM chip: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, pwm);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>pwm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-reboot</title>
    <url>/2020/02/15/linux-kernel-reboot/</url>
    <content><![CDATA[<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>/kernel/reboot.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Reboot system call: <span class="keyword">for</span> obvious reasons only root may call it,</span><br><span class="line"> * and even root needs to <span class="built_in">set</span> up some magic numbers <span class="keyword">in</span> the registers</span><br><span class="line"> * so that some mistake won<span class="string">&#x27;t make this reboot the whole machine.</span></span><br><span class="line"><span class="string"> * You can also set the meaning of the ctrl-alt-del-key here.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * reboot doesn&#x27;</span>t sync: <span class="keyword">do</span> that yourself before calling this.</span><br><span class="line"> */</span><br><span class="line">SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,</span><br><span class="line">		void __user *, arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct pid_namespace *pid_ns = task_active_pid_ns(current);</span><br><span class="line">	char buffer[256];</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	//判断调用者的用户权限，如果不是超级用户（superuser），则直接返回错误</span><br><span class="line">	/* We only trust the superuser with rebooting the system. */</span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))</span><br><span class="line">		<span class="built_in">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	//判断传入的 magic number是否匹配，如果不匹配，直接返回错误。</span><br><span class="line">	/* For safety, we require <span class="string">&quot;magic&quot;</span> arguments. */</span><br><span class="line">	<span class="keyword">if</span> (magic1 != LINUX_REBOOT_MAGIC1 ||</span><br><span class="line">			(magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2C))</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If pid namespaces are enabled and the current task is <span class="keyword">in</span> a child</span><br><span class="line">	 * pid_namespace, the <span class="built_in">command</span> is handled by reboot_pid_ns() <span class="built_in">which</span> will</span><br><span class="line">	 * call do_exit().</span><br><span class="line">	 */</span><br><span class="line">	ret = reboot_pid_ns(pid_ns, cmd);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">	//如果是POWER_OFF命令，且没有注册power off的machine处理函数（pm_power_off），把该命令转换为HALT命令</span><br><span class="line">	/* Instead of trying to make the power_off code look like</span><br><span class="line">	 * halt when pm_power_off is not <span class="built_in">set</span> <span class="keyword">do</span> it the easy way.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> ((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !pm_power_off)</span><br><span class="line">		cmd = LINUX_REBOOT_CMD_HALT;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;reboot_mutex);</span><br><span class="line">	//根据具体的cmd命令，执行具体的处理，包括，如果是RESTART或者RESTART2命令，调用kernel_restart。如果是CAD_ON或CAD_OFF命令，更新C_A_D的值，表示是否允许通过Ctrl+Alt+Del组合键重启系</span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART:</span><br><span class="line">		kernel_restart(NULL);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_CAD_ON:</span><br><span class="line">		C_A_D = 1;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_CAD_OFF:</span><br><span class="line">		C_A_D = 0;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_HALT:</span><br><span class="line">		kernel_halt();</span><br><span class="line">		do_exit(0);</span><br><span class="line">		panic(<span class="string">&quot;cannot halt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:</span><br><span class="line">		kernel_power_off();</span><br><span class="line">		do_exit(0);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART2:</span><br><span class="line">		ret = strncpy_from_user(&amp;buffer[0], arg, sizeof(buffer) - 1);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		buffer[sizeof(buffer) - 1] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		kernel_restart(buffer);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_KEXEC_CORE</span></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_KEXEC:</span><br><span class="line">		ret = kernel_kexec();</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_HIBERNATION</span></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_SW_SUSPEND:</span><br><span class="line">		ret = hibernate();</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;reboot_mutex);</span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体实现函数"><a href="#具体实现函数" class="headerlink" title="具体实现函数"></a>具体实现函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *	kernel_restart - reboot the system</span><br><span class="line"> *	@cmd: pointer to buffer containing <span class="built_in">command</span> to execute <span class="keyword">for</span> restart</span><br><span class="line"> *		or %NULL</span><br><span class="line"> *</span><br><span class="line"> *	Shutdown everything and perform a clean reboot.</span><br><span class="line"> *	This is not safe to call <span class="keyword">in</span> interrupt context.</span><br><span class="line"> */</span><br><span class="line">void kernel_restart(char *cmd)</span><br><span class="line">&#123;</span><br><span class="line">	kernel_restart_prepare(cmd);</span><br><span class="line">		/* 调用blocking_notifier_call_chain接口，向关心reboot事件的进程，发送SYS_RESTART、SYS_HALT或者SYS_POWER_OFF事件 */</span><br><span class="line">		blocking_notifier_call_chain(&amp;reboot_notifier_list, SYS_RESTART, cmd);</span><br><span class="line">		/* 将系统状态设置为相应的状态（SYS_RESTART、SYS_HALT或SYS_POWER_OFF）*/</span><br><span class="line">		system_state = SYSTEM_RESTART;</span><br><span class="line">		/* 调用usermodehelper_disable接口，禁止User mode helper */</span><br><span class="line">		usermodehelper_disable();</span><br><span class="line">		device_shutdown();</span><br><span class="line">	/* 调用migrate_to_reboot_cpu接口，将当前的进程（task）移到一个CPU上 */</span><br><span class="line">	migrate_to_reboot_cpu();</span><br><span class="line">	/* 调用syscore_shutdown接口，将系统核心器件关闭。system core的shutdown和设备的shutdown类似，也是从一个链表中，遍历所有的system core，并调用它的shutdown接口*/</span><br><span class="line">	syscore_shutdown();</span><br><span class="line">	<span class="keyword">if</span> (!cmd)</span><br><span class="line">		pr_emerg(<span class="string">&quot;Restarting system\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pr_emerg(<span class="string">&quot;Restarting system with command &#x27;%s&#x27;\n&quot;</span>, cmd);</span><br><span class="line">	kmsg_dump(KMSG_DUMP_RESTART);</span><br><span class="line">	machine_restart(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>device_shutdown函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * device_shutdown - call -&gt;shutdown() on each device to shutdown.</span><br><span class="line"> */</span><br><span class="line">void device_shutdown(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev, *parent;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line">	/* 遍历devices_kset的链表，取出所有的设备（struct device）*/</span><br><span class="line">	/*</span><br><span class="line">	 * Walk the devices list backward, shutting down each <span class="keyword">in</span> turn.</span><br><span class="line">	 * Beware that device unplug events may also start pulling</span><br><span class="line">	 * devices offline, even as the system is shutting down.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;devices_kset-&gt;list)) &#123;</span><br><span class="line">		dev = list_entry(devices_kset-&gt;list.prev, struct device,</span><br><span class="line">				kobj.entry);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * hold reference count of device<span class="string">&#x27;s parent to</span></span><br><span class="line"><span class="string">		 * prevent it from being freed because parent&#x27;</span>s</span><br><span class="line">		 * lock is to be held</span><br><span class="line">		 */</span><br><span class="line">		parent = get_device(dev-&gt;parent);</span><br><span class="line">		get_device(dev);</span><br><span class="line">		/*</span><br><span class="line">		 * Make sure the device is off the kset list, <span class="keyword">in</span> the</span><br><span class="line">		 * event that dev-&gt;*-&gt;shutdown() doesn<span class="string">&#x27;t remove it.</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		/* 将该设备从链表中删除*/</span></span><br><span class="line"><span class="string">		list_del_init(&amp;dev-&gt;kobj.entry);</span></span><br><span class="line"><span class="string">		spin_unlock(&amp;devices_kset-&gt;list_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		/* hold lock to avoid race with probe/release */</span></span><br><span class="line"><span class="string">		if (parent)</span></span><br><span class="line"><span class="string">			device_lock(parent);</span></span><br><span class="line"><span class="string">		device_lock(dev);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		/* 调用pm_runtime_get_noresume和pm_runtime_barrier接口，停止所有的Runtime相关的电源管理动作 */</span></span><br><span class="line"><span class="string">		/* Don&#x27;</span>t allow any more runtime suspends */</span><br><span class="line">		pm_runtime_get_noresume(dev);</span><br><span class="line">		pm_runtime_barrier(dev);</span><br><span class="line"></span><br><span class="line">		/*调用class-&gt;shutdown--&gt;bus-&gt;shutdown--&gt;driver-&gt;shutdown*/</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;shutdown) &#123;</span><br><span class="line">			<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">				dev_info(dev, <span class="string">&quot;shutdown\n&quot;</span>);</span><br><span class="line">			dev-&gt;class-&gt;shutdown(dev);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;shutdown) &#123;</span><br><span class="line">			<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">				dev_info(dev, <span class="string">&quot;shutdown\n&quot;</span>);</span><br><span class="line">			dev-&gt;bus-&gt;shutdown(dev);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;driver &amp;&amp; dev-&gt;driver-&gt;shutdown) &#123;</span><br><span class="line">			<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">				dev_info(dev, <span class="string">&quot;shutdown\n&quot;</span>);</span><br><span class="line">			dev-&gt;driver-&gt;shutdown(dev);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		device_unlock(dev);</span><br><span class="line">		<span class="keyword">if</span> (parent)</span><br><span class="line">			device_unlock(parent);</span><br><span class="line"></span><br><span class="line">		put_device(dev);</span><br><span class="line">		put_device(parent);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>machine_restart的实现在具体arch目录下，arch/arm64/kernel/process.c如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Restart requires that the secondary CPUs stop performing any activity</span><br><span class="line"> * <span class="keyword">while</span> the primary CPU resets the system. Systems with multiple CPUs must</span><br><span class="line"> * provide a HW restart implementation, to ensure that all CPUs reset at once.</span><br><span class="line"> * This is required so that any code running after reset on the primary CPU</span><br><span class="line"> * doesn<span class="string">&#x27;t have to co-ordinate with other CPUs to ensure they aren&#x27;</span>t still</span><br><span class="line"> * executing pre-reset code, and using RAM that the primary CPU<span class="string">&#x27;s code wishes</span></span><br><span class="line"><span class="string"> * to use. Implementing such co-ordination would be essentially impossible.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">void machine_restart(char *cmd)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	/* Disable interrupts first */</span></span><br><span class="line"><span class="string">	local_irq_disable();</span></span><br><span class="line"><span class="string">	/* 调用smp_send_stop接口，确保其它CPU处于非活动状态 */</span></span><br><span class="line"><span class="string">	smp_send_stop();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	do_kernel_i2c_restart(cmd);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * UpdateCapsule() depends on the system being reset via</span></span><br><span class="line"><span class="string">	 * ResetSystem().</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (efi_enabled(EFI_RUNTIME_SERVICES))</span></span><br><span class="line"><span class="string">		efi_reboot(reboot_mode, NULL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Now call the architecture specific reboot code. */</span></span><br><span class="line"><span class="string">	if (arm_pm_restart)</span></span><br><span class="line"><span class="string">		arm_pm_restart(reboot_mode, cmd);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		do_kernel_restart(cmd);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Whoops - the architecture was unable to reboot.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	printk(&quot;Reboot failed -- System halted\n&quot;);</span></span><br><span class="line"><span class="string">	while (1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于power_off也是一样的流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *	kernel_power_off - power_off the system</span><br><span class="line"> *</span><br><span class="line"> *	Shutdown everything and perform a clean system power_off.</span><br><span class="line"> */</span><br><span class="line">void kernel_power_off(void)</span><br><span class="line">&#123;</span><br><span class="line">	kernel_shutdown_prepare(SYSTEM_POWER_OFF);</span><br><span class="line">	<span class="keyword">if</span> (pm_power_off_prepare)</span><br><span class="line">		pm_power_off_prepare();</span><br><span class="line">	migrate_to_reboot_cpu();</span><br><span class="line">	syscore_shutdown();</span><br><span class="line">	pr_emerg(<span class="string">&quot;Power down\n&quot;</span>);</span><br><span class="line">	kmsg_dump(KMSG_DUMP_POWEROFF);</span><br><span class="line">	machine_power_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Power Management Interface可以参考<a href="http://www.wowotech.net/pm_subsystem/pm_interface.html">http://www.wowotech.net/pm_subsystem/pm_interface.html</a></p>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><h4 id="sys-power-state"><a href="#sys-power-state" class="headerlink" title="/sys/power/state"></a>/sys/power/state</h4><p>state是sysfs中一个文件，为Generic PM的核心接口，用于将系统置于指定的Power State（供电模式，如Hibernate、Sleep、Standby等）。不同的电源管理功能，在底层的实现，就是在不同Power State之间切换。写入特定的Power State字符串，将会把系统置为该模式。</p>
<h4 id="sys-power-pm-trace"><a href="#sys-power-pm-trace" class="headerlink" title="/sys/power/pm_trace"></a>/sys/power/pm_trace</h4><p>PM Trace用于提供电源管理过程中的Trace记录，由“CONFIG_PM_TRACE”宏定义（kernel/power/Kconfig）控制是否编译进内核，并由“/sys/power/pm_trace”文件在运行时控制是否使能该功能</p>
<h4 id="sys-power-pm-test"><a href="#sys-power-pm-test" class="headerlink" title="/sys/power/pm_test"></a>/sys/power/pm_test</h4><ul>
<li><p>PM test用于对电源管理功能的测试，由“CONFIG_PM_DEBUG”宏定义（kernel/power/Kconfig）控制是否编译进内核。其核心思想是：<br>将电源管理过程按照先后顺序，划分为多个步骤，如core、platform、devices等。这些步骤称作PM Test Level。</p>
</li>
<li><p>系统通过一个全局变量（pm_test_level），保存系统当前的PM Test Level。该变量的值可以通过”/sys/power/pm_test“文件获取及修改。</p>
</li>
<li><p>在每一个电源管理步骤结束后，插入PM test代码，该代码以当前执行步骤为参数，会判断当前的PM Test Level和执行步骤是否一致，如果一致，则说明该步骤执行成功。出于Test考量，执行成功后，系统会打印Test信息，并在等待一段时间后，退出PM过程。</p>
</li>
<li><p>开发人员可以通过修改全局的Test Level，有目的测试所关心的步骤是否执行成功。<br>该文件用于获取及修改PM Test Level</p>
</li>
</ul>
<h4 id="sys-power-wakeup-count"><a href="#sys-power-wakeup-count" class="headerlink" title="/sys/power/wakeup_count"></a>/sys/power/wakeup_count</h4><p>该接口只和Sleep功能有关，因此由“CONFIG_PM_SLEEP”宏定义（kernel/power/Kconfig）控制。它的存在，是为了解决Sleep和Wakeup之间的同步问题。</p>
<p>我们知道，系统睡眠后，可以通过保留的Wakeup source唤醒系统。而在当今的CPU体系中，唤醒系统就是唤醒CPU，而唤醒CPU的唯一途径，就是Wakeup source产生中断（内核称作Wakeup event）。而内核要保证在多种状态下，Sleep/Wakeup的行为都能正常，如下：</p>
<ul>
<li><p>系统处于sleep状态时，产生了Wakeup event。此时应该直接唤醒系统。这一点没有问题。</p>
</li>
<li><p>系统在进入sleep的过程中，产生了Wakeup event。此时应该放弃进入sleep。</p>
</li>
</ul>
<p>这一点就不那么容易做到了。例如，当Wakeup event发生在“/sys/power/state”被写之后、内核执行freeze操作之前。此时用户空间程序依旧可以处理Wakeup event，或者只是部分处理。而内核却以为该Event已经被处理，因此并不会放弃此次sleep动作。</p>
<p>这就会造成，Wakeup event发生后，用户空间程序已经后悔了，不想睡了，但最终还是睡下去了。直到下一个Wakeup event到来。</p>
<p>为了解决上面的问题，内核提供wkaeup_count机制，配合“/sys/power/state”，以实现Sleep过程中的同步。该机制的操作行为如下：</p>
<ul>
<li><p>wakeup_count是内核用来保存当前wakeup event发生的计数。</p>
</li>
<li><p> 用户空间程序在写入state切换状态之前，应先读取wakeup_count并把获得的count写回给wakeup_count。</p>
</li>
<li><p>内核会比对写回的count和当前的count是否一致，如果不一致，说明在读取/写回操作之间，产生了新的的wakeup event，内核就会返回错误。</p>
</li>
<li><p>用户空间程序检测到写入错误之后，不能继续后的动作，需要处理响应的event并伺机再次读取/写回wakeup_count。</p>
</li>
<li><p>如果内核比对一致，会记录write wakeup_count成功时的event快照，后面继续suspend动作时，会检查是否和快照相符，如果不符，会终止suspend。</p>
</li>
<li><p>用户空间程序检测到写入正确后，可以继续对state的写入，以便发起一次状态切换。而此时是安全的。</p>
</li>
</ul>
<h4 id="sys-power-disk"><a href="#sys-power-disk" class="headerlink" title="/sys/power/disk"></a>/sys/power/disk</h4><p>该接口是STD特有的。用于设置或获取STD的类型。当前内核支持的STD类型包括：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1: static const char * const hibernation_modes[] = &#123;</span><br><span class="line">2:         [HIBERNATION_PLATFORM]  = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">3:         [HIBERNATION_SHUTDOWN]  = <span class="string">&quot;shutdown&quot;</span>,</span><br><span class="line">4:         [HIBERNATION_REBOOT]    = <span class="string">&quot;reboot&quot;</span>,</span><br><span class="line">5: <span class="comment">#ifdef CONFIG_SUSPEND</span></span><br><span class="line">6:         [HIBERNATION_SUSPEND]   = <span class="string">&quot;suspend&quot;</span>,</span><br><span class="line">7: <span class="comment">#endif</span></span><br><span class="line">8: &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>platform，表示使用平台特有的机制，处理STD操作，如使用hibernation_ops等。</p>
</li>
<li><p>shutdown，通过关闭系统实现STD，内核会调用kernel_power_off接口。</p>
</li>
<li><p>reboot，通过重启系统实现STD，内核会调用kernel_restart接口。</p>
</li>
<li><p>suspend，利用STR功能，实现STD。该类型下，STD和STR底层的处理逻辑类似。</p>
</li>
</ul>
<h4 id="sys-power-image-size"><a href="#sys-power-image-size" class="headerlink" title="/sys/power/image_size"></a>/sys/power/image_size</h4><p>该接口也是STD特有的。我们知道，STD的原理是将当前的运行上下文保存在系统的disk（如NAND Flash，如硬盘），然后选择合适的方式关闭或重启系统。保存上下文是需要存储空间的，不光是disk中的存储空间，也包括位于内存的用于交换或缓冲的空间。</p>
<p>而该接口，就是设置或者获取当前内存中需要分配多少空间，用于缓冲需要写入到disk的数据。单位为byte。</p>
<h4 id="sys-power-reserverd-size"><a href="#sys-power-reserverd-size" class="headerlink" title="/sys/power/reserverd_size"></a>/sys/power/reserverd_size</h4><p>reserverd_size用于指示预留多少内存空间，用于在-&gt;freeze() 和 -&gt;freeze_noirq()过程中保存设备驱动分配的空间。以免在STD的过程中丢失。</p>
<h4 id="sys-power-resume"><a href="#sys-power-resume" class="headerlink" title="/sys/power/resume"></a>/sys/power/resume</h4><p>该接口也是STD特有的。正常情况下，在重新开机后，内核会在后期的初始化过程中，读取保存在disk中的image，并恢复系统。而该接口，提供了一种在用户空间手动的读取image并恢复系统的方法。</p>
<p>通常情况下，该操作出现在系统正常运行的过程中，需要加载并执行另外的image。</p>
<h4 id="debugfs-suspend-status"><a href="#debugfs-suspend-status" class="headerlink" title="debugfs/suspend_status"></a>debugfs/suspend_status</h4><p>该接口是以debugfs的形式，向用户空间提供suspend过程的统计信息，包括：成功的次数、失败的次数、freeze失败的次数等等。</p>
<h4 id="dev-snapshot"><a href="#dev-snapshot" class="headerlink" title="/dev/snapshot"></a>/dev/snapshot</h4><p>该接口也是STD特有的。它通过字符设备的形式，向用户空间提供software的STD操作。我们会在后续的文章中详细描述。</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>reboot</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-sample</title>
    <url>/2019/09/05/linux-kernel-sample/</url>
    <content><![CDATA[<h3 id="sparrow-dev-c"><a href="#sparrow-dev-c" class="headerlink" title="sparrow_dev.c"></a>sparrow_dev.c</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sparrow_dev.c</span><br><span class="line"> *</span><br><span class="line"> * A demonstation driver using Module <span class="keyword">in</span> Linux kernel</span><br><span class="line"> *</span><br><span class="line"> * Author: wowo&lt;www.wowotech.net&gt;</span><br><span class="line"> *</span><br><span class="line"> * This program is free software; you can redistribute  it and/or modify it</span><br><span class="line"> * under  the terms of  the GNU General  Public License as published by the</span><br><span class="line"> * Free Software Foundation;  either version 2 of the  License, or (at your</span><br><span class="line"> * option) any later version.</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DEVICE_NAME			&quot;sparrow&quot;</span></span><br><span class="line"></span><br><span class="line">static struct platform_device spa_pdev = &#123;</span><br><span class="line">	.name 	= DEVICE_NAME,</span><br><span class="line">	.id 	= -1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init sparrow_dev_init(void) &#123; </span><br><span class="line">	int 		ret;</span><br><span class="line">	printk(<span class="string">&quot;Hello world, this is Sparrow Dev!\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * add spa_pdev to system</span><br><span class="line">	 */</span><br><span class="line">	ret = platform_device_register(&amp;spa_pdev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Can&#x27;t register spa_pdev!\n&quot;</span>); </span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit sparrow_dev_exit(void) &#123; </span><br><span class="line">	/*</span><br><span class="line">	 * there will be a WARNING(drivers/base/core.c, device_release):</span><br><span class="line">	 * Device <span class="string">&#x27;xxx&#x27;</span> does not have a release() <span class="keyword">function</span>,</span><br><span class="line">	 * it is broken and must be fixed,</span><br><span class="line">	 * think it, WHY??</span><br><span class="line">	 */</span><br><span class="line">	platform_device_unregister(&amp;spa_pdev);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Bye world, this is Sparrow Dev!\n&quot;</span>); </span><br><span class="line">	<span class="built_in">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">module_init(sparrow_dev_init);</span><br><span class="line">module_exit(sparrow_dev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="sparrow-drv-c"><a href="#sparrow-drv-c" class="headerlink" title="sparrow_drv.c"></a>sparrow_drv.c</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sparrow_drv.c</span><br><span class="line"> *</span><br><span class="line"> * A demonstation driver using Module <span class="keyword">in</span> Linux kernel</span><br><span class="line"> *</span><br><span class="line"> * Author: wowo&lt;www.wowotech.net&gt;</span><br><span class="line"> *</span><br><span class="line"> * This program is free software; you can redistribute  it and/or modify it</span><br><span class="line"> * under  the terms of  the GNU General  Public License as published by the</span><br><span class="line"> * Free Software Foundation;  either version 2 of the  License, or (at your</span><br><span class="line"> * option) any later version.</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DEVICE_NAME			&quot;sparrow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SPA_DEFAULT_MAJOR 	(111)	/* major device number, if invalid, dynamic alloc it */</span></span><br><span class="line"><span class="comment">#define SPA_NUMS 			(2)		/* device numbers */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* the sparrow char device and its major */</span><br><span class="line">static struct cdev 			spa_cdev;</span><br><span class="line">static unsigned int			spa_major = SPA_DEFAULT_MAJOR;</span><br><span class="line"></span><br><span class="line">/* a short memory used <span class="keyword">for</span> <span class="built_in">read</span>/write demo */</span><br><span class="line"><span class="comment">#define BUF_LEN				(32)</span></span><br><span class="line">static char 				spa_mem[BUF_LEN];</span><br><span class="line"></span><br><span class="line">extern void TS_test_stop(void);</span><br><span class="line">extern int TS_test_start(void);</span><br><span class="line"></span><br><span class="line">static int spa_open(struct inode *inode, struct file *filp) &#123;</span><br><span class="line">	unsigned int major, minor;</span><br><span class="line"></span><br><span class="line">	/* </span><br><span class="line">	 * we can get the major and minor number from filp pointer,</span><br><span class="line">	 * <span class="keyword">if</span> the char device has multiple minors,</span><br><span class="line">	 * we can know <span class="built_in">which</span> one is being operated. </span><br><span class="line">	 */ </span><br><span class="line">	major = imajor(inode);</span><br><span class="line">	minor = iminor(inode);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;%s, major = %d, minor = %d!\n&quot;</span>, __func__, major, minor); </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t spa_read(struct file *filp, char *buf,</span><br><span class="line">						size_t len, loff_t *offset) &#123;</span><br><span class="line">	printk(<span class="string">&quot;%s, len = %d\n&quot;</span>, __func__, len); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filp == NULL || buf == NULL || len == 0) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Params error!\n&quot;</span>); </span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len &gt; BUF_LEN) &#123;</span><br><span class="line">		len = BUF_LEN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* skip the offset variable */</span><br><span class="line">	copy_to_user(buf, spa_mem, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t spa_write(struct file *filp, const char *buf,</span><br><span class="line">						 size_t len, loff_t *offset) &#123;</span><br><span class="line">	printk(<span class="string">&quot;%s, len = %d\n&quot;</span>, __func__, len); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filp == NULL || buf == NULL || len == 0) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Params error!\n&quot;</span>); </span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len &gt; BUF_LEN) &#123;</span><br><span class="line">		len = BUF_LEN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* skip the offset variable */</span><br><span class="line">	copy_from_user(spa_mem, buf, len);</span><br><span class="line"></span><br><span class="line">	/* Thread Synchronization Testing */</span><br><span class="line">	<span class="keyword">if</span> (strcmp(buf, <span class="string">&quot;start\n&quot;</span>) == 0) &#123;</span><br><span class="line">		TS_test_start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strcmp(buf, <span class="string">&quot;stop\n&quot;</span>) == 0) &#123;</span><br><span class="line">		TS_test_stop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int spa_close(struct inode *inode, struct file *filp) &#123;</span><br><span class="line">	printk(<span class="string">&quot;%s\n&quot;</span>, __func__); </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations spa_fops = &#123;</span><br><span class="line">	.open 		= spa_open,</span><br><span class="line">	.<span class="built_in">read</span> 		= spa_read,</span><br><span class="line">	.write 		= spa_write,</span><br><span class="line">	.release 	= spa_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int spa_probe(struct platform_device *pdev) &#123;</span><br><span class="line">	int 		ret;</span><br><span class="line">	dev_t 		devno;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;%s!\n&quot;</span>, __func__); </span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * register device numbers,</span><br><span class="line">	 * static or dynamic according to the init spa_major</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (spa_major &gt; 0) &#123;				/* static register */</span><br><span class="line">		devno 	= MKDEV(spa_major, 0);	/* get the first device number */</span><br><span class="line">		ret 	= register_chrdev_region(devno, SPA_NUMS, DEVICE_NAME);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Can&#x27;t static register chrdev region!\n&quot;</span>);    </span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; 							/* dynamic alloc */</span><br><span class="line">		ret = alloc_chrdev_region(&amp;devno, 0, SPA_NUMS, DEVICE_NAME) ;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">			printk(<span class="string">&quot;Can&#x27;t alloc chrdev region!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* saved the major number */</span><br><span class="line">		spa_major = MAJOR(devno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">     * add the char device to system</span><br><span class="line">     */</span><br><span class="line">	cdev_init(&amp;spa_cdev, &amp;spa_fops);</span><br><span class="line"></span><br><span class="line">	spa_cdev.owner 	= THIS_MODULE;</span><br><span class="line">	spa_cdev.ops	= &amp;spa_fops;</span><br><span class="line"></span><br><span class="line">	ret = cdev_add(&amp;spa_cdev, devno, SPA_NUMS);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Can&#x27;t add char device!\n&quot;</span>);</span><br><span class="line">		unregister_chrdev_region(devno, SPA_NUMS);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int spa_remove(struct platform_device *pdev) &#123;</span><br><span class="line">	printk(<span class="string">&quot;%s!\n&quot;</span>, __func__); </span><br><span class="line"></span><br><span class="line">	/* remove char device and unregister device number */</span><br><span class="line">	cdev_del(&amp;spa_cdev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(spa_major, 0), SPA_NUMS);</span><br><span class="line"></span><br><span class="line">	TS_test_stop();</span><br><span class="line">	<span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct platform_driver spa_pdrv = &#123;</span><br><span class="line">	.driver	= &#123;</span><br><span class="line">		.name 	= DEVICE_NAME,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe 		= spa_probe,</span><br><span class="line">	.remove		= spa_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init sparrow_drv_init(void) &#123; </span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Hello world, this is Sparrow Drv!\n&quot;</span>); </span><br><span class="line"></span><br><span class="line"> 	/*</span><br><span class="line">	 * add spa_pdrv to system</span><br><span class="line">	 */</span><br><span class="line">	ret = platform_driver_register(&amp;spa_pdrv);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Can&#x27;t register spa_pdev!\n&quot;</span>); </span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit sparrow_drv_exit(void) &#123; </span><br><span class="line">	platform_driver_unregister(&amp;spa_pdrv);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Bye world, this is Sparrow Drv!\n&quot;</span>); </span><br><span class="line">	<span class="built_in">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">module_init(sparrow_drv_init);</span><br><span class="line">module_exit(sparrow_drv_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="TS-test-c"><a href="#TS-test-c" class="headerlink" title="TS_test.c"></a>TS_test.c</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * TS_test.c</span><br><span class="line"> *</span><br><span class="line"> * A <span class="built_in">test</span> code <span class="keyword">for</span> Thread Synchronization</span><br><span class="line"> *</span><br><span class="line"> * Author: wowo&lt;www.wowotech.net&gt;</span><br><span class="line"> *</span><br><span class="line"> * This program is free software; you can redistribute  it and/or modify it</span><br><span class="line"> * under  the terms of  the GNU General  Public License as published by the</span><br><span class="line"> * Free Software Foundation;  either version 2 of the  License, or (at your</span><br><span class="line"> * option) any later version.</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/delay.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DELAY1				(1000)	/* ms */</span></span><br><span class="line"><span class="comment">#define DELAY2				(872)	/* ms */</span></span><br><span class="line"><span class="comment">#define DELAY3				(1093)	/* ms */</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * v_s_wr, a variable will be accessed by write and <span class="built_in">read</span></span><br><span class="line"> */</span><br><span class="line">static volatile int			v_s_wr = 0;</span><br><span class="line">/* spinlock is enough */</span><br><span class="line">static						DEFINE_SPINLOCK(s_wr_lock);</span><br><span class="line"></span><br><span class="line">static struct task_struct 	*TS_task1, *TS_task2, *TS_task3;</span><br><span class="line"></span><br><span class="line">/* TS_thread1, add 1 to v_s_wr */</span><br><span class="line">static int TS_thread1(void *data) &#123;</span><br><span class="line">	<span class="keyword">while</span> (1) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s: add 1\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;s_wr_lock);</span><br><span class="line">		v_s_wr++;</span><br><span class="line">		spin_unlock(&amp;s_wr_lock);</span><br><span class="line"></span><br><span class="line">		msleep(DELAY1);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* TS_thread2, <span class="built_in">read</span> and <span class="built_in">print</span> v_s_wr */</span><br><span class="line">static int TS_thread2(void *data) &#123;</span><br><span class="line">	<span class="keyword">while</span> (1) &#123;</span><br><span class="line">		spin_lock(&amp;s_wr_lock);</span><br><span class="line">		printk(<span class="string">&quot;%s: print---%d\n&quot;</span>, __func__, v_s_wr);</span><br><span class="line">		spin_unlock(&amp;s_wr_lock);</span><br><span class="line"></span><br><span class="line">		msleep(DELAY2);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* TS_thread3, dec 1  from v_s_wr */</span><br><span class="line">static int TS_thread3(void *data) &#123;</span><br><span class="line">	<span class="keyword">while</span> (1) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s: dec 1\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;s_wr_lock);</span><br><span class="line">		v_s_wr--;</span><br><span class="line">		spin_unlock(&amp;s_wr_lock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		msleep(DELAY3);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*========================================================================</span><br><span class="line">					The global <span class="built_in">functions</span> provided to others</span><br><span class="line">  =======================================================================*/</span><br><span class="line">void TS_test_stop(void) &#123;</span><br><span class="line">	<span class="keyword">if</span> (TS_task1) &#123;</span><br><span class="line">		kthread_stop(TS_task1);</span><br><span class="line">		TS_task1 = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TS_task2) &#123;</span><br><span class="line">		kthread_stop(TS_task2);</span><br><span class="line">		TS_task2 = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TS_task3) &#123;</span><br><span class="line">		kthread_stop(TS_task3);</span><br><span class="line">		TS_task3 = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int TS_test_start(void) &#123;</span><br><span class="line">	TS_task1 = kthread_create(TS_thread1, NULL, <span class="string">&quot;TS_task1&quot;</span>);</span><br><span class="line">	TS_task2 = kthread_create(TS_thread2, NULL, <span class="string">&quot;TS_task2&quot;</span>);</span><br><span class="line">	TS_task3 = kthread_create(TS_thread3, NULL, <span class="string">&quot;TS_task3&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(TS_task1) || IS_ERR(TS_task2) || IS_ERR(TS_task3)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Unable to start kernel thread.\n&quot;</span>);</span><br><span class="line">		TS_test_stop();</span><br><span class="line">      	<span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	wake_up_process(TS_task1);</span><br><span class="line">	wake_up_process(TS_task2);</span><br><span class="line">	wake_up_process(TS_task3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>sample</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-suspend</title>
    <url>/2020/02/17/linux-kernel-suspend/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Linux内核提供了三种Suspend: Freeze、Standby和STR(Suspend to RAM)，在用户空间向”/sys/power/state”文件分别写入”freeze”、”standby”和”mem”，即可触发它们。<br>在用户空间执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;freeze&quot;</span> &gt; /sys/power/state</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;standby&quot;</span> &gt; /sys/power/state</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mem&quot;</span> &gt; /sys/power/state</span><br></pre></td></tr></table></figure>
<p>会通过sysfs触发suspend的执行，相应的处理代码如下：kernel/power/main.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,</span><br><span class="line">			   const char *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	suspend_state_t state;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	error = pm_autosleep_lock();</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pm_autosleep_state() &gt; PM_SUSPEND_ON) &#123;</span><br><span class="line">		error = -EBUSY;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state = decode_state(buf, n);</span><br><span class="line">	<span class="keyword">if</span> (state &lt; PM_SUSPEND_MAX)</span><br><span class="line">		error = pm_suspend(state);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state == PM_SUSPEND_MAX)</span><br><span class="line">		error = hibernate();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		error = -EINVAL;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	pm_autosleep_unlock();</span><br><span class="line">	<span class="built_in">return</span> error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line">power_attr(state);</span><br></pre></td></tr></table></figure>
<p>power_attr定义了一个名称为state的attribute文件，该文件的store接口为state_store，该接口在lock住autosleep功能后，解析用户传入的buffer（freeze、standby or mem），转换成state参数。<br>state参数的类型为suspend_state_t，在include\linux\suspend.h中定义，为电源管理状态在内核中的表示。具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef int __bitwise suspend_state_t;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#define PM_SUSPEND_ON           ((__force suspend_state_t) 0)</span></span><br><span class="line"><span class="comment">#define PM_SUSPEND_FREEZE       ((__force suspend_state_t) 1)</span></span><br><span class="line"><span class="comment">#define PM_SUSPEND_STANDBY      ((__force suspend_state_t) 2)</span></span><br><span class="line"><span class="comment">#define PM_SUSPEND_MEM          ((__force suspend_state_t) 3)</span></span><br><span class="line"><span class="comment">#define PM_SUSPEND_MIN          PM_SUSPEND_FREEZE</span></span><br><span class="line"><span class="comment">#define PM_SUSPEND_MAX          ((__force suspend_state_t) 4)</span></span><br></pre></td></tr></table></figure>
<p>根据state的值，如果不是（PM_SUSPEND_MAX，对应hibernate功能），则调用pm_suspend接口，进行后续的处理。 </p>
<p>pm_suspend在kernel/power/suspend.c定义，处理所有的suspend过程。  </p>
<h3 id="pm-suspend-amp-enter-state"><a href="#pm-suspend-amp-enter-state" class="headerlink" title="pm_suspend &amp; enter_state"></a>pm_suspend &amp; enter_state</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * pm_suspend - Externally visible <span class="keyword">function</span> <span class="keyword">for</span> suspending the system.</span><br><span class="line"> * @state: System sleep state to enter.</span><br><span class="line"> *</span><br><span class="line"> * Check <span class="keyword">if</span> the value of @state represents one of the supported states,</span><br><span class="line"> * execute enter_state() and update system <span class="built_in">suspend</span> statistics.</span><br><span class="line"> */</span><br><span class="line">int pm_suspend(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (state &lt;= PM_SUSPEND_ON || state &gt;= PM_SUSPEND_MAX)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pm_suspend_marker(<span class="string">&quot;entry&quot;</span>);</span><br><span class="line">	error = enter_state(state);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		suspend_stats.fail++;</span><br><span class="line">		dpm_save_failed_errno(error);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		suspend_stats.success++;</span><br><span class="line">	&#125;</span><br><span class="line">	pm_suspend_marker(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * enter_state - Do common work needed to enter system sleep state.</span><br><span class="line"> * @state: System sleep state to enter.</span><br><span class="line"> *</span><br><span class="line"> * Make sure that no one <span class="keyword">else</span> is trying to put the system into a sleep state.</span><br><span class="line"> * Fail <span class="keyword">if</span> that<span class="string">&#x27;s not the case.  Otherwise, prepare for system suspend, make the</span></span><br><span class="line"><span class="string"> * system enter the given sleep state and clean up after wakeup.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int enter_state(suspend_state_t state)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int error;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;suspend_enter&quot;), state, true);</span></span><br><span class="line"><span class="string">	if (state == PM_SUSPEND_FREEZE) &#123;</span></span><br><span class="line"><span class="string">#ifdef CONFIG_PM_DEBUG</span></span><br><span class="line"><span class="string">		if (pm_test_level != TEST_NONE &amp;&amp; pm_test_level &lt;= TEST_CPUS) &#123;</span></span><br><span class="line"><span class="string">			pr_warning(&quot;PM: Unsupported test mode for suspend to idle,&quot;</span></span><br><span class="line"><span class="string">				   &quot;please choose none/freezer/devices/platform.\n&quot;);</span></span><br><span class="line"><span class="string">			return -EAGAIN;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	// 调用valid_state，判断该平台是否支持该电源状态。suspend的最终目的，是让系统进入可恢复的挂起状态，而该功能必须有平台相关代码的参与才能完成，因此内核PM Core就提供了一系列的回调函数（封装在platform_suspend_ops中），让平台代码（如arch/arm/mach-xxx/pm.c）实现，然后由PM Core在合适的时机调用。这些回调函数包含一个valid函数，就是用来告知PM Core，支持哪些state。</span></span><br><span class="line"><span class="string">	&#125; else if (!valid_state(state)) &#123;</span></span><br><span class="line"><span class="string">		return -EINVAL;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//加互斥锁，只允许一个实例处理suspend</span></span><br><span class="line"><span class="string">	if (!mutex_trylock(&amp;pm_mutex))</span></span><br><span class="line"><span class="string">		return -EBUSY;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//如果state是freeze，调用freeze_begin，进行suspend to freeze相关的特殊动作</span></span><br><span class="line"><span class="string">	if (state == PM_SUSPEND_FREEZE)</span></span><br><span class="line"><span class="string">		freeze_begin();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifndef CONFIG_SUSPEND_SKIP_SYNC</span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;sync_filesystems&quot;), 0, true);</span></span><br><span class="line"><span class="string">	printk(KERN_INFO &quot;PM: Syncing filesystems ... &quot;);</span></span><br><span class="line"><span class="string">	sys_sync();</span></span><br><span class="line"><span class="string">	printk(&quot;done.\n&quot;);</span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;sync_filesystems&quot;), 0, false);</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	pr_debug(&quot;PM: Preparing system for sleep (%s)\n&quot;, pm_states[state]);</span></span><br><span class="line"><span class="string">	pm_suspend_clear_flags();</span></span><br><span class="line"><span class="string">	//调用suspend_prepare，进行suspend前的准备，主要包括switch console和process&amp;thread freezing。如果失败，则终止suspend过程</span></span><br><span class="line"><span class="string">	error = suspend_prepare(state);</span></span><br><span class="line"><span class="string">	if (error)</span></span><br><span class="line"><span class="string">		goto Unlock;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (suspend_test(TEST_FREEZER))</span></span><br><span class="line"><span class="string">		goto Finish;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;suspend_enter&quot;), state, false);</span></span><br><span class="line"><span class="string">	pr_debug(&quot;PM: Suspending system (%s)\n&quot;, pm_states[state]);</span></span><br><span class="line"><span class="string">	pm_restrict_gfp_mask();</span></span><br><span class="line"><span class="string">	//调用suspend_devices_and_enter接口，该接口负责suspend和resume的所有实际动作。前半部分，suspend console、suspend device、关中断、调用平台相关的suspend_ops使系统进入低功耗状态。后半部分，在系统被事件唤醒后，处理相关动作，调用平台相关的suspend_ops恢复系统、开中断、resume device、resume console</span></span><br><span class="line"><span class="string">	error = suspend_devices_and_enter(state);</span></span><br><span class="line"><span class="string">	pm_restore_gfp_mask();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Finish:</span></span><br><span class="line"><span class="string">	pr_debug(&quot;PM: Finishing wakeup.\n&quot;);</span></span><br><span class="line"><span class="string">	//调用suspend_finish，恢复（或等待恢复）process&amp;thread，还原console</span></span><br><span class="line"><span class="string">	suspend_finish();</span></span><br><span class="line"><span class="string"> Unlock:</span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;pm_mutex);</span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * suspend_prepare - Prepare for entering system sleep state.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Common code run for every system sleep state that can be entered (except for</span></span><br><span class="line"><span class="string"> * hibernation).  Run suspend notifiers, allocate the &quot;suspend&quot; console and</span></span><br><span class="line"><span class="string"> * freeze processes.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int suspend_prepare(suspend_state_t state)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int error, nr_calls = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!sleep_state_supported(state))</span></span><br><span class="line"><span class="string">		return -EPERM;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用pm_prepare_console，将当前console切换到一个虚拟console并重定向内核的kmsg（需要的话）。该功能称作VT switch</span></span><br><span class="line"><span class="string">	pm_prepare_console();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用pm_notifier_call_chain，发送suspend开始的消息</span></span><br><span class="line"><span class="string">	error = __pm_notifier_call_chain(PM_SUSPEND_PREPARE, -1, &amp;nr_calls);</span></span><br><span class="line"><span class="string">	if (error) &#123;</span></span><br><span class="line"><span class="string">		nr_calls--;</span></span><br><span class="line"><span class="string">		goto Finish;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;freeze_processes&quot;), 0, true);</span></span><br><span class="line"><span class="string">	//调用suspend_freeze_processes，freeze用户空间进程和一些内核线程</span></span><br><span class="line"><span class="string">	error = suspend_freeze_processes();</span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;freeze_processes&quot;), 0, false);</span></span><br><span class="line"><span class="string">	if (!error)</span></span><br><span class="line"><span class="string">		return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	suspend_stats.failed_freeze++;</span></span><br><span class="line"><span class="string">	dpm_save_failed_step(SUSPEND_FREEZE);</span></span><br><span class="line"><span class="string"> Finish:</span></span><br><span class="line"><span class="string">	__pm_notifier_call_chain(PM_POST_SUSPEND, nr_calls, NULL);</span></span><br><span class="line"><span class="string">	//如果freezing-of-tasks失败，调用pm_restore_console，将console切换回原来的console，并返回错误，以便能终止suspend</span></span><br><span class="line"><span class="string">	pm_restore_console();</span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * suspend_devices_and_enter - Suspend devices and enter system sleep state.</span></span><br><span class="line"><span class="string"> * @state: System sleep state to enter.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">int suspend_devices_and_enter(suspend_state_t state)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int error;</span></span><br><span class="line"><span class="string">	bool wakeup = false;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!sleep_state_supported(state))</span></span><br><span class="line"><span class="string">		return -ENOSYS;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用suspend_ops的begin回调（有的话），通知平台代码，以便让其作相应的处理（需要的话）。可能失败，需要跳至Close处执行恢复操作（suspend_ops-&gt;end）</span></span><br><span class="line"><span class="string">	error = platform_suspend_begin(state);</span></span><br><span class="line"><span class="string">	if (error)</span></span><br><span class="line"><span class="string">		goto Close;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用suspend_console，挂起console。该接口由&quot;kernel\printk.c&quot;实现，主要是hold住一个lock，该lock会阻止其它代码访问console</span></span><br><span class="line"><span class="string">	suspend_console();</span></span><br><span class="line"><span class="string">	suspend_test_start();</span></span><br><span class="line"><span class="string">	//调用dpm_suspend_start，调用所有设备的-&gt;prepare和-&gt;suspend回调函数</span></span><br><span class="line"><span class="string">	error = dpm_suspend_start(PMSG_SUSPEND);</span></span><br><span class="line"><span class="string">	if (error) &#123;</span></span><br><span class="line"><span class="string">		pr_err(&quot;PM: Some devices failed to suspend, or early wake event detected\n&quot;);</span></span><br><span class="line"><span class="string">		log_suspend_abort_reason(&quot;Some devices failed to suspend, or early wake event detected&quot;);</span></span><br><span class="line"><span class="string">		goto Recover_platform;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	suspend_test_finish(&quot;suspend devices&quot;);</span></span><br><span class="line"><span class="string">	if (suspend_test(TEST_DEVICES))</span></span><br><span class="line"><span class="string">		goto Recover_platform;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	do &#123;</span></span><br><span class="line"><span class="string">		//以上都是suspend前的准备工作，此时，调用suspend_enter接口，使系统进入指定的电源状态</span></span><br><span class="line"><span class="string">		error = suspend_enter(state, &amp;wakeup);</span></span><br><span class="line"><span class="string">	&#125; while (!error &amp;&amp; !wakeup &amp;&amp; platform_suspend_again(state));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Resume_devices:</span></span><br><span class="line"><span class="string">	suspend_test_start();</span></span><br><span class="line"><span class="string">	dpm_resume_end(PMSG_RESUME);</span></span><br><span class="line"><span class="string">	suspend_test_finish(&quot;resume devices&quot;);</span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;resume_console&quot;), state, true);</span></span><br><span class="line"><span class="string">	resume_console();</span></span><br><span class="line"><span class="string">	trace_suspend_resume(TPS(&quot;resume_console&quot;), state, false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Close:</span></span><br><span class="line"><span class="string">	platform_resume_end(state);</span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Recover_platform:</span></span><br><span class="line"><span class="string"> 	//suspend需要正常suspend的设备。suspend device可能失败，需要跳至 Recover_platform，执行recover操作（suspend_ops-&gt;recover）</span></span><br><span class="line"><span class="string">	platform_recover(state);</span></span><br><span class="line"><span class="string">	goto Resume_devices;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用suspend_enter</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * suspend_enter - Make the system enter the given sleep state.</span><br><span class="line"> * @state: System sleep state to enter.</span><br><span class="line"> * @wakeup: Returns information that the sleep state should not be re-entered.</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> should be called after devices have been suspended.</span><br><span class="line"> */</span><br><span class="line">static int suspend_enter(suspend_state_t state, bool *wakeup)</span><br><span class="line">&#123;</span><br><span class="line">	char suspend_abort[MAX_SUSPEND_ABORT_LEN];</span><br><span class="line">	int error, last_dev;</span><br><span class="line"></span><br><span class="line">	//调用suspend_ops的prepare回调（有的话），通知平台代码，以便让其在即将进行状态切换之时，再做一些处理（需要的话）。该回调可能失败（平台代码出现意外），失败的话，需要跳至Platform_finish处，调用suspend_ops的finish回调，执行恢复操作</span><br><span class="line">	error = platform_suspend_prepare(state);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto Platform_finish;</span><br><span class="line"></span><br><span class="line">	//调用dpm_suspend_end，调用所有设备的-&gt;suspend_late和-&gt;suspend_noirq回调函数,<span class="built_in">suspend</span> late <span class="built_in">suspend</span>设备和需要在关中断下<span class="built_in">suspend</span>的设备。需要说明的是，这里的noirq，是通过禁止所有的中断线的形式，而不是通过关全局中断的方式。同样，该操作可能会失败，失败的话，跳至Platform_finish处，执行恢复动作</span><br><span class="line">	error = dpm_suspend_late(PMSG_SUSPEND);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		last_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;</span><br><span class="line">		last_dev %= REC_FAILED_NUM;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;PM: late suspend of devices failed\n&quot;</span>);</span><br><span class="line">		log_suspend_abort_reason(<span class="string">&quot;%s device failed to power down&quot;</span>,</span><br><span class="line">			suspend_stats.failed_devs[last_dev]);</span><br><span class="line">		goto Platform_finish;</span><br><span class="line">	&#125;</span><br><span class="line">	//调用suspend_ops的prepare_late回调（有的话），通知平台代码，以便让其在最后关头，再做一些处理（需要的话）。该回调可能失败（平台代码出现意外），失败的话，需要跳至Platform_wake处，调用suspend_ops的wake回调，执行device的resume、调用suspend_ops的finish回调，执行恢复操作</span><br><span class="line">	error = platform_suspend_prepare_late(state);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto Devices_early_resume;</span><br><span class="line"></span><br><span class="line">	error = dpm_suspend_noirq(PMSG_SUSPEND);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		last_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;</span><br><span class="line">		last_dev %= REC_FAILED_NUM;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;PM: noirq suspend of devices failed\n&quot;</span>);</span><br><span class="line">		log_suspend_abort_reason(<span class="string">&quot;noirq suspend of %s device failed&quot;</span>,</span><br><span class="line">			suspend_stats.failed_devs[last_dev]);</span><br><span class="line">		goto Platform_early_resume;</span><br><span class="line">	&#125;</span><br><span class="line">	error = platform_suspend_prepare_noirq(state);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		goto Platform_wake;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (suspend_test(TEST_PLATFORM))</span><br><span class="line">		goto Platform_wake;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * PM_SUSPEND_FREEZE equals</span><br><span class="line">	 * frozen processes + suspended devices + idle processors.</span><br><span class="line">	 * Thus we should invoke freeze_enter() soon after</span><br><span class="line">	 * all the devices are suspended.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (state == PM_SUSPEND_FREEZE) &#123;</span><br><span class="line">		trace_suspend_resume(TPS(<span class="string">&quot;machine_suspend&quot;</span>), state, <span class="literal">true</span>);</span><br><span class="line">		freeze_enter();</span><br><span class="line">		trace_suspend_resume(TPS(<span class="string">&quot;machine_suspend&quot;</span>), state, <span class="literal">false</span>);</span><br><span class="line">		goto Platform_wake;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//调用disable_nonboot_cpus，禁止所有的非boot cpu。也会失败，执行恢复操作即可</span><br><span class="line">	error = disable_nonboot_cpus();</span><br><span class="line">	<span class="keyword">if</span> (error || suspend_test(TEST_CPUS)) &#123;</span><br><span class="line">		log_suspend_abort_reason(<span class="string">&quot;Disabling non-boot cpus failed&quot;</span>);</span><br><span class="line">		goto Enable_cpus;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//调用arch_suspend_disable_irqs，关全局中断</span><br><span class="line">	arch_suspend_disable_irqs();</span><br><span class="line">	BUG_ON(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">	//调用syscore_suspend，<span class="built_in">suspend</span> system core。同样会失败，执行恢复操作即可</span><br><span class="line">	error = syscore_suspend();</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		//如果很幸运，以上操作都成功了，那么，切换吧。不过，别高兴太早，还得调用pm_wakeup_pending检查一下，这段时间内，是否有唤醒事件发生，如果有就要终止<span class="built_in">suspend</span>。</span><br><span class="line">		*wakeup = pm_wakeup_pending();</span><br><span class="line">		<span class="keyword">if</span> (!(suspend_test(TEST_CORE) || *wakeup)) &#123;</span><br><span class="line">			trace_suspend_resume(TPS(<span class="string">&quot;machine_suspend&quot;</span>),</span><br><span class="line">				state, <span class="literal">true</span>);</span><br><span class="line">			//如果一切顺利，调用suspend_ops的enter回调，进行状态切换。这时，系统应该已经<span class="built_in">suspend</span>了……</span><br><span class="line">			error = suspend_ops-&gt;enter(state);</span><br><span class="line">			trace_suspend_resume(TPS(<span class="string">&quot;machine_suspend&quot;</span>),</span><br><span class="line">				state, <span class="literal">false</span>);</span><br><span class="line">			events_check_enabled = <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*wakeup) &#123;</span><br><span class="line">			pm_get_active_wakeup_sources(suspend_abort,</span><br><span class="line">				MAX_SUSPEND_ABORT_LEN);</span><br><span class="line">			log_suspend_abort_reason(suspend_abort);</span><br><span class="line">			error = -EBUSY;</span><br><span class="line">		&#125;</span><br><span class="line">		//<span class="built_in">suspend</span>过程中，唤醒事件发生，系统唤醒，该函数接着执行resume动作，并最终返回。resume动作基本上是<span class="built_in">suspend</span>的反动作</span><br><span class="line">		syscore_resume();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arch_suspend_enable_irqs();</span><br><span class="line">	BUG_ON(irqs_disabled());</span><br><span class="line"></span><br><span class="line"> Enable_cpus:</span><br><span class="line">	enable_nonboot_cpus();</span><br><span class="line"></span><br><span class="line"> Platform_wake:</span><br><span class="line">	platform_resume_noirq(state);</span><br><span class="line">	dpm_resume_noirq(PMSG_RESUME);</span><br><span class="line"></span><br><span class="line"> Platform_early_resume:</span><br><span class="line">	platform_resume_early(state);</span><br><span class="line"></span><br><span class="line"> Devices_early_resume:</span><br><span class="line">	dpm_resume_early(PMSG_RESUME);</span><br><span class="line"></span><br><span class="line"> Platform_finish:</span><br><span class="line">	platform_resume_finish(state);</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口处理完后，会通过返回值告知是否enter成功，同时通过wakeup指针，告知调用者，是否有wakeup事件发生，导致电源状态切换失败</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>suspend</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-syscon</title>
    <url>/2019/09/12/linux-kernel-syscon/</url>
    <content><![CDATA[<p>System controller node represents a register region containing a set<br>of miscellaneous registers. The registers are not cohesive enough to<br>represent as any specific type of device. The typical use-case is for<br>some other node’s driver, or platform-specific code, to acquire a<br>reference to the syscon node (e.g. by phandle, node path, or search<br>using a specific compatible value), interrogate the node (or associated<br>OS driver) to determine the location of the registers, and access the<br>registers directly.</p>
<h3 id="一、Required-properties"><a href="#一、Required-properties" class="headerlink" title="一、Required properties"></a>一、Required properties</h3><ul>
<li>compatible: Should contain “syscon”.</li>
<li>reg: the register region can be accessed from syscon</li>
</ul>
<h3 id="二、Optional-property"><a href="#二、Optional-property" class="headerlink" title="二、Optional property:"></a>二、Optional property:</h3><ul>
<li>reg-io-width: the size (in bytes) of the IO accesses that should be<br>performed on the device.</li>
<li>hwlocks: reference to a phandle of a hardware spinlock provider node.</li>
</ul>
<h3 id="三、Examples"><a href="#三、Examples" class="headerlink" title="三、Examples:"></a>三、Examples:</h3><p>gpr: iomuxc-gpr@20e0000 {<br>    compatible = “fsl,imx6q-iomuxc-gpr”, “syscon”;<br>    reg = &lt;0x020e0000 0x38&gt;;<br>    hwlocks = &lt;&amp;hwlock1 1&gt;;<br>};</p>
<p>hwlock1: hwspinlock@40500000 {<br>    …<br>    reg = &lt;0x40500000 0x1000&gt;;<br>    #hwlock-cells = &lt;1&gt;;<br>};</p>
<h3 id="四、syscon-node-to-regmap"><a href="#四、syscon-node-to-regmap" class="headerlink" title="四、syscon_node_to_regmap"></a>四、syscon_node_to_regmap</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct regmap *syscon_node_to_regmap(struct device_node *np)</span><br><span class="line">&#123;</span><br><span class="line">	struct syscon *entry, *syscon = NULL;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;syscon_list_slock);</span><br><span class="line"></span><br><span class="line">	//遍历syscon_list查找syscon</span><br><span class="line">	list_for_each_entry(entry, &amp;syscon_list, list)</span><br><span class="line">		<span class="keyword">if</span> (entry-&gt;np == np) &#123;</span><br><span class="line">			syscon = entry;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;syscon_list_slock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!syscon)</span><br><span class="line">		syscon = of_syscon_register(np);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(syscon))</span><br><span class="line">		<span class="built_in">return</span> ERR_CAST(syscon);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> syscon-&gt;regmap;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(syscon_node_to_regmap);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static struct syscon *of_syscon_register(struct device_node *np)</span><br><span class="line">&#123;</span><br><span class="line">	struct syscon *syscon;</span><br><span class="line">	struct regmap *regmap;</span><br><span class="line">	void __iomem *base;</span><br><span class="line">	u32 reg_io_width;</span><br><span class="line">	int ret;</span><br><span class="line">	struct regmap_config syscon_config = syscon_regmap_config;</span><br><span class="line">	struct resource res;</span><br><span class="line"></span><br><span class="line">	/* 判断是否有syscon字段*/</span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_compatible(np, <span class="string">&quot;syscon&quot;</span>))</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	/*   //申请空间，调用kzalloc申请的空间自动清零了，免去额外调用memset清零的动作 */</span><br><span class="line">	syscon = kzalloc(sizeof(*syscon), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!syscon)</span><br><span class="line">		<span class="built_in">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	/* 获得resource资源 */</span><br><span class="line">	<span class="keyword">if</span> (of_address_to_resource(np, 0, &amp;res)) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err_map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 /* 对res做虚拟地址的映射 */</span><br><span class="line">	base = ioremap(res.start, resource_size(&amp;res));</span><br><span class="line">	<span class="keyword">if</span> (!base) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err_map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 解析设备树是大端还是小端 */</span><br><span class="line">	/* Parse the device<span class="string">&#x27;s DT node for an endianness specification */</span></span><br><span class="line"><span class="string">	if (of_property_read_bool(np, &quot;big-endian&quot;))</span></span><br><span class="line"><span class="string">		syscon_config.val_format_endian = REGMAP_ENDIAN_BIG;</span></span><br><span class="line"><span class="string">	else if (of_property_read_bool(np, &quot;little-endian&quot;))</span></span><br><span class="line"><span class="string">		syscon_config.val_format_endian = REGMAP_ENDIAN_LITTLE;</span></span><br><span class="line"><span class="string">	else if (of_property_read_bool(np, &quot;native-endian&quot;))</span></span><br><span class="line"><span class="string">		syscon_config.val_format_endian = REGMAP_ENDIAN_NATIVE;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * search for reg-io-width property in DT. If it is not provided,</span></span><br><span class="line"><span class="string">	 * default to 4 bytes. regmap_init_mmio will return an error if values</span></span><br><span class="line"><span class="string">	 * are invalid so there is no need to check them here.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	ret = of_property_read_u32(np, &quot;reg-io-width&quot;, &amp;reg_io_width);</span></span><br><span class="line"><span class="string">	if (ret)</span></span><br><span class="line"><span class="string">		reg_io_width = 4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	ret = of_hwspin_lock_get_id(np, 0);</span></span><br><span class="line"><span class="string">	if (ret &gt; 0 || (IS_ENABLED(CONFIG_HWSPINLOCK) &amp;&amp; ret == 0)) &#123;</span></span><br><span class="line"><span class="string">		syscon_config.use_hwlock = true;</span></span><br><span class="line"><span class="string">		syscon_config.hwlock_id = ret;</span></span><br><span class="line"><span class="string">		syscon_config.hwlock_mode = HWLOCK_IRQSTATE;</span></span><br><span class="line"><span class="string">	&#125; else if (ret &lt; 0) &#123;</span></span><br><span class="line"><span class="string">		switch (ret) &#123;</span></span><br><span class="line"><span class="string">		case -ENOENT:</span></span><br><span class="line"><span class="string">			/* Ignore missing hwlock, it&#x27;</span>s optional. */</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		default:</span><br><span class="line">			pr_err(<span class="string">&quot;Failed to retrieve valid hwlock: %d\n&quot;</span>, ret);</span><br><span class="line">			/* fall-through */</span><br><span class="line">		<span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">			goto err_regmap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	syscon_config.reg_stride = reg_io_width;</span><br><span class="line">	syscon_config.val_bits = reg_io_width * 8;</span><br><span class="line">	syscon_config.max_register = resource_size(&amp;res) - reg_io_width;</span><br><span class="line"></span><br><span class="line">	regmap = regmap_init_mmio(NULL, base, &amp;syscon_config);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(regmap)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;regmap init failed\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(regmap);</span><br><span class="line">		goto err_regmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	syscon-&gt;regmap = regmap;</span><br><span class="line">	syscon-&gt;np = np;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;syscon_list_slock);</span><br><span class="line">	list_add_tail(&amp;syscon-&gt;list, &amp;syscon_list);</span><br><span class="line">	spin_unlock(&amp;syscon_list_slock);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> syscon;</span><br><span class="line"></span><br><span class="line">err_regmap:</span><br><span class="line">	iounmap(base);</span><br><span class="line">err_map:</span><br><span class="line">	kfree(syscon);</span><br><span class="line">	<span class="built_in">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>syscon</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-sysfs</title>
    <url>/2019/09/04/linux-kernel-sysfs/</url>
    <content><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>sysfs是一个基于RAM的文件系统，它和Kobject一起，可以将Kernel的数据结构导出到用户空间，以文件目录结构的形式，提供对这些数据结构（以及数据结构的属性）的访问支持。</p>
<h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct kernfs_node &#123;</span><br><span class="line">	atomic_t		count;</span><br><span class="line">	atomic_t		active;</span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	struct lockdep_map	dep_map;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	/*</span><br><span class="line">	 * Use kernfs_get_parent() and kernfs_name/path() instead of</span><br><span class="line">	 * accessing the following two fields directly.  If the node is</span><br><span class="line">	 * never moved to a different parent, it is safe to access the</span><br><span class="line">	 * parent directly.</span><br><span class="line">	 */</span><br><span class="line">	struct kernfs_node	*parent;</span><br><span class="line">	const char		*name;</span><br><span class="line"></span><br><span class="line">	struct rb_node		rb;</span><br><span class="line"></span><br><span class="line">	const void		*ns;	/* namespace tag */</span><br><span class="line">	unsigned int		<span class="built_in">hash</span>;	/* ns + name <span class="built_in">hash</span> */</span><br><span class="line">	union &#123;</span><br><span class="line">		struct kernfs_elem_dir		dir;</span><br><span class="line">		struct kernfs_elem_symlink	symlink;</span><br><span class="line">		struct kernfs_elem_attr		attr;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	void			*priv; //指向kobject</span><br><span class="line"></span><br><span class="line">	union kernfs_node_id	id;</span><br><span class="line">	unsigned short		flags;</span><br><span class="line">	umode_t			mode;</span><br><span class="line">	struct kernfs_iattrs	*iattr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个数据结构的priv和kobject，kset里的成员相联系。</p>
<h3 id="三、目录"><a href="#三、目录" class="headerlink" title="三、目录"></a>三、目录</h3><p>每一个Kobject，都会对应sysfs中的一个目录。因此在将Kobject添加到Kernel时，create_dir接口会调用sysfs文件系统的创建目录接口，创建和Kobject对应的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 如果kobj的父级已启用命名空间操作，则返回其命名空间标记，kobj应该有一个与之相关联的名称空间标记。 */</span><br><span class="line">const void *kobject_namespace(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ns_ops || ns_ops-&gt;<span class="built_in">type</span> == KOBJ_NS_TYPE_NONE)</span><br><span class="line">		<span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> kobj-&gt;ktype-&gt;namespace(kobj);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">static int create_dir(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	const struct kobj_ns_type_operations *ops;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	/* 以kobject_namespace(kobj)为namespace tag创建一个目录，该目录与parenr通过namespace tag相关联 */</span><br><span class="line">	error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = populate_dir(kobj); //用属性填充目录，创建属性文件</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		sysfs_remove_dir(kobj);</span><br><span class="line">		<span class="built_in">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * @kobj-&gt;sd may be deleted by an ancestor going away.  Hold an</span><br><span class="line">	 * extra reference so that it stays until @kobj is gone.</span><br><span class="line">	 */</span><br><span class="line">	sysfs_get(kobj-&gt;sd);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If @kobj has ns_ops, its children need to be filtered based on</span><br><span class="line">	 * their namespace tags.  Enable namespace support on @kobj-&gt;sd.</span><br><span class="line">	 */</span><br><span class="line">	ops = kobj_child_ns_ops(kobj);</span><br><span class="line">	<span class="keyword">if</span> (ops) &#123;</span><br><span class="line">		BUG_ON(ops-&gt;<span class="built_in">type</span> &lt;= KOBJ_NS_TYPE_NONE);</span><br><span class="line">		BUG_ON(ops-&gt;<span class="built_in">type</span> &gt;= KOBJ_NS_TYPES);</span><br><span class="line">		BUG_ON(!kobj_ns_type_registered(ops-&gt;<span class="built_in">type</span>));</span><br><span class="line"></span><br><span class="line">		sysfs_enable_ns(kobj-&gt;sd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sysfs_create_dir_ns和populate_dir</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 为kobj创建一个带有namespace tag的目录 */</span><br><span class="line">int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)</span><br><span class="line">&#123;</span><br><span class="line">	struct kernfs_node *parent, *kn;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!kobj);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kobj-&gt;parent)</span><br><span class="line">		parent = kobj-&gt;parent-&gt;sd;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		parent = sysfs_root_kn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!parent)</span><br><span class="line">		<span class="built_in">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">	kn = kernfs_create_dir_ns(parent, kobject_name(kobj),</span><br><span class="line">				  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns); //创建目录</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(kn)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(kn) == -EEXIST)</span><br><span class="line">			sysfs_warn_dup(parent, kobject_name(kobj)); </span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(kn);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kobj-&gt;sd = kn;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/* 在sysfs中，为什么会有attribute的概念呢？其实它是对应kobject而言的，指的是kobject的“属性”。我们知道，</span><br><span class="line">sysfs中的目录描述了kobject，而kobject是特定数据类型变量（如struct device）的体现。因此kobject的属性，就是这些变量的属性。它可以是任何东西，名称、一个内部变量、一个字符串等等。而attribute，在sysfs文件系统中是以文件的形式提供的，即：kobject的所有属性，都在它对应的sysfs目录下以文件的形式呈现。这些文件一般是可读、写的，而kernel中定义了这些属性的模块，会根据用户空间的读写操作，记录和返回这些attribute的值。所谓的attibute，就是内核空间和用户空间进行信息交互的一种方法。例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，以控制driver的运行行为，那么就可以将该变量以sysfs attribute的形式开放出来。*/</span><br><span class="line">static int populate_dir(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	struct kobj_type *t = get_ktype(kobj);</span><br><span class="line">	struct attribute *attr;</span><br><span class="line">	int error = 0;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t &amp;&amp; t-&gt;default_attrs) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = 0; (attr = t-&gt;default_attrs[i]) != NULL; i++) &#123;</span><br><span class="line">			error = sysfs_create_file(kobj, attr);</span><br><span class="line">			<span class="keyword">if</span> (error)</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、属性文件"><a href="#四、属性文件" class="headerlink" title="四、属性文件"></a>四、属性文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct attribute &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	umode_t			mode;</span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	bool			ignore_lockdep:1;</span><br><span class="line">	struct lock_class_key	*key;</span><br><span class="line">	struct lock_class_key	skey;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">struct attribute_group &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	umode_t			(*is_visible)(struct kobject *,</span><br><span class="line">					      struct attribute *, int);</span><br><span class="line">	umode_t			(*is_bin_visible)(struct kobject *,</span><br><span class="line">						  struct bin_attribute *, int);</span><br><span class="line">	struct attribute	**attrs;</span><br><span class="line">	struct bin_attribute	**bin_attrs;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">struct bin_attribute &#123;</span><br><span class="line">	struct attribute	attr;</span><br><span class="line">	size_t			size;</span><br><span class="line">	void			*private;</span><br><span class="line">	ssize_t (*<span class="built_in">read</span>)(struct file *, struct kobject *, struct bin_attribute *,</span><br><span class="line">			char *, loff_t, size_t);</span><br><span class="line">	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *,</span><br><span class="line">			 char *, loff_t, size_t);</span><br><span class="line">	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,</span><br><span class="line">		    struct vm_area_struct *vma);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct attribute为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写。而struct bin_attribute在struct attribute的基础上，增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写。sysfs_create_file最终调用sysfs_add_file_mode_ns函数，该函数内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static const struct kernfs_ops sysfs_prealloc_kfops_rw = &#123;</span><br><span class="line">	.<span class="built_in">read</span>		= sysfs_kf_read,</span><br><span class="line">	.write		= sysfs_kf_write,</span><br><span class="line">	.prealloc	= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">int sysfs_add_file_mode_ns(struct kernfs_node *parent,</span><br><span class="line">			   const struct attribute *attr, bool is_bin,</span><br><span class="line">			   umode_t mode, const void *ns)</span><br><span class="line">&#123;</span><br><span class="line">	struct lock_class_key *key = NULL;</span><br><span class="line">	const struct kernfs_ops *ops;</span><br><span class="line">	struct kernfs_node *kn;</span><br><span class="line">	loff_t size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_bin) &#123; //如果不是bin文件</span><br><span class="line">		struct kobject *kobj = parent-&gt;priv;</span><br><span class="line">		const struct sysfs_ops *sysfs_ops = kobj-&gt;ktype-&gt;sysfs_ops;//通过kobj的ktype获得sysfs_ops</span><br><span class="line"></span><br><span class="line">		/* every kobject with an attribute needs a ktype assigned */</span><br><span class="line">		<span class="keyword">if</span> (WARN(!sysfs_ops, KERN_ERR</span><br><span class="line">			 <span class="string">&quot;missing sysfs attribute operations for kobject: %s\n&quot;</span>,</span><br><span class="line">			 kobject_name(kobj)))</span><br><span class="line">			<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		/* 根据模式对文件分别设置操作接口 */</span><br><span class="line">		<span class="keyword">if</span> (sysfs_ops-&gt;show &amp;&amp; sysfs_ops-&gt;store) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mode &amp; SYSFS_PREALLOC)</span><br><span class="line">				ops = &amp;sysfs_prealloc_kfops_rw; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ops = &amp;sysfs_file_kfops_rw;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sysfs_ops-&gt;show) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mode &amp; SYSFS_PREALLOC)</span><br><span class="line">				ops = &amp;sysfs_prealloc_kfops_ro;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ops = &amp;sysfs_file_kfops_ro;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sysfs_ops-&gt;store) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mode &amp; SYSFS_PREALLOC)</span><br><span class="line">				ops = &amp;sysfs_prealloc_kfops_wo;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ops = &amp;sysfs_file_kfops_wo;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			ops = &amp;sysfs_file_kfops_empty;</span><br><span class="line"></span><br><span class="line">		size = PAGE_SIZE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct bin_attribute *battr = (void *)attr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (battr-&gt;mmap)</span><br><span class="line">			ops = &amp;sysfs_bin_kfops_mmap;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (battr-&gt;<span class="built_in">read</span> &amp;&amp; battr-&gt;write)</span><br><span class="line">			ops = &amp;sysfs_bin_kfops_rw;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (battr-&gt;<span class="built_in">read</span>)</span><br><span class="line">			ops = &amp;sysfs_bin_kfops_ro;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (battr-&gt;write)</span><br><span class="line">			ops = &amp;sysfs_bin_kfops_wo;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ops = &amp;sysfs_file_kfops_empty;</span><br><span class="line"></span><br><span class="line">		size = battr-&gt;size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="keyword">if</span> (!attr-&gt;ignore_lockdep)</span><br><span class="line">		key = attr-&gt;key ?: (struct lock_class_key *)&amp;attr-&gt;skey;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	kn = __kernfs_create_file(parent, attr-&gt;name, mode &amp; 0777, size, ops,</span><br><span class="line">				  (void *)attr, ns, key);//创建文件</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(kn)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(kn) == -EEXIST)</span><br><span class="line">			sysfs_warn_dup(parent, attr-&gt;name);</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(kn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下read函数的处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 获得kobject-&gt;ktype */</span><br><span class="line">static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)</span><br><span class="line">&#123;</span><br><span class="line">	struct kobject *kobj = kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kn-&gt;flags &amp; KERNFS_LOCKDEP)</span><br><span class="line">		lockdep_assert_held(kn);</span><br><span class="line">	<span class="built_in">return</span> kobj-&gt;ktype ? kobj-&gt;ktype-&gt;sysfs_ops : NULL;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/* sysfs_ops 定义 */</span><br><span class="line">struct sysfs_ops &#123;</span><br><span class="line">	ssize_t	(*show)(struct kobject *, struct attribute *, char *);</span><br><span class="line">	ssize_t	(*store)(struct kobject *, struct attribute *, const char *, size_t);</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">/* kernfs <span class="built_in">read</span> callback <span class="keyword">for</span> regular sysfs files with pre-alloc */</span><br><span class="line">static ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,</span><br><span class="line">			     size_t count, loff_t pos)</span><br><span class="line">&#123;</span><br><span class="line">	const struct sysfs_ops *ops = sysfs_file_ops(of-&gt;kn); /* 获得kobject-&gt;ktype */</span><br><span class="line">	struct kobject *kobj = of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line">	ssize_t len;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If buf != of-&gt;prealloc_buf, we don<span class="string">&#x27;t know how</span></span><br><span class="line"><span class="string">	 * large it is, so cannot safely pass it to -&gt;show</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (WARN_ON_ONCE(buf != of-&gt;prealloc_buf))</span></span><br><span class="line"><span class="string">		return 0;</span></span><br><span class="line"><span class="string">	len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf); //调用driver的show函数</span></span><br><span class="line"><span class="string">	if (len &lt; 0)</span></span><br><span class="line"><span class="string">		return len;</span></span><br><span class="line"><span class="string">	if (pos) &#123;</span></span><br><span class="line"><span class="string">		if (len &lt;= pos)</span></span><br><span class="line"><span class="string">			return 0;</span></span><br><span class="line"><span class="string">		len -= pos;</span></span><br><span class="line"><span class="string">		memmove(buf, buf + pos, len);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return min_t(ssize_t, count, len);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用ops-&gt;show就是具体driver实现的了,这样device在需要使用attribute的时候自己定义结构图并实现show和store来，再填充到ktype-&gt;sysfs_ops就实现里attribute的使用了。这样实现了在sysfs文件系统里读写attribute来操作具体driver数据。</p>
<h3 id="五、sysfs目录结构"><a href="#五、sysfs目录结构" class="headerlink" title="五、sysfs目录结构"></a>五、sysfs目录结构</h3><p>The top level sysfs directory looks like:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">block/ </span><br><span class="line">bus/ </span><br><span class="line">class/ </span><br><span class="line">dev/ </span><br><span class="line">devices/ </span><br><span class="line">firmware/ </span><br><span class="line">net/ </span><br><span class="line">fs/</span><br></pre></td></tr></table></figure>
<p>devices/ contains a filesystem representation of the device tree. It maps directly to the internal kernel device tree, which is a hierarchy of struct device. </p>
<p>bus/ contains flat directory layout of the various bus types in the kernel. Each bus’s directory contains two subdirectories:<br>    devices/<br>    drivers/</p>
<p>devices/ contains symlinks for each device discovered in the system that point to the device’s directory under root/.</p>
<p>drivers/ contains a directory for each device driver that is loaded for devices on that particular bus (this assumes that drivers do not span multiple bus types).</p>
<p>fs/ contains a directory for some filesystems.  Currently each filesystem wanting to export attributes must create its own hierarchy below fs/ (see ./fuse.txt for an example).</p>
<p>dev/ contains two directories char/ and block/. Inside these two directories there are symlinks named <major>:<minor>.  These symlinks point to the sysfs directory for the given device.  /sys/dev provides a quick way to lookup the sysfs interface for a device from the result of a stat(2) operation.</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>sysfs</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-uevent</title>
    <url>/2019/09/04/linux-kernel-uevent/</url>
    <content><![CDATA[<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。用户空间程序收到这样的事件后，会做相应的处理。</p>
<p>该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建/dev/目录下的设备节点，更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum kobject_action &#123;</span><br><span class="line">	KOBJ_ADD,</span><br><span class="line">	KOBJ_REMOVE,//Kobject（或上层数据结构）的添加/移除事件</span><br><span class="line">	KOBJ_CHANGE, //Kobject（或上层数据结构）的状态或者内容发生改变</span><br><span class="line">	KOBJ_MOVE, //Kobject（或上层数据结构）更改名称或者更改Parent,意味着在sysfs中更改了目录结构。</span><br><span class="line">	KOBJ_ONLINE,</span><br><span class="line">	KOBJ_OFFLINE,//Kobject（或上层数据结构）的上线/下线事件，其实是是否使能。</span><br><span class="line">	KOBJ_BIND,</span><br><span class="line">	KOBJ_UNBIND,</span><br><span class="line">	KOBJ_MAX</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define UEVENT_HELPER_PATH_LEN		256</span></span><br><span class="line"><span class="comment">#define UEVENT_NUM_ENVP			32	/* number of env pointers */</span></span><br><span class="line"><span class="comment">#define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */</span></span><br><span class="line">...</span><br><span class="line">struct kobj_uevent_env &#123;</span><br><span class="line">	char *argv[3];</span><br><span class="line">	char *envp[UEVENT_NUM_ENVP];//指针数组，用于保存每个环境变量的地址，最多可支持的环境变量数量为UEVENT_NUM_ENVP。</span><br><span class="line">	int envp_idx; //用于访问环境变量指针数组的index。</span><br><span class="line">	char buf[UEVENT_BUFFER_SIZE];//保存环境变量的buffer，最大为UEVENT_BUFFER_SIZE</span><br><span class="line">	int buflen;//访问buf的变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct kset_uevent_ops &#123;</span><br><span class="line">	int (* const filter)(struct kset *kset, struct kobject *kobj); //当任何Kobject需要上报uevent时，它所属的kset可以通过该接口过滤，阻止不希望上报的event，从而达到从整体上管理的目的。</span><br><span class="line">	const char *(* const name)(struct kset *kset, struct kobject *kobj);//该接口可以返回kset的名称。如果一个kset没有合法的名称，则其下的所有Kobject将不允许上报uvent</span><br><span class="line">	int (* const uevent)(struct kset *kset, struct kobject *kobj,</span><br><span class="line">		      struct kobj_uevent_env *env);//当任何Kobject需要上报uevent时，它所属的kset可以通过该接口统一为这些event添加环境变量。因为很多时候上报uevent时的环境变量都是相同的，因此可以由kset统一处理，就不需要让每个Kobject独自添加了。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li>kobject_uevent<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int kobject_uevent(struct kobject *kobj, enum kobject_action action)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> kobject_uevent_env(kobj, action, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>kobject_uevent_env<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*以envp为环境变量，上报一个指定action的uevent。环境变量的作用是为执行用户空间程序指定运行环境*/</span><br><span class="line">int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,</span><br><span class="line">		       char *envp_ext[])</span><br><span class="line">&#123;</span><br><span class="line">	struct kobj_uevent_env *env;</span><br><span class="line">	const char *action_string = kobject_actions[action];</span><br><span class="line">	const char *devpath = NULL;</span><br><span class="line">	const char *subsystem;</span><br><span class="line">	struct kobject *top_kobj;</span><br><span class="line">	struct kset *kset;</span><br><span class="line">	const struct kset_uevent_ops *uevent_ops;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int retval = 0;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s\n&quot;</span>,</span><br><span class="line">		 kobject_name(kobj), kobj, __func__);</span><br><span class="line"></span><br><span class="line">	/* search the kset we belong to */</span><br><span class="line">	/* 查找kobj本身或者其parent是否从属于某个kset */</span><br><span class="line">	top_kobj = kobj;</span><br><span class="line">	<span class="keyword">while</span> (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent) </span><br><span class="line">		top_kobj = top_kobj-&gt;parent;</span><br><span class="line"></span><br><span class="line">	/* kobj不属于某个kset，则报错返回（如果一个kobject没有加入kset，是不允许上报uevent的）*/</span><br><span class="line">	<span class="keyword">if</span> (!top_kobj-&gt;kset) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: attempted to send uevent &quot;</span></span><br><span class="line">			 <span class="string">&quot;without kset!\n&quot;</span>, kobject_name(kobj), kobj,</span><br><span class="line">			 __func__);</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kset = top_kobj-&gt;kset;</span><br><span class="line">	uevent_ops = kset-&gt;uevent_ops;</span><br><span class="line"></span><br><span class="line">	/* skip the event, <span class="keyword">if</span> uevent_suppress is <span class="built_in">set</span>*/</span><br><span class="line">	/* 查看kobj-&gt;uevent_suppress是否设置，如果设置，则忽略所有的uevent上报并返回（注3：由此可知，可以通过Kobject的uevent_suppress标志，管控Kobject的uevent的上报）*/</span><br><span class="line">	<span class="keyword">if</span> (kobj-&gt;uevent_suppress) &#123; </span><br><span class="line">		pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: uevent_suppress &quot;</span></span><br><span class="line">				 <span class="string">&quot;caused the event to drop!\n&quot;</span>,</span><br><span class="line">				 kobject_name(kobj), kobj, __func__);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line">	/* skip the event, <span class="keyword">if</span> the filter returns zero. */</span><br><span class="line">	/* 如果所属的kset有uevent_ops-&gt;filter函数，则调用该函数，过滤此次上报（注4：这佐证了3.2小节有关filter接口的说明，kset可以通过filter接口过滤不希望上报的event，从而达到整体的管理效果） */</span><br><span class="line">	<span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;filter)</span><br><span class="line">		<span class="keyword">if</span> (!uevent_ops-&gt;filter(kset, kobj)) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: filter function &quot;</span></span><br><span class="line">				 <span class="string">&quot;caused the event to drop!\n&quot;</span>,</span><br><span class="line">				 kobject_name(kobj), kobj, __func__);</span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	/* originating subsystem */</span><br><span class="line">	/* 判断所属的kset是否有合法的名称，否则不允许上报uevent */	</span><br><span class="line">	<span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;name)</span><br><span class="line">		subsystem = uevent_ops-&gt;name(kset, kobj);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		subsystem = kobject_name(&amp;kset-&gt;kobj);</span><br><span class="line">	<span class="keyword">if</span> (!subsystem) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: unset subsystem caused the &quot;</span></span><br><span class="line">			 <span class="string">&quot;event to drop!\n&quot;</span>, kobject_name(kobj), kobj,</span><br><span class="line">			 __func__);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* environment buffer */</span><br><span class="line">	/* 分配一个用于此次上报的、存储环境变量的buffer（结果保存在env指针中） */</span><br><span class="line">	env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!env)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	/* complete object path */</span><br><span class="line">	/* 并获得该Kobject在sysfs中路径信息（用户空间软件需要依据该路径信息在sysfs中访问它） */</span><br><span class="line">	devpath = kobject_get_path(kobj, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!devpath) &#123;</span><br><span class="line">		retval = -ENOENT;</span><br><span class="line">		goto <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* default keys */</span><br><span class="line">	/* 调用add_uevent_var接口，将Action、路径信息、subsystem等信息，添加到env指针中 */</span><br><span class="line">	retval = add_uevent_var(env, <span class="string">&quot;ACTION=%s&quot;</span>, action_string);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto <span class="built_in">exit</span>;</span><br><span class="line">	retval = add_uevent_var(env, <span class="string">&quot;DEVPATH=%s&quot;</span>, devpath);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto <span class="built_in">exit</span>;</span><br><span class="line">	retval = add_uevent_var(env, <span class="string">&quot;SUBSYSTEM=%s&quot;</span>, subsystem);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		goto <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">	/* keys passed <span class="keyword">in</span> from the <span class="built_in">caller</span> */</span><br><span class="line">	/* 如果传入的envp不空，则解析传入的环境变量中，同样调用add_uevent_var接口，添加到env指针中 */</span><br><span class="line">	<span class="keyword">if</span> (envp_ext) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = 0; envp_ext[i]; i++) &#123;</span><br><span class="line">			retval = add_uevent_var(env, <span class="string">&quot;%s&quot;</span>, envp_ext[i]);</span><br><span class="line">			<span class="keyword">if</span> (retval)</span><br><span class="line">				goto <span class="built_in">exit</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* <span class="built_in">let</span> the kset specific <span class="keyword">function</span> add its stuff */</span><br><span class="line">	/* 如果所属的kset存在uevent_ops-&gt;uevent接口，调用该接口，添加kset统一的环境变量到env指针 */</span><br><span class="line">	<span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;uevent) &#123;</span><br><span class="line">		retval = uevent_ops-&gt;uevent(kset, kobj, env);</span><br><span class="line">		<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: uevent() returned &quot;</span></span><br><span class="line">				 <span class="string">&quot;%d\n&quot;</span>, kobject_name(kobj), kobj,</span><br><span class="line">				 __func__, retval);</span><br><span class="line">			goto <span class="built_in">exit</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 根据ACTION的类型，设置kobj-&gt;state_add_uevent_sent和kobj-&gt;state_remove_uevent_sent变量，以记录正确的状态 */</span><br><span class="line">	switch (action) &#123;</span><br><span class="line">	<span class="keyword">case</span> KOBJ_ADD:</span><br><span class="line">		/*</span><br><span class="line">		 * Mark <span class="string">&quot;add&quot;</span> event so we can make sure we deliver <span class="string">&quot;remove&quot;</span></span><br><span class="line">		 * event to userspace during automatic cleanup. If</span><br><span class="line">		 * the object did send an <span class="string">&quot;add&quot;</span> event, <span class="string">&quot;remove&quot;</span> will</span><br><span class="line">		 * automatically generated by the core, <span class="keyword">if</span> not already <span class="keyword">done</span></span><br><span class="line">		 * by the <span class="built_in">caller</span>.</span><br><span class="line">		 */</span><br><span class="line">		kobj-&gt;state_add_uevent_sent = 1;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> KOBJ_REMOVE:</span><br><span class="line">		kobj-&gt;state_remove_uevent_sent = 1;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> KOBJ_UNBIND:</span><br><span class="line">		zap_modalias_env(env);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;uevent_sock_mutex);</span><br><span class="line">	/* we will send an event, so request a new sequence number */</span><br><span class="line">	/* 调用add_uevent_var接口，添加格式为<span class="string">&quot;SEQNUM=%llu&quot;</span>的序列号 */</span><br><span class="line">	retval = add_uevent_var(env, <span class="string">&quot;SEQNUM=%llu&quot;</span>, (unsigned long long)++uevent_seqnum);</span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		mutex_unlock(&amp;uevent_sock_mutex);</span><br><span class="line">		goto <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	/* 使用netlink发送该uevent */</span><br><span class="line">	retval = kobject_uevent_net_broadcast(kobj, env, action_string,</span><br><span class="line">					      devpath);</span><br><span class="line">	mutex_unlock(&amp;uevent_sock_mutex);</span><br><span class="line"></span><br><span class="line">	/* 以uevent_helper、subsystem以及添加了标准环境变量（HOME=/，PATH=/sbin:/bin:/usr/sbin:/usr/bin）的env指针为参数，调用kmod模块提供的call_usermodehelper函数，上报uevent。 </span><br><span class="line">其中uevent_helper的内容是由内核配置项CONFIG_UEVENT_HELPER_PATH(位于./drivers/base/Kconfig)决定的(可参考lib/kobject_uevent.c, line 32)，该配置项指定了一个用户空间程序（或者脚本），用于解析上报的uevent，例如<span class="string">&quot;/sbin/hotplug&quot;</span>。 </span><br><span class="line">call_usermodehelper的作用，就是fork一个进程，以uevent为参数，执行uevent_helper。 */</span><br><span class="line"><span class="comment">#ifdef CONFIG_UEVENT_HELPER</span></span><br><span class="line">	/* call uevent_helper, usually only enabled during early boot */</span><br><span class="line">	<span class="keyword">if</span> (uevent_helper[0] &amp;&amp; !kobj_usermode_filter(kobj)) &#123;</span><br><span class="line">		struct subprocess_info *info;</span><br><span class="line"></span><br><span class="line">		retval = add_uevent_var(env, <span class="string">&quot;HOME=/&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			goto <span class="built_in">exit</span>;</span><br><span class="line">		retval = add_uevent_var(env,</span><br><span class="line">					<span class="string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			goto <span class="built_in">exit</span>;</span><br><span class="line">		retval = init_uevent_argv(env, subsystem);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			goto <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		info = call_usermodehelper_setup(env-&gt;argv[0], env-&gt;argv,</span><br><span class="line">						 env-&gt;envp, GFP_KERNEL,</span><br><span class="line">						 NULL, cleanup_uevent_env, env);</span><br><span class="line">		<span class="keyword">if</span> (info) &#123;</span><br><span class="line">			retval = call_usermodehelper_exec(info, UMH_NO_WAIT);</span><br><span class="line">			env = NULL;	/* freed by cleanup_uevent_env */</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	kfree(devpath);</span><br><span class="line">	kfree(env);</span><br><span class="line">	<span class="built_in">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kobject_uevent_env);</span><br></pre></td></tr></table></figure></li>
<li>add_uevent_var<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 以格式化字符的形式（类似<span class="built_in">printf</span>、printk等），将环境变量copy到env指针中。 */</span><br><span class="line">int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	int len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;envp_idx &gt;= ARRAY_SIZE(env-&gt;envp)) &#123;</span><br><span class="line">		WARN(1, KERN_ERR <span class="string">&quot;add_uevent_var: too many keys\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va_start(args, format);</span><br><span class="line">	len = vsnprintf(&amp;env-&gt;buf[env-&gt;buflen],</span><br><span class="line">			sizeof(env-&gt;buf) - env-&gt;buflen,</span><br><span class="line">			format, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len &gt;= (sizeof(env-&gt;buf) - env-&gt;buflen)) &#123;</span><br><span class="line">		WARN(1, KERN_ERR <span class="string">&quot;add_uevent_var: buffer size too small\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	env-&gt;envp[env-&gt;envp_idx++] = &amp;env-&gt;buf[env-&gt;buflen];</span><br><span class="line">	env-&gt;buflen += len + 1;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(add_uevent_var);</span><br></pre></td></tr></table></figure></li>
<li>kobject_action_type<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* the strings here must match the enum <span class="keyword">in</span> include/linux/kobject.h */</span><br><span class="line">static const char *kobject_actions[] = &#123;</span><br><span class="line">	[KOBJ_ADD] =		<span class="string">&quot;add&quot;</span>,</span><br><span class="line">	[KOBJ_REMOVE] =		<span class="string">&quot;remove&quot;</span>,</span><br><span class="line">	[KOBJ_CHANGE] =		<span class="string">&quot;change&quot;</span>,</span><br><span class="line">	[KOBJ_MOVE] =		<span class="string">&quot;move&quot;</span>,</span><br><span class="line">	[KOBJ_ONLINE] =		<span class="string">&quot;online&quot;</span>,</span><br><span class="line">	[KOBJ_OFFLINE] =	<span class="string">&quot;offline&quot;</span>,</span><br><span class="line">	[KOBJ_BIND] =		<span class="string">&quot;bind&quot;</span>,</span><br><span class="line">	[KOBJ_UNBIND] =		<span class="string">&quot;unbind&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">/* 将enum kobject_action类型的Action，转换为字符串 */</span><br><span class="line">static int kobject_action_type(const char *buf, size_t count,</span><br><span class="line">			       enum kobject_action *<span class="built_in">type</span>,</span><br><span class="line">			       const char **args)</span><br><span class="line">&#123;</span><br><span class="line">	enum kobject_action action;</span><br><span class="line">	size_t count_first;</span><br><span class="line">	const char *args_start;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &amp;&amp; (buf[count-1] == <span class="string">&#x27;\n&#x27;</span> || buf[count-1] == <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">		count--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	args_start = strnchr(buf, count, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (args_start) &#123;</span><br><span class="line">		count_first = args_start - buf;</span><br><span class="line">		args_start = args_start + 1;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		count_first = count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (action = 0; action &lt; ARRAY_SIZE(kobject_actions); action++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (strncmp(kobject_actions[action], buf, count_first) != 0)</span><br><span class="line">			<span class="built_in">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (kobject_actions[action][count_first] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">			<span class="built_in">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (args)</span><br><span class="line">			*args = args_start;</span><br><span class="line">		*<span class="built_in">type</span> = action;</span><br><span class="line">		ret = 0;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>call_usermodehelper_setup<br>通过call_usermodehelper函数，调用用户空间的可执行文件（或者脚本，简称uevent helper ）处理该event。而该uevent helper的路径保存在uevent_helper数组中。 </li>
</ul>
<p>可以在编译内核时，通过CONFIG_UEVENT_HELPER_PATH配置项，静态指定uevent helper。但这种方式会为每个event fork一个进程，随着内核支持的设备数量的增多，这种方式在系统启动时将会是致命的（可以导致内存溢出等）。因此只有在早期的内核版本中会使用这种方式，现在内核不再推荐使用该方式。因此内核编译时，需要把该配置项留空。 </p>
<p>在系统启动后，大部分的设备已经ready，可以根据需要，重新指定一个uevent helper，以便检测系统运行过程中的热拔插事件。这可以通过把helper的路径写入到”/sys/kernel/uevent_helper”文件中实现。实际上，内核通过sysfs文件系统的形式，将uevent_helper数组开放到用户空间，供用户空间程序修改访问，具体可参考”./kernel/ksysfs.c”中相应的代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 创建内核线程 */</span><br><span class="line">static void call_usermodehelper_exec_work(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	struct subprocess_info *sub_info =</span><br><span class="line">		container_of(work, struct subprocess_info, work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sub_info-&gt;<span class="built_in">wait</span> &amp; UMH_WAIT_PROC) &#123;</span><br><span class="line">		call_usermodehelper_exec_sync(sub_info);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pid_t pid;</span><br><span class="line">		/*</span><br><span class="line">		 * Use CLONE_PARENT to reparent it to kthreadd; we <span class="keyword">do</span> not</span><br><span class="line">		 * want to pollute current-&gt;children, and we need a parent</span><br><span class="line">		 * that always ignores SIGCHLD to ensure auto-reaping.</span><br><span class="line">		 */</span><br><span class="line">		pid = kernel_thread(call_usermodehelper_exec_async, sub_info,</span><br><span class="line">				    CLONE_PARENT | SIGCHLD);</span><br><span class="line">		<span class="keyword">if</span> (pid &lt; 0) &#123;</span><br><span class="line">			sub_info-&gt;retval = pid;</span><br><span class="line">			umh_complete(sub_info);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,</span><br><span class="line">		char **envp, gfp_t gfp_mask,</span><br><span class="line">		int (*init)(struct subprocess_info *info, struct cred *new),</span><br><span class="line">		void (*cleanup)(struct subprocess_info *info),</span><br><span class="line">		void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct subprocess_info *sub_info;</span><br><span class="line">	sub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask); //分配子进程结构体</span><br><span class="line">	<span class="keyword">if</span> (!sub_info)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	INIT_WORK(&amp;sub_info-&gt;work, call_usermodehelper_exec_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_STATIC_USERMODEHELPER</span></span><br><span class="line">	sub_info-&gt;path = CONFIG_STATIC_USERMODEHELPER_PATH;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	sub_info-&gt;path = path;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	sub_info-&gt;argv = argv;</span><br><span class="line">	sub_info-&gt;envp = envp;</span><br><span class="line"></span><br><span class="line">	sub_info-&gt;cleanup = cleanup;</span><br><span class="line">	sub_info-&gt;init = init;</span><br><span class="line">	sub_info-&gt;data = data;</span><br><span class="line">  out:</span><br><span class="line">	<span class="built_in">return</span> sub_info;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_usermodehelper_setup);</span><br></pre></td></tr></table></figure>
<ul>
<li>call_usermodehelper_exec<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int call_usermodehelper_exec(struct subprocess_info *sub_info, int <span class="built_in">wait</span>)</span><br><span class="line">&#123;</span><br><span class="line">	DECLARE_COMPLETION_ONSTACK(<span class="keyword">done</span>);</span><br><span class="line">	int retval = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sub_info-&gt;path) &#123;</span><br><span class="line">		call_usermodehelper_freeinfo(sub_info);</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	helper_lock();</span><br><span class="line">	<span class="keyword">if</span> (usermodehelper_disabled) &#123;</span><br><span class="line">		retval = -EBUSY;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If there is no binary <span class="keyword">for</span> us to call, <span class="keyword">then</span> just <span class="built_in">return</span> and get out of</span><br><span class="line">	 * here.  This allows us to <span class="built_in">set</span> STATIC_USERMODEHELPER_PATH to <span class="string">&quot;&quot;</span> and</span><br><span class="line">	 * <span class="built_in">disable</span> all call_usermodehelper() calls.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (strlen(sub_info-&gt;path) == 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set the completion pointer only <span class="keyword">if</span> there is a waiter.</span><br><span class="line">	 * This makes it possible to use umh_complete to free</span><br><span class="line">	 * the data structure <span class="keyword">in</span> <span class="keyword">case</span> of UMH_NO_WAIT.</span><br><span class="line">	 */</span><br><span class="line">	sub_info-&gt;complete = (<span class="built_in">wait</span> == UMH_NO_WAIT) ? NULL : &amp;<span class="keyword">done</span>;</span><br><span class="line">	sub_info-&gt;<span class="built_in">wait</span> = <span class="built_in">wait</span>;</span><br><span class="line"></span><br><span class="line">	queue_work(system_unbound_wq, &amp;sub_info-&gt;work);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">wait</span> == UMH_NO_WAIT)	/* task has freed sub_info */</span><br><span class="line">		goto unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">wait</span> &amp; UMH_KILLABLE) &#123;</span><br><span class="line">		retval = wait_for_completion_killable(&amp;<span class="keyword">done</span>);</span><br><span class="line">		<span class="keyword">if</span> (!retval)</span><br><span class="line">			goto wait_done;</span><br><span class="line"></span><br><span class="line">		/* umh_complete() will see NULL and free sub_info */</span><br><span class="line">		<span class="keyword">if</span> (xchg(&amp;sub_info-&gt;complete, NULL))</span><br><span class="line">			goto unlock;</span><br><span class="line">		/* fallthrough, umh_complete() was already called */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wait_for_completion(&amp;<span class="keyword">done</span>);</span><br><span class="line">wait_done:</span><br><span class="line">	retval = sub_info-&gt;retval;</span><br><span class="line">out:</span><br><span class="line">	call_usermodehelper_freeinfo(sub_info);</span><br><span class="line">unlock:</span><br><span class="line">	helper_unlock();</span><br><span class="line">	<span class="built_in">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_usermodehelper_exec);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>uevent</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-wakelock</title>
    <url>/2020/02/17/linux-kernel-wakelock/</url>
    <content><![CDATA[<h3 id="Android-wakelocks"><a href="#Android-wakelocks" class="headerlink" title="Android wakelocks"></a>Android wakelocks</h3><p>Android wakelocks提供的功能包括：</p>
<p>1）一个sysfs文件：/sys/power/wake_lock，用户程序向文件写入一个字符串，即可创建一个wakelock，该字符串就是wakelock的名字。该wakelock可以阻止系统进入低功耗模式。</p>
<p>2）一个sysfs文件：：/sys/power/wake_unlock，用户程序向文件写入相同的字符串，即可注销一个wakelock。</p>
<p>3）当系统中所有的wakelock都注销后，系统可以自动进入低功耗状态。</p>
<p>4）向内核其它driver也提供了wakelock的创建和注销接口，允许driver创建wakelock以阻止睡眠、注销wakelock以允许睡眠。</p>
<h3 id="Kernel-wakelocks"><a href="#Kernel-wakelocks" class="headerlink" title="Kernel wakelocks"></a>Kernel wakelocks</h3><p>对比Android wakelocks要实现的功能，Linux kernel的方案是：</p>
<p>1）允许driver创建wakelock以阻止睡眠、注销wakelock以允许睡眠：已经由“Linux电源管理(7)_Wakeup events framework”所描述的wakeup source取代。</p>
<p>2）当系统中所有的wakelock都注销后，系统可以自动进入低功耗状态：由autosleep实现（下一篇文章会分析）。</p>
<p>3）wake_lock和wake_unlock功能：由本文所描述的kernel wakelocks实现，其本质就是将wakeup source开发到用户空间访问。</p>
<p>相比Android wakelocks，Kernel wakelocks的实现非常简单（简单的才是最好的），就是在PM core中增加一个wakelock模块（kernel/power/wakelock.c），该模块依赖wakeup events framework提供的wakeup source机制，实现用户空间的wakeup source（就是wakelocks），并通过PM core main模块，向用户空间提供两个同名的sysfs文件，wake_lock和wake_unlock。</p>
<h3 id="sys-power-wake-lock-amp-sys-power-wake-unlock"><a href="#sys-power-wake-lock-amp-sys-power-wake-unlock" class="headerlink" title="/sys/power/wake_lock &amp; /sys/power/wake_unlock"></a>/sys/power/wake_lock &amp; /sys/power/wake_unlock</h3><p>从字面意思上，新版的wake_lock和wake_unlock和旧版的一样，都是用于创建和注销wakelock。从应用开发者的角度，确实可以这样理解。但从底层实现的角度，却完全不是一回事。</p>
<p>Android的wakelock，真是一个lock，用户程序创建一个wakelock，就是在系统suspend的路径上加了一把锁，注销就是解开这把锁。直到suspend路径上所有的锁都解开时，系统才可以suspend。</p>
<p>而Kernel的wakelock，是基于wakeup source实现的，因此创建wakelock的本质是在指定的wakeup source上activate一个wakeup event，注销wakelock的本质是deactivate wakeup event。因此，/sys/power/wake_lock和/sys/power/wake_unlock两个sysfs文件的的功能就是：</p>
<p>写wake_lock（以wakelock name和timeout时间&lt;可选&gt;为参数），相当于以wakeup source为参数调用__pm_stay_awake（或者__pm_wakeup_event），即activate wakeup event；</p>
<p>写wake_unlock（以wakelock name为参数），相当于以wakeup source为参数，调用__pm_relax；</p>
<p>读wake_lock，获取系统中所有的处于active状态的wakelock列表（也即wakeup source列表）</p>
<p>读wake_unlock，返回系统中所有的处于非active状态的wakelock信息（也即wakeup source列表）。</p>
<p>实现如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static ssize_t wake_lock_show(struct kobject *kobj,</span><br><span class="line">			      struct kobj_attribute *attr,</span><br><span class="line">			      char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> pm_show_wakelocks(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t wake_lock_store(struct kobject *kobj,</span><br><span class="line">			       struct kobj_attribute *attr,</span><br><span class="line">			       const char *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	int error = pm_wake_lock(buf);</span><br><span class="line">	<span class="built_in">return</span> error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">power_attr(wake_lock);</span><br><span class="line">...</span><br><span class="line">ssize_t pm_show_wakelocks(char *buf, bool show_active)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node *node;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line">	char *str = buf;</span><br><span class="line">	char *end = buf + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wakelocks_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (node = rb_first(&amp;wakelocks_tree); node; node = rb_next(node)) &#123;</span><br><span class="line">		wl = rb_entry(node, struct wakelock, node);</span><br><span class="line">		<span class="keyword">if</span> (wl-&gt;ws.active == show_active)</span><br><span class="line">			str += scnprintf(str, end - str, <span class="string">&quot;%s &quot;</span>, wl-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (str &gt; buf)</span><br><span class="line">		str--;</span><br><span class="line"></span><br><span class="line">	str += scnprintf(str, end - str, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wakelocks_lock);</span><br><span class="line">	<span class="built_in">return</span> (str - buf);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">int pm_wake_lock(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	const char *str = buf;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line">	u64 timeout_ns = 0;</span><br><span class="line">	size_t len;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	//调用capable，检查当前进程是否具备阻止系统<span class="built_in">suspend</span>的权限</span><br><span class="line">	<span class="keyword">if</span> (!capable(CAP_BLOCK_SUSPEND))</span><br><span class="line">		<span class="built_in">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	//解析字符串，将timeout值（有的话）保存在timeout_ns中，解析name长度（len），并将name保存在原来的buf中</span><br><span class="line">	<span class="keyword">while</span> (*str &amp;&amp; !isspace(*str))</span><br><span class="line">		str++;</span><br><span class="line"></span><br><span class="line">	len = str - buf;</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str &amp;&amp; *str != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">		/* Find out <span class="keyword">if</span> there<span class="string">&#x27;s a valid timeout string appended. */</span></span><br><span class="line"><span class="string">		ret = kstrtou64(skip_spaces(str), 10, &amp;timeout_ns);</span></span><br><span class="line"><span class="string">		if (ret)</span></span><br><span class="line"><span class="string">			return -EINVAL;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	mutex_lock(&amp;wakelocks_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用wakelock_lookup_add接口，查找是否有相同name的wakelock。如果有，直接返回wakelock的指针；如果没有，分配一个wakelock，同时调用wakeup events framework提供的接口，创建该wakelock对应的wakeup source结构</span></span><br><span class="line"><span class="string">	wl = wakelock_lookup_add(buf, len, true);</span></span><br><span class="line"><span class="string">	if (IS_ERR(wl)) &#123;</span></span><br><span class="line"><span class="string">		ret = PTR_ERR(wl);</span></span><br><span class="line"><span class="string">		goto out;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//如果指定timeout值，以wakelock的wakeup source指针为参数，调用__pm_wakeup_event接口，上报一个具有时限的wakeup events；否则，调用__pm_stay_awake，上报一个没有时限的wakeup event</span></span><br><span class="line"><span class="string">	if (timeout_ns) &#123;</span></span><br><span class="line"><span class="string">		u64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		do_div(timeout_ms, NSEC_PER_MSEC);</span></span><br><span class="line"><span class="string">		__pm_wakeup_event(&amp;wl-&gt;ws, timeout_ms);</span></span><br><span class="line"><span class="string">	&#125; else &#123;</span></span><br><span class="line"><span class="string">		__pm_stay_awake(&amp;wl-&gt;ws);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	wakelocks_lru_most_recent(wl);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> out:</span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;wakelocks_lock);</span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">/*维护一个名称为wakelocks_tree的红黑树（红黑树都用上了，可以想象wakelocks曾经使用多么频繁！），所有的wakelock都保存在该tree上。因此该接口的动作是：*/</span></span><br><span class="line"><span class="string">static struct wakelock *wakelock_lookup_add(const char *name, size_t len,</span></span><br><span class="line"><span class="string">					    bool add_if_not_found)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	struct rb_node **node = &amp;wakelocks_tree.rb_node;</span></span><br><span class="line"><span class="string">	struct rb_node *parent = *node;</span></span><br><span class="line"><span class="string">	struct wakelock *wl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	while (*node) &#123;</span></span><br><span class="line"><span class="string">		int diff;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		parent = *node;</span></span><br><span class="line"><span class="string">		//查找红黑树，如果找到name相同的wakelock，返回wakelock指针</span></span><br><span class="line"><span class="string">		wl = rb_entry(*node, struct wakelock, node);</span></span><br><span class="line"><span class="string">		diff = strncmp(name, wl-&gt;name, len);</span></span><br><span class="line"><span class="string">		if (diff == 0) &#123;</span></span><br><span class="line"><span class="string">			if (wl-&gt;name[len])</span></span><br><span class="line"><span class="string">				diff = -1;</span></span><br><span class="line"><span class="string">			else</span></span><br><span class="line"><span class="string">				return wl;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		if (diff &lt; 0)</span></span><br><span class="line"><span class="string">			node = &amp;(*node)-&gt;rb_left;</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			node = &amp;(*node)-&gt;rb_right;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//如果没找到，且add_if_not_found为false，返回错误</span></span><br><span class="line"><span class="string">	if (!add_if_not_found)</span></span><br><span class="line"><span class="string">		return ERR_PTR(-EINVAL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (wakelocks_limit_exceeded())</span></span><br><span class="line"><span class="string">		return ERR_PTR(-ENOSPC);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//如果add_if_not_found为true，分配一个struct wakelock变量，并初始化它的名称、它的wakeup source的名称。调用wakeup_source_add接口，将wakeup source添加到wakeup events framework中。</span></span><br><span class="line"><span class="string">	/* Not found, we have to add a new one. */</span></span><br><span class="line"><span class="string">	wl = kzalloc(sizeof(*wl), GFP_KERNEL);</span></span><br><span class="line"><span class="string">	if (!wl)</span></span><br><span class="line"><span class="string">		return ERR_PTR(-ENOMEM);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	wl-&gt;name = kstrndup(name, len, GFP_KERNEL);</span></span><br><span class="line"><span class="string">	if (!wl-&gt;name) &#123;</span></span><br><span class="line"><span class="string">		kfree(wl);</span></span><br><span class="line"><span class="string">		return ERR_PTR(-ENOMEM);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	wl-&gt;ws.name = wl-&gt;name;</span></span><br><span class="line"><span class="string">	wakeup_source_add(&amp;wl-&gt;ws);</span></span><br><span class="line"><span class="string">	//将该wakelock添加到红黑树</span></span><br><span class="line"><span class="string">	rb_link_node(&amp;wl-&gt;node, parent, node);</span></span><br><span class="line"><span class="string">	rb_insert_color(&amp;wl-&gt;node, &amp;wakelocks_tree);</span></span><br><span class="line"><span class="string">	//最后调用wakelocks_lru_add接口，将新分配的wakeup添加到一个名称为wakelocks_lru_list的链表前端</span></span><br><span class="line"><span class="string">	wakelocks_lru_add(wl);</span></span><br><span class="line"><span class="string">	increment_wakelocks_number();</span></span><br><span class="line"><span class="string">	return wl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>1）wakelocks功能不是linux kernel的必选功能，可以通过CONFIG_PM_WAKELOCKS开关。</p>
<p>2）wake_lock的写接口，直接调用pm_wake_lock；wake_unlock的写接口，直接调用pm_wake_unlock；它们的读接口，直接调用pm_show_wakelocks接口（参数不同）。这三个接口均在kernel/power/wakelock.c中实现。</p>
<h3 id="pm-wake-unlock"><a href="#pm-wake-unlock" class="headerlink" title="pm_wake_unlock"></a>pm_wake_unlock</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int pm_wake_unlock(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	//输入参数为一个字符串，如<span class="string">&quot;wake_lock_test”，该字符串指定一个wakelock name。</span></span><br><span class="line"><span class="string">	struct wakelock *wl;</span></span><br><span class="line"><span class="string">	size_t len;</span></span><br><span class="line"><span class="string">	int ret = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用capable，检查当前进程是否具备阻止系统suspend的权限</span></span><br><span class="line"><span class="string">	if (!capable(CAP_BLOCK_SUSPEND))</span></span><br><span class="line"><span class="string">		return -EPERM;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//解析字符串</span></span><br><span class="line"><span class="string">	len = strlen(buf);</span></span><br><span class="line"><span class="string">	if (!len)</span></span><br><span class="line"><span class="string">		return -EINVAL;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (buf[len-1] == &#x27;\n&#x27;)</span></span><br><span class="line"><span class="string">		len--;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!len)</span></span><br><span class="line"><span class="string">		return -EINVAL;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	mutex_lock(&amp;wakelocks_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用wakelock_lookup_add接口，查找是否有相同name的wakelock。如果有，直接返回wakelock的指针；如果没有，退出</span></span><br><span class="line"><span class="string">	wl = wakelock_lookup_add(buf, len, false);</span></span><br><span class="line"><span class="string">	if (IS_ERR(wl)) &#123;</span></span><br><span class="line"><span class="string">		ret = PTR_ERR(wl);</span></span><br><span class="line"><span class="string">		goto out;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//调用__pm_relax接口，deactive wakelock对应的wakeup source</span></span><br><span class="line"><span class="string">	__pm_relax(&amp;wl-&gt;ws);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//调用wakelocks_lru_most_recent接口，将盖wakelock移到wakelocks_lru_list链表的前端</span></span><br><span class="line"><span class="string">	wakelocks_lru_most_recent(wl);</span></span><br><span class="line"><span class="string">	//调用wakelocks_gc，执行wakelock的垃圾回收动作</span></span><br><span class="line"><span class="string">	wakelocks_gc();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> out:</span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;wakelocks_lock);</span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="pm-show-wakelocks"><a href="#pm-show-wakelocks" class="headerlink" title="pm_show_wakelocks"></a>pm_show_wakelocks</h4><p>该接口很简单，查询红黑树，返回处于acvtive或者deactive状态的wakelock，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssize_t pm_show_wakelocks(char *buf, bool show_active)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node *node;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line">	char *str = buf;</span><br><span class="line">	char *end = buf + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wakelocks_lock);</span><br><span class="line"></span><br><span class="line">	//遍历红黑树，拿到wakelock指针，判断其中的wakeup <span class="built_in">source</span>的active变量，如果和输入变量（show_active)相符，将该wakelock的名字添加在buf中</span><br><span class="line">	<span class="keyword">for</span> (node = rb_first(&amp;wakelocks_tree); node; node = rb_next(node)) &#123;</span><br><span class="line">		wl = rb_entry(node, struct wakelock, node);</span><br><span class="line">		<span class="keyword">if</span> (wl-&gt;ws.active == show_active)</span><br><span class="line">			str += scnprintf(str, end - str, <span class="string">&quot;%s &quot;</span>, wl-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	//调整buf的长度和结束符，返回长度值</span><br><span class="line">	<span class="keyword">if</span> (str &gt; buf)</span><br><span class="line">		str--;</span><br><span class="line"></span><br><span class="line">	str += scnprintf(str, end - str, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wakelocks_lock);</span><br><span class="line">	<span class="built_in">return</span> (str - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wakelocks的垃圾回收机制"><a href="#wakelocks的垃圾回收机制" class="headerlink" title="wakelocks的垃圾回收机制"></a>wakelocks的垃圾回收机制</h4><p>由上面的逻辑可知，一个wakelock的生命周期，应只存在于wakeup event的avtive时期内，因此如果它的wakeup source状态为deactive，应该销毁该wakelock。但销毁后，如果又产生wakeup events，就得重新建立。如果这种建立-&gt;销毁-&gt;建立的过程太频繁，效率就会降低。</p>
<p>因此，最好不销毁，保留系统所有的wakelocks（同时可以完整的保留wakelock信息），但如果wakelocks太多（特别是不活动的），将会占用很多内存，也不合理。</p>
<p>折衷方案，保留一些非active状态的wakelock，到一定的时机时，再销毁，这就是wakelocks的垃圾回收（GC）机制。</p>
<p>wakelocks GC功能可以开关（由CONFIG_PM_WAKELOCKS_GC控制），如果关闭，系统会保留所有的wakelocks，如果打开，它的处理逻辑也很简单：<br>1）定义一个list head，保存所有的wakelock指针，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1: static LIST_HEAD(wakelocks_lru_list);</span><br><span class="line">2: static unsigned int wakelocks_gc_count;</span><br></pre></td></tr></table></figure>
<p>2）在wakelock结构中，嵌入一个list head（lru），用于挂入wakelocks_lru_list。</p>
<p>3）wakelocks_lru_list中的wakelock是按访问顺序排列的，最近访问的，靠近head位置。这是由3种操作保证的：<br>a）wakelock创建时），调用wakelocks_lru_add接口，将改wakelock挂到wakelocks_lru_list的head处（利用list_add接口），表示它是最近被访问的。</p>
<p>b）pm_wake_lock或者pm_wake_unlock时，调用wakelocks_lru_most_recent接口，将该wakelcok移到链表的head处，表示最近访问。</p>
<p>c）每当pm_wake_unlock时，调用wakelocks_gc，执行wakelock的垃圾回收动作。wakelocks_gc的实现如下：</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>wakelock</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-wakeup</title>
    <url>/2020/02/17/linux-kernel-wakeup/</url>
    <content><![CDATA[<h3 id="wakeup-events-framework概述"><a href="#wakeup-events-framework概述" class="headerlink" title="wakeup events framework概述"></a>wakeup events framework概述</h3><p>我们知道，系统处于suspend状态，可通过wakeup events唤醒。具体的wakeup events可以是按键按下，可以是充电器插入，等等。但是，如果在suspend的过程中，产生了wakeup events，怎么办？答案很肯定，”wakeup”系统。由于此时系统没有真正suspend，所以这的”wakeup”是个假动作，实际上只是终止suspend。</p>
<p>但由于系统在suspend的过程中，会进行process freeze、 device suspend等操作，而这些操作可能导致内核或用户空间程序不能及时获取wakeup events，从而使系统不能正确wakeup，这就是wakeup events framework要解决的问题：system suspend和system wakeup events之间的同步问题。</p>
<p>一、内核空间的同步<br>wakeup events产生后，通常是以中断的形式通知device driver。driver会处理events，处理的过程中，系统不能suspend。</p>
<p>二、用户空间的同步<br>一般情况下，driver对wakeup events处理后，会交给用户空间程序继续处理，处理的过程，也不允许suspend。这又可以分为两种情况：</p>
<p>1）进行后续处理的用户进程，根本没有机会被调度，即该wakeup events无法上报到用户空间。</p>
<p>2）进行后续处理的用户进程被调度，处理的过程中（以及处理结束后，决定终止suspend操作），系统不能suspend。<br>因此，wakeup events framework就包括3大功能：<br>解决内核空间同步问题（framework的核心功能）；</p>
<p>解决用户空间同步问题的情景1（wakeup count功能）；</p>
<p>解决用户空间同步问题的情景2（wake lock功能） 。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>wakeup source和wakeup event<br>在kernel中，可以唤醒系统的只有设备(struct device)，但并不是每个设备都具备唤醒功能，那些具有唤醒功能的设备称作wakeup source。struct device结构涉及到一个struct dev_pm_info类型的power变量，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct device &#123;</span><br><span class="line">         ...</span><br><span class="line">         struct dev_pm_info      power;</span><br><span class="line">         ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 该结构中有一个power变量，保存了和wakeup event相关的信息，让我们接着看一下struct dev_pm_info数据结构<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct dev_pm_info &#123;</span><br><span class="line">         ...</span><br><span class="line">         unsigned int            can_wakeup:1;</span><br><span class="line">         ...</span><br><span class="line"> <span class="comment">#ifdef CONFIG_PM_SLEEP</span></span><br><span class="line">         ...</span><br><span class="line">         struct wakeup_source    *wakeup;</span><br><span class="line">         ...</span><br><span class="line"> <span class="comment">#else</span></span><br><span class="line">         unsigned int            should_wakeup:1;</span><br><span class="line"> <span class="comment">#endif</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><br> can_wakeup，标识本设备是否具有唤醒能力。只有具备唤醒能力的设备，才会在sysfs中有一个power目录，用于提供所有的wakeup信息，这些信息是以struct wakeup_source的形式组织起来的。也就是上面wakeup指针。具体有哪些信息呢？让我们看看struct wakeup_source的定义。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* include\linux\pm_wakeup.h */</span><br><span class="line">struct wakeup_source &#123;</span><br><span class="line">        const char              *name;  //该wakeup <span class="built_in">source</span>的名称，一般为对应的device name</span><br><span class="line">        struct list_head        entry;//用于将所有的wakeup <span class="built_in">source</span>挂在一个链表中</span><br><span class="line">        spinlock_t              lock;</span><br><span class="line">        struct timer_list       timer;</span><br><span class="line">        unsigned long           timer_expires; //timer、timer_expires，一个wakeup <span class="built_in">source</span>产生了wakeup event，称作wakeup <span class="built_in">source</span> activate，wakeup event处理完毕后（不再需要系统为此保持active），称作deactivate。activate和deactivate的操作可以由driver亲自设置，也可以在activate时，指定一个timeout时间，时间到达后，由wakeup events framework自动将其设置为deactivate状态。这里的timer以及expires时间，就是用来实现该功能</span><br><span class="line">        ktime_t total_time; //，该wakeup <span class="built_in">source</span>处于activate状态的总时间（可以指示该wakeup <span class="built_in">source</span>对应的设备的繁忙程度、耗电等级）；</span><br><span class="line">        ktime_t max_time; //该wakeup <span class="built_in">source</span>持续处于activate状态的最大时间（越长越不合理）</span><br><span class="line">        ktime_t last_time; //该wakeup <span class="built_in">source</span>上次active的开始时间</span><br><span class="line">        ktime_t start_prevent_time; //该wakeup <span class="built_in">source</span>开始阻止系统自动睡眠（auto sleep）的时间点</span><br><span class="line">        ktime_t prevent_sleep_time; //该wakeup <span class="built_in">source</span>阻止系统自动睡眠的总时间</span><br><span class="line">        unsigned long           event_count; //wakeup <span class="built_in">source</span>上报的event个数</span><br><span class="line">        unsigned long           active_count; //wakeup <span class="built_in">source</span> activate的次数</span><br><span class="line">        unsigned long           relax_count; // wakeup <span class="built_in">source</span> deactivate的次数</span><br><span class="line">        unsigned long           expire_count; //wakeup <span class="built_in">source</span> timeout到达的次数</span><br><span class="line">        unsigned long           wakeup_count; //wakeup <span class="built_in">source</span>终止<span class="built_in">suspend</span>过程的次数</span><br><span class="line">        bool                    active:1; //wakeup <span class="built_in">source</span>的activate状态</span><br><span class="line">        bool                    autosleep_enabled:1; //记录系统auto sleep的使能状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br> 一个wakeup source代表了一个具有唤醒能力的设备，也称该设备为一个wakeup source。该结构中各个字段的意义如下：</p>
<p>wakeup source代表一个具有唤醒能力的设备，该设备产生的可以唤醒系统的事件，就称作wakeup event。当wakeup source产生wakeup event时，需要将wakeup source切换为activate状态；当wakeup event处理完毕后，要切换为deactivate状态。因此，我们再来理解一下几个wakeup source比较混淆的变量：event_count, active_count和wakeup_count：</p>
<h3 id="wakeup-events-framework的核心功能"><a href="#wakeup-events-framework的核心功能" class="headerlink" title="wakeup events framework的核心功能"></a>wakeup events framework的核心功能</h3><p>wakeup events framework的核心功能体现在它向底层的设备驱动所提供的用于上报wakeup event的接口，这些接口根据操作对象可分为两类，具体如下。</p>
<p>类型一（操作对象为wakeup source，编写设备驱动时，一般不会直接使用）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* include/linux/pm_wakeup.h */</span><br><span class="line">extern void __pm_stay_awake(struct wakeup_source *ws);</span><br><span class="line">extern void __pm_relax(struct wakeup_source *ws);</span><br><span class="line">extern void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec);</span><br></pre></td></tr></table></figure>
<p>__pm_stay_awake，通知PM core，ws产生了wakeup event，且正在处理，因此不允许系统suspend（stay awake）；<br>__pm_relax，通知PM core，ws没有正在处理的wakeup event，允许系统suspend（relax）；<br>__pm_wakeup_event，为上边两个接口的功能组合，通知PM core，ws产生了wakeup event，会在msec毫秒内处理结束（wakeup events framework自动relax）。</p>
<p>类型二（操作对象为device，为设备驱动的常用接口）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* include/linux/pm_wakeup.h */</span><br><span class="line">extern int device_wakeup_enable(struct device *dev);</span><br><span class="line">extern int device_wakeup_disable(struct device *dev);</span><br><span class="line">extern void device_set_wakeup_capable(struct device *dev, bool capable); //device_set_wakeup_capable，设置dev的can_wakeup标志，并增加或移除该设备在sysfs相关的power文件；</span><br><span class="line">extern int device_init_wakeup(struct device *dev, bool val);//设置dev的can_wakeup标志，若是<span class="built_in">enable</span>，同时调用device_wakeup_enable使能wakeup功能</span><br><span class="line">extern int device_set_wakeup_enable(struct device *dev, bool <span class="built_in">enable</span>);</span><br><span class="line">extern void pm_stay_awake(struct device *dev);</span><br><span class="line">extern void pm_relax(struct device *dev);</span><br><span class="line">extern void pm_wakeup_event(struct device *dev, unsigned int msec);</span><br></pre></td></tr></table></figure>
<p>pm_stay_awake、pm_relax、pm_wakeup_event直接调用上面的wakeup source操作接口，操作device的struct wakeup_source变量，处理wakeup events</p>
<h4 id="device-set-wakeup-capable"><a href="#device-set-wakeup-capable" class="headerlink" title="device_set_wakeup_capable"></a>device_set_wakeup_capable</h4><p>该接口位于在drivers/base/power/wakeup.c中，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * device_set_wakeup_capable - Set/reset device wakeup capability flag.</span><br><span class="line"> * @dev: Device to handle.</span><br><span class="line"> * @capable: Whether or not @dev is capable of waking up the system from sleep.</span><br><span class="line"> *</span><br><span class="line"> * If @capable is <span class="built_in">set</span>, <span class="built_in">set</span> the @dev<span class="string">&#x27;s power.can_wakeup flag and add its</span></span><br><span class="line"><span class="string"> * wakeup-related attributes to sysfs.  Otherwise, unset the @dev&#x27;</span>s</span><br><span class="line"> * power.can_wakeup flag and remove its wakeup-related attributes from sysfs.</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> may sleep and it can<span class="string">&#x27;t be called from any context where</span></span><br><span class="line"><span class="string"> * sleeping is not allowed.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">void device_set_wakeup_capable(struct device *dev, bool capable)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	if (!!dev-&gt;power.can_wakeup == !!capable)</span></span><br><span class="line"><span class="string">		return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (device_is_registered(dev) &amp;&amp; !list_empty(&amp;dev-&gt;power.entry)) &#123;</span></span><br><span class="line"><span class="string">		if (capable) &#123;</span></span><br><span class="line"><span class="string">			if (wakeup_sysfs_add(dev))</span></span><br><span class="line"><span class="string">				return;</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			wakeup_sysfs_remove(dev);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	dev-&gt;power.can_wakeup = capable;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>该接口的实现很简单，主要包括sysfs的add/remove和can_wakeup标志的设置两部分.如果设置can_wakeup标志，则调用wakeup_sysfs_add，向该设备的sysfs目录下添加power文件夹，并注册相应的attribute文件。如果清除can_wakeup标志，执行sysfs的移除操作。<br>wakeup_sysfs_add/wakeup_sysfs_remove位于drivers/base/power/sysfs.c中，对wakeup events framework来说，主要包括如下的attribute文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static struct attribute *wakeup_attrs[] = &#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_PM_SLEEP</span></span><br><span class="line">	&amp;dev_attr_wakeup.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_count.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_active_count.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_abort_count.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_expire_count.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_active.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_total_time_ms.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_max_time_ms.attr,</span><br><span class="line">	&amp;dev_attr_wakeup_last_time_ms.attr,</span><br><span class="line"><span class="comment">#ifdef CONFIG_PM_AUTOSLEEP</span></span><br><span class="line">	&amp;dev_attr_wakeup_prevent_sleep_time_ms.attr,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1）wakeup</p>
<p>读，获得设备wakeup功能的使能状态，返回”enabled”或”disabled”字符串。<br>写，更改设备wakeup功能的使能状态，根据写入的字符串（”enabled”或”disabled”），调用device_set_wakeup_enable接口完成实际的状态切换。<br>设备wakeup功能是否使能，取决于设备的can_wakeup标志，以及设备是否注册有相应的struct wakeup_source指针。即can wakeup和may wakeup，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  * Changes to device_may_wakeup take effect on the next pm state change.</span><br><span class="line">  */</span><br><span class="line">  </span><br><span class="line"> static inline bool device_can_wakeup(struct device *dev)</span><br><span class="line"> &#123;</span><br><span class="line">         <span class="built_in">return</span> dev-&gt;power.can_wakeup;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> static inline bool device_may_wakeup(struct device *dev)</span><br><span class="line"> &#123;</span><br><span class="line">         <span class="built_in">return</span> dev-&gt;power.can_wakeup &amp;&amp; !!dev-&gt;power.wakeup;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>2）wakeup_count</p>
<p>只读，获取dev-&gt;power.wakeup-&gt;event_count值。顺便抱怨一下，这个attribute文件的命名简直糟糕透顶了！直接用event_count就是了，用什么wakeup_count，会和wakeup source中的同名字段搞混淆的！</p>
<p>3）wakeup_active_count，只读，获取dev-&gt;power.wakeup-&gt;active_count值。</p>
<p>4）wakeup_abort_count，只读，获取dev-&gt;power.wakeup-&gt;wakeup_count值。</p>
<p>5）wakeup_expire_count，只读，获dev-&gt;power.wakeup-&gt;expire_count取值。</p>
<p>6）wakeup_active，只读，获取dev-&gt;power.wakeup-&gt;active值。</p>
<p>7）wakeup_total_time_ms，只读，获取dev-&gt;power.wakeup-&gt;total_time值，单位为ms。</p>
<p>8）wakeup_max_time_ms，只读，获dev-&gt;power.wakeup-&gt;max_time取值，单位为ms。</p>
<p>9）wakeup_last_time_ms，只读，获dev-&gt;power.wakeup-&gt;last_time取值，单位为ms。</p>
<p>10）wakeup_prevent_sleep_time_ms，只读，获取dev-&gt;power.wakeup-&gt;prevent_sleep_time值，单位为ms。</p>
<h4 id="device-wakeup-enable-device-wakeup-disable-device-set-wakeup-enable"><a href="#device-wakeup-enable-device-wakeup-disable-device-set-wakeup-enable" class="headerlink" title="device_wakeup_enable/device_wakeup_disable/device_set_wakeup_enable"></a>device_wakeup_enable/device_wakeup_disable/device_set_wakeup_enable</h4><p>device_wakeup_enable为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * device_wakeup_enable - Enable given device to be a wakeup <span class="built_in">source</span>.</span><br><span class="line"> * @dev: Device to handle.</span><br><span class="line"> *</span><br><span class="line"> * Create a wakeup <span class="built_in">source</span> object, register it and attach it to @dev.</span><br><span class="line"> */</span><br><span class="line">int device_wakeup_enable(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct wakeup_source *ws;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	//若设备指针为空，或者设备不具备wakeup能力，免谈，报错退出</span><br><span class="line">	<span class="keyword">if</span> (!dev || !dev-&gt;power.can_wakeup)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	//调用wakeup_source_register接口，以设备名为参数，创建并注册一个wakeup <span class="built_in">source</span></span><br><span class="line">	ws = wakeup_source_register(dev_name(dev));</span><br><span class="line">	<span class="keyword">if</span> (!ws)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	//调用device_wakeup_attach接口，将新建的wakeup <span class="built_in">source</span>保存在dev-&gt;power.wakeup指针中</span><br><span class="line">	ret = device_wakeup_attach(dev, ws);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		wakeup_source_unregister(ws);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wakeup_source_register接口的实现也比较简单，会先后调用wakeup_source_create、wakeup_source_prepare、wakeup_source_add等接口，所做的工作包括分配struct wakeup_source变量所需的内存空间、初始化内部变量、将新建的wakeup source添加到名称为wakeup_sources的全局链表中、等等。</p>
<p>device_wakeup_attach接口更为直观，不过有一点我们要关注，如果设备的dev-&gt;power.wakeup非空，也就是说之前已经有一个wakeup source了，是不允许再enable了的，会报错返回。</p>
<h4 id="pm-stay-awake"><a href="#pm-stay-awake" class="headerlink" title="pm_stay_awake"></a>pm_stay_awake</h4><p>当设备有wakeup event正在处理时，需要调用该接口通知PM core，该接口的实现如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * __pm_stay_awake - Notify the PM core of a wakeup event.</span><br><span class="line"> * @ws: Wakeup <span class="built_in">source</span> object associated with the <span class="built_in">source</span> of the event.</span><br><span class="line"> *</span><br><span class="line"> * It is safe to call this <span class="keyword">function</span> from interrupt context.</span><br><span class="line"> */</span><br><span class="line">void __pm_stay_awake(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ws)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ws-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	wakeup_source_report_event(ws);</span><br><span class="line">	del_timer(&amp;ws-&gt;timer);</span><br><span class="line">	ws-&gt;timer_expires = 0;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;ws-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * pm_stay_awake - Notify the PM core that a wakeup event is being processed.</span><br><span class="line"> * @dev: Device the wakeup event is related to.</span><br><span class="line"> *</span><br><span class="line"> * Notify the PM core of a wakeup event (signaled by @dev) by calling</span><br><span class="line"> * __pm_stay_awake <span class="keyword">for</span> the @dev<span class="string">&#x27;s wakeup source object.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Call this function after detecting of a wakeup event if pm_relax() is going</span></span><br><span class="line"><span class="string"> * to be called directly after processing the event (and possibly passing it to</span></span><br><span class="line"><span class="string"> * user space for further processing).</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">void pm_stay_awake(struct device *dev)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	unsigned long flags;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!dev)</span></span><br><span class="line"><span class="string">		return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	spin_lock_irqsave(&amp;dev-&gt;power.lock, flags);</span></span><br><span class="line"><span class="string">	__pm_stay_awake(dev-&gt;power.wakeup);</span></span><br><span class="line"><span class="string">	spin_unlock_irqrestore(&amp;dev-&gt;power.lock, flags);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>由于pm_stay_awake报告的event需要经过pm_relax主动停止，因此就不再需要timer，所以__pm_stay_awake实现是直接调用wakeup_source_report_event，然后停止timer。接着看代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * wakeup_source_report_event - Report wakeup event using the given <span class="built_in">source</span>.</span><br><span class="line"> * @ws: Wakeup <span class="built_in">source</span> to report the event <span class="keyword">for</span>.</span><br><span class="line"> */</span><br><span class="line">static void wakeup_source_report_event(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	ws-&gt;event_count++; //增加wakeup <span class="built_in">source</span>的event_count，表示该<span class="built_in">source</span>又产生了一个event。</span><br><span class="line">	/* This is racy, but the counter is approximate anyway. */</span><br><span class="line">	//根据events_check_enabled变量的状态，决定是否增加wakeup_count。这和wakeup count的功能有关</span><br><span class="line">	<span class="keyword">if</span> (events_check_enabled) </span><br><span class="line">		ws-&gt;wakeup_count++;</span><br><span class="line"></span><br><span class="line">	//如果wakeup <span class="built_in">source</span>没有active，则调用wakeup_source_activate，activate之</span><br><span class="line">	<span class="keyword">if</span> (!ws-&gt;active)</span><br><span class="line">		wakeup_source_activate(ws);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * wakup_source_activate - Mark given wakeup <span class="built_in">source</span> as active.</span><br><span class="line"> * @ws: Wakeup <span class="built_in">source</span> to handle.</span><br><span class="line"> *</span><br><span class="line"> * Update the @ws<span class="string">&#x27; statistics and, if @ws has just been activated, notify the PM</span></span><br><span class="line"><span class="string"> * core of the event by incrementing the counter of of wakeup events being</span></span><br><span class="line"><span class="string"> * processed.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static void wakeup_source_activate(struct wakeup_source *ws)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	unsigned int cec;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (WARN_ONCE(wakeup_source_not_registered(ws),</span></span><br><span class="line"><span class="string">			&quot;unregistered wakeup source\n&quot;))</span></span><br><span class="line"><span class="string">		return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * active wakeup source should bring the system</span></span><br><span class="line"><span class="string">	 * out of PM_SUSPEND_FREEZE state</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	 //调用freeze_wake，将系统从suspend to freeze状态下唤醒</span></span><br><span class="line"><span class="string">	freeze_wake();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//设置active标志，增加active_count，更新last_time</span></span><br><span class="line"><span class="string">	ws-&gt;active = true;</span></span><br><span class="line"><span class="string">	ws-&gt;active_count++;</span></span><br><span class="line"><span class="string">	ws-&gt;last_time = ktime_get();</span></span><br><span class="line"><span class="string">	//如果使能了autosleep，更新start_prevent_time，因为此刻该wakeup source会开始阻止系统auto sleep</span></span><br><span class="line"><span class="string">	if (ws-&gt;autosleep_enabled)</span></span><br><span class="line"><span class="string">		ws-&gt;start_prevent_time = ws-&gt;last_time;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//增加“wakeup events in progress”计数,该操作是wakeup events framework的灵魂，增加该计数，意味着系统正在处理的wakeup event数目不为零，则系统不能suspend</span></span><br><span class="line"><span class="string">	/* Increment the counter of events in progress. */</span></span><br><span class="line"><span class="string">	cec = atomic_inc_return(&amp;combined_event_count);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	trace_wakeup_source_activate(ws-&gt;name, cec);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>到此，pm_stay_awake执行结束，意味着系统至少正在处理一个wakeup event，因此不能suspend。那处理完成后呢？driver要调用pm_relax通知PM core。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * __pm_relax - Notify the PM core that processing of a wakeup event has ended.</span><br><span class="line"> * @ws: Wakeup <span class="built_in">source</span> object associated with the <span class="built_in">source</span> of the event.</span><br><span class="line"> *</span><br><span class="line"> * Call this <span class="keyword">function</span> <span class="keyword">for</span> wakeup events whose processing started with calling</span><br><span class="line"> * __pm_stay_awake().</span><br><span class="line"> *</span><br><span class="line"> * It is safe to call it from interrupt context.</span><br><span class="line"> */</span><br><span class="line">void __pm_relax(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ws)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ws-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">		wakeup_source_deactivate(ws);</span><br><span class="line">	spin_unlock_irqrestore(&amp;ws-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">/**</span><br><span class="line"> * pm_relax - Notify the PM core that processing of a wakeup event has ended.</span><br><span class="line"> * @dev: Device that signaled the event.</span><br><span class="line"> *</span><br><span class="line"> * Execute __pm_relax() <span class="keyword">for</span> the @dev<span class="string">&#x27;s wakeup source object.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">void pm_relax(struct device *dev)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	unsigned long flags;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!dev)</span></span><br><span class="line"><span class="string">		return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	spin_lock_irqsave(&amp;dev-&gt;power.lock, flags);</span></span><br><span class="line"><span class="string">	__pm_relax(dev-&gt;power.wakeup);</span></span><br><span class="line"><span class="string">	spin_unlock_irqrestore(&amp;dev-&gt;power.lock, flags);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果该wakeup source处于active状态，调用wakeup_source_deactivate接口，deactivate之。deactivate接口和activate接口一样，是wakeup events framework的核心逻辑，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static void wakeup_source_deactivate(struct wakeup_source *ws)</span><br><span class="line"> &#123;</span><br><span class="line">         unsigned int cnt, inpr, cec;</span><br><span class="line">         ktime_t duration;</span><br><span class="line">         ktime_t now;</span><br><span class="line">  </span><br><span class="line">         ws-&gt;relax_count++; //relax_count加1（如果relax_count和active_count不等，则说明有重复调用，要退出）</span><br><span class="line">         /*</span><br><span class="line">          * __pm_relax() may be called directly or from a timer <span class="keyword">function</span>.</span><br><span class="line">          * If it is called directly right after the timer <span class="keyword">function</span> has been</span><br><span class="line">          * started, but before the timer <span class="keyword">function</span> calls __pm_relax(), it is</span><br><span class="line">          * possible that __pm_stay_awake() will be called <span class="keyword">in</span> the meantime and</span><br><span class="line">          * will <span class="built_in">set</span> ws-&gt;active.  Then, ws-&gt;active may be cleared immediately</span><br><span class="line">          * by the __pm_relax() called from the timer <span class="keyword">function</span>, but <span class="keyword">in</span> such a</span><br><span class="line">          * <span class="keyword">case</span> ws-&gt;relax_count will be different from ws-&gt;active_count.</span><br><span class="line">          */</span><br><span class="line">         <span class="keyword">if</span> (ws-&gt;relax_count != ws-&gt;active_count) &#123;</span><br><span class="line">                 ws-&gt;relax_count--;</span><br><span class="line">                 <span class="built_in">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">  		//清除active标记</span><br><span class="line">         ws-&gt;active = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  		//更新total_time、max_time、last_time等变量</span><br><span class="line">         now = ktime_get();</span><br><span class="line">         duration = ktime_sub(now, ws-&gt;last_time);</span><br><span class="line">         ws-&gt;total_time = ktime_add(ws-&gt;total_time, duration);</span><br><span class="line">         <span class="keyword">if</span> (ktime_to_ns(duration) &gt; ktime_to_ns(ws-&gt;max_time))</span><br><span class="line">                 ws-&gt;max_time = duration;</span><br><span class="line">  </span><br><span class="line">         ws-&gt;last_time = now;</span><br><span class="line">         del_timer(&amp;ws-&gt;timer);</span><br><span class="line">         ws-&gt;timer_expires = 0;</span><br><span class="line">  </span><br><span class="line">  		//如果使能auto sleep，更新相关的变量</span><br><span class="line">         <span class="keyword">if</span> (ws-&gt;autosleep_enabled)</span><br><span class="line">                 update_prevent_sleep_time(ws, now);</span><br><span class="line">  </span><br><span class="line">         /*</span><br><span class="line">          * Increment the counter of registered wakeup events and decrement the</span><br><span class="line">          * couter of wakeup events <span class="keyword">in</span> progress simultaneously.</span><br><span class="line">          */</span><br><span class="line">          //wakeup events <span class="keyword">in</span> progress减1，registered wakeup events加1</span><br><span class="line">         cec = atomic_add_return(MAX_IN_PROGRESS, &amp;combined_event_count);</span><br><span class="line">         trace_wakeup_source_deactivate(ws-&gt;name, cec);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">         split_counters(&amp;cnt, &amp;inpr);</span><br><span class="line">         <span class="keyword">if</span> (!inpr &amp;&amp; waitqueue_active(&amp;wakeup_count_wait_queue))</span><br><span class="line">                 wake_up(&amp;wakeup_count_wait_queue);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="pm-wakeup-event"><a href="#pm-wakeup-event" class="headerlink" title="pm_wakeup_event"></a>pm_wakeup_event</h4><p>pm_wakeup_event是pm_stay_awake和pm_relax的组合版，在上报event时，指定一个timeout时间，timeout后，自动relax，一般用于不知道何时能处理完成的场景。该接口比较简单，就不一一描述了。</p>
<h4 id="pm-wakeup-pending"><a href="#pm-wakeup-pending" class="headerlink" title="pm_wakeup_pending"></a>pm_wakeup_pending</h4><p>drivers产生的wakeup events，最终要上报到PM core，PM core会根据这些events，决定是否要终止suspend过程。这表现在suspend过程中频繁调用pm_wakeup_pending接口上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * pm_wakeup_pending - Check <span class="keyword">if</span> power transition <span class="keyword">in</span> progress should be aborted.</span><br><span class="line">  *</span><br><span class="line">  * Compare the current number of registered wakeup events with its preserved</span><br><span class="line">  * value from the past and <span class="built_in">return</span> <span class="literal">true</span> <span class="keyword">if</span> new wakeup events have been registered</span><br><span class="line">  * since the old value was stored.  Also <span class="built_in">return</span> <span class="literal">true</span> <span class="keyword">if</span> the current number of</span><br><span class="line">  * wakeup events being processed is different from zero.</span><br><span class="line">  */</span><br><span class="line"> bool pm_wakeup_pending(void)</span><br><span class="line"> &#123;</span><br><span class="line">         unsigned long flags;</span><br><span class="line">         bool ret = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">         spin_lock_irqsave(&amp;events_lock, flags);</span><br><span class="line">         <span class="keyword">if</span> (events_check_enabled) &#123;</span><br><span class="line">                 unsigned int cnt, inpr;</span><br><span class="line">  </span><br><span class="line">                 split_counters(&amp;cnt, &amp;inpr);</span><br><span class="line">                 ret = (cnt != saved_count || inpr &gt; 0);</span><br><span class="line">                 events_check_enabled = !ret;</span><br><span class="line">         &#125;</span><br><span class="line">         spin_unlock_irqrestore(&amp;events_lock, flags);</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> (ret)</span><br><span class="line">                 print_active_wakeup_sources();</span><br><span class="line">  </span><br><span class="line">         <span class="built_in">return</span> ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该接口的逻辑比较直观，先抛开wakeup count的逻辑不谈，只要正在处理的events不为0，就返回true，调用者就会终止suspend。</p>
<h3 id="wakeup-count的功能"><a href="#wakeup-count的功能" class="headerlink" title="wakeup count的功能"></a>wakeup count的功能</h3><p>akeup count的功能是suspend同步，实现思路是这样的：</p>
<p>1）任何想发起电源状态切换的实体（可以是用户空间电源管理进程，也可以是内核线程，简称C），在发起状态切换前，读取系统的wakeup counts（该值记录了当前的wakeup event总数），并将读取的counts告知wakeup events framework。</p>
<p>2）wakeup events framework记录该counts到一个全局变量中（saved_count）。</p>
<p>3）随后C发起电源状态切换（如STR），执行suspend过程。</p>
<p>4）在suspend的过程中，wakeup events framework照旧工作（直到系统中断被关闭），上报wakeup events，增加wakeup events counts。</p>
<p>5）suspend执行的一些时间点，会调用wakeup  events framework提供的接口（pm_wakeup_pending），检查是否有wakeup没有处理。</p>
<p>6）检查逻辑很简单，就是比较当前的wakeup counts和saved wakeup counts（C发起电源状态切换时的counts），如果不同，就要终止suspend过程。</p>
<h3 id="wakeup-count的实现逻辑"><a href="#wakeup-count的实现逻辑" class="headerlink" title="wakeup count的实现逻辑"></a>wakeup count的实现逻辑</h3><p>在进行代码分析之前，我们先用伪代码的形式，写出一个利用wakeup count进行suspend操作的例子，然后基于该例子，分析相关的实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = <span class="built_in">read</span>(&amp;cnt, <span class="string">&quot;/sys/power/wakeup_count&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        ret = write(cnt, <span class="string">&quot;/sys/power/wakeup_count&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        countine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!ret);</span><br><span class="line"> </span><br><span class="line">write(<span class="string">&quot;mem&quot;</span>, <span class="string">&quot;/sys/power/state&quot;</span>);</span><br><span class="line"> </span><br><span class="line">/* goto here after wakeup */</span><br></pre></td></tr></table></figure>
<p>a）读取wakeup count值，如果成功，将读取的值回写。否则说明有正在处理的wakeup events，continue。</p>
<p>b）回写后，判断返回值是否成功，如果不成功（说明读、写的过程中产生了wakeup events），继续读、写，直到成功。成功后，可以触发电源状态切换。</p>
]]></content>
      <categories>
        <category>linux-kernel</category>
      </categories>
      <tags>
        <tag>wakeup</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-search</title>
    <url>/2018/09/06/linux-search/</url>
    <content><![CDATA[<h3 id="一、grep"><a href="#一、grep" class="headerlink" title="一、grep"></a>一、grep</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>grep -rn <span class="string">&quot;string&quot;</span> *</span><br></pre></td></tr></table></figure>
<ul>
<li>: 表示当前目录所有文件，也可以是某个文件名</li>
</ul>
<p>-r 是递归查找<br>-n 是显示行号<br>-R 查找所有文件包含子目录<br>-i 忽略大小写</p>
<h3 id="二、find"><a href="#二、find" class="headerlink" title="二、find"></a>二、find</h3><p>在当前目录及子目录下查找文件</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="builtin-name">find</span> -name <span class="string">&quot;file_name&quot;</span></span><br></pre></td></tr></table></figure>
<p>在home目录下查找以.txt结尾的文件，忽略大小写</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">find</span> /<span class="built_in">home</span> -iname <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure>
<p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="built_in">name</span> <span class="string">&quot;*.txt&quot;</span> -o -<span class="built_in">name</span> <span class="string">&quot;*.pdf&quot;</span> </span><br></pre></td></tr></table></figure>
<p>搜索最近七天内被访问过的所有文件</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="keyword">type</span> <span class="type">f </span>-atime -<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>搜索访问时间超过10分钟的所有文件</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="keyword">type</span> <span class="type">f </span>-amin +<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>搜索大于10KB的文件</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> +<span class="number">10</span>k</span><br></pre></td></tr></table></figure>
<p>删除当前目录下所有.txt文件</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="keyword">type</span> f -<span class="type">name</span> &quot;*.txt&quot; -<span class="keyword">delete</span></span><br></pre></td></tr></table></figure>
<p>当前目录下搜索出权限为777的文件</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="keyword">type</span> <span class="type">f </span>-perm <span class="number">777</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-shell</title>
    <url>/2019/11/28/linux-shell/</url>
    <content><![CDATA[<h3 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h3><p>1、定义变量</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">var</span>=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure>
<p>变量名和等号之间不能有空格<br>2、引用变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure>
<p>推荐使用第二种<br>3、只读变量</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">readonly</span> <span class="built_in">var</span></span><br></pre></td></tr></table></figure>
<p>4、删除变量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unset</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
<p>5、字符串</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">str1</span>=<span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="attribute">str2</span>=<span class="string">&quot;str1 is \&quot;<span class="variable">$str1</span>\&quot;&quot;</span></span><br><span class="line">echo <span class="variable">$str2</span></span><br></pre></td></tr></table></figure>
<p>双引号里可以有变量<br>6、获取字符串长度</p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;1234&quot;</span></span><br><span class="line"><span class="built_in">echo</span> $&#123;#<span class="built_in">str</span>&#125;</span><br></pre></td></tr></table></figure>
<p>7、截取字符串</p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;google&quot;</span></span><br><span class="line"><span class="built_in">echo</span> $&#123;<span class="built_in">str</span>:<span class="number">0</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>8、数组</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">array</span>=(val<span class="number">0</span> val<span class="number">1</span> val<span class="number">2</span>)</span><br><span class="line"><span class="attribute">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br></pre></td></tr></table></figure>
<p>9、注释<br>#是单行注释<br>:&lt;&lt; EOF<br>注释内容<br>EOF</p>
<h3 id="二、传递参数"><a href="#二、传递参数" class="headerlink" title="二、传递参数"></a>二、传递参数</h3><p>$0为脚本文件名，$1为脚本第一个参数，$2为第二个参数，以此类推…<br>|参数|说明|<br>|——|——|<br>|$#|参数个数|<br>|$$|运行脚本的当前进程ID|<br>|$!|后台运行的最后一个进程ID|<br>|$?|显示最后命令的退出状态，0表示没有错误，其他值有错误|</p>
<h3 id="三、表达式"><a href="#三、表达式" class="headerlink" title="三、表达式"></a>三、表达式</h3><p>1、 使用expre进行算术运算</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">val</span>=`expr 1 + 1`</span><br><span class="line">echo <span class="string">&quot;val=<span class="variable">$&#123;val&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>乘号(*)前边必须加反斜杠()才能实现乘法运算<br>2、条件表达式<br>条件表达三要放到[]里并且要加空格</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>3、关系运算符<br>|运算符|说明|<br>|———|——|<br>| -eq |检测两个数是否相等，相等返回 true|<br>| -ne |检测两个数是否不相等，不相等返回 true|<br>| -gt |检测左边的数是否大于右边的，如果是，则返回 true|<br>| -lt |检测左边的数是否小于右边的，如果是，则返回 true|<br>| -ge |检测左边的数是否大于等于右边的，如果是，则返回 true|<br>| -le |检测左边的数是否小于等于右边的，如果是，则返回 true|</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne <span class="variable">$b</span> ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> -ne <span class="variable">$b</span>: a 不等于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> -ne <span class="variable">$b</span> : a 等于 b&quot;</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br></pre></td></tr></table></figure>
<p>4、布尔运算<br>|运算符|说明|<br>|———|—–|<br>| !|非运算，表达式为 true 则返回 false，否则返回 true|<br>| -o |或运算，有一个表达式为 true 则返回 true|<br>| -a |与运算，两个表达式都为 true 才返回 true|</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>5、逻辑运算<br>|运算|说明|<br>|——|——-|<br>| &amp;&amp; |逻辑与|<br>| || |逻辑或|</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 &amp;&amp; <span class="variable">$b</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>6、字符串运算符<br>|运算符|说明|<br>|———|——-|<br>| = |检测两个字符串是否相等，相等返回 true|<br>| ！= |检测两个字符串是否相等，不相等返回 true|<br>| -z |检测字符串长度是否为0，为0返回 true|<br>| -n |检测字符串长度是否为0，不为0返回 true|<br>| str |检测字符串是否为空，不为空返回 true|</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$a</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;-n <span class="variable">$a</span> : 字符串长度不为 0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;-n <span class="variable">$a</span> : 字符串长度为 0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>7、文件测试运算符<br>-b file    检测文件是否是块设备文件，如果是，则返回 true。<br>-c file    检测文件是否是字符设备文件，如果是，则返回 true。<br>-d file    检测文件是否是目录，如果是，则返回 true。<br>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。<br>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。<br>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。<br>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。<br>-p file    检测文件是否是有名管道，如果是，则返回 true。<br>-r file    检测文件是否可读，如果是，则返回 true。<br>-w file    检测文件是否可写，如果是，则返回 true。<br>-x file    检测文件是否可执行，如果是，则返回 true。<br>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file=<span class="string">&quot;/var/www/runoob/test.sh&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;文件可读&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;文件不可读&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h3 id="四、echo命令"><a href="#四、echo命令" class="headerlink" title="四、echo命令"></a>四、echo命令</h3><p>1、显示换行与不换行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e  <span class="string">&quot;OK! \n&quot;</span> <span class="comment"># -e开启转义</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \c&quot;</span> <span class="comment"># \c不换行</span></span><br></pre></td></tr></table></figure>
<p>2、原样显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$var\&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>3、显示执行结果</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">date</span>`</span><br></pre></td></tr></table></figure>
<h3 id="五、test命令"><a href="#五、test命令" class="headerlink" title="五、test命令"></a>五、test命令</h3><p>1、数值测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数相等！&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数不相等！&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>代码中的 [] 执行基本的算数运算<br>2、字符串测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num1=<span class="string">&quot;ru1noob&quot;</span></span><br><span class="line">num2=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$num1</span> = <span class="variable">$num2</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个字符串相等!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个字符串不相等!&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>3、文件测试<br>-e 文件名    如果文件存在则为真<br>-r 文件名    如果文件存在且可读则为真<br>-w 文件名    如果文件存在且可写则为真<br>-x 文件名    如果文件存在且可执行则为真<br>-s 文件名    如果文件存在且至少有一个字符则为真<br>-d 文件名    如果文件存在且为目录则为真<br>-f 文件名    如果文件存在且为普通文件则为真<br>-c 文件名    如果文件存在且为字符型特殊文件则为真<br>-b 文件名    如果文件存在且为块特殊文件则为真</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;文件已存在!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;文件不存在!&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h3 id="六、流程控制"><a href="#六、流程控制" class="headerlink" title="六、流程控制"></a>六、流程控制</h3><p>1、if语句<br><strong>if格式</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line">then</span><br><span class="line">    <span class="keyword">command</span>1 </span><br><span class="line">    <span class="keyword">command</span>2</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="keyword">command</span>N </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>if else</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line">then</span><br><span class="line">    <span class="keyword">command</span>1 </span><br><span class="line">    <span class="keyword">command</span>2</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="keyword">command</span>N</span><br><span class="line">else</span><br><span class="line">    <span class="keyword">command</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>if elif else</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>2、for循环</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 <span class="string">...</span> itemN</span><br><span class="line">do</span><br><span class="line">    <span class="keyword">command</span>1</span><br><span class="line">    <span class="keyword">command</span>2</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="keyword">command</span>N</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>3、while语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>无限循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> : <span class="comment"># while true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>4、case语句</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    <span class="keyword">command</span>1</span><br><span class="line">    <span class="keyword">command</span>2</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="keyword">command</span>N</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    <span class="keyword">command</span>1</span><br><span class="line">    <span class="keyword">command</span>2</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="keyword">command</span>N</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><p>1、函数定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这个函数会对输入的两个数字进行相加运算...&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第一个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第二个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、函数参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-sublineText</title>
    <url>/2018/07/06/linux-sublineText/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装插件<br>按Ctrl+ `(此符号为tab按键上面的按键) 调出console</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">&#x27;Package Control.sublime-package&#x27;</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); <span class="keyword">open</span>(os.path.<span class="keyword">join</span>(ipp, pf), <span class="string">&#x27;wb&#x27;</span>).<span class="keyword">write</span>(urllib.request.urlopen( <span class="string">&#x27;http://sublime.wbond.net/&#x27;</span> + pf.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;%20&#x27;</span>)).<span class="keyword">read</span>())</span><br></pre></td></tr></table></figure>
<p>按下Ctrl+Shift+P调出命令面板<br>输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h3><p>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。</p>
<p>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。</p>
<p>Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。</p>
<p>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</p>
<p>Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。</p>
<p>Ctrl+Shift+] 选中代码，按下快捷键，展开代码。</p>
<p>Ctrl+K+0 展开所有折叠代码。</p>
<p>shift+↑ 向上选中多行。</p>
<p>shift+↓ 向下选中多行。</p>
<p>Shift+← 向左选中文本。</p>
<p>Shift+→ 向右选中文本。</p>
<p>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</p>
<p>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</p>
<p>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。</p>
<p>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。</p>
<h3 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h3><p>Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。</p>
<p>Ctrl+Shift+D 复制光标所在整行，插入到下一行。</p>
<p>Tab 向右缩进。</p>
<p>Shift+Tab 向左缩进。</p>
<p>Ctrl+Shift+K 删除整行。</p>
<p>Ctrl+/ 注释单行。</p>
<p>Ctrl+Shift+/ 注释多行。</p>
<p>Ctrl+Z 撤销。</p>
<p>Ctrl+Y 恢复撤销。</p>
<p>Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。</p>
<p>Ctrl+F2 设置书签</p>
<p>F6 单词检测拼写</p>
<h3 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h3><p>ctrl+shift+F 全局搜索，但是这个快捷键是搜狗繁体和简体的切换快捷键，需要在搜狗设置了关掉</p>
<p>Ctrl+F 打开底部搜索框，查找关键字。</p>
<p>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。</p>
<p>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。</p>
<p>Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</p>
<p>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。</p>
<p>Esc 退出光标多行选择，退出搜索框，命令框等。</p>
<h3 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h3><p>Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。</p>
<p>Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）</p>
<p>Alt+Shift+2 左右分屏-2列</p>
<p>Alt+Shift+3 左右分屏-3列</p>
<p>Alt+Shift+4 左右分屏-4列</p>
<p>Alt+Shift+5 等分4屏</p>
<p>Alt+Shift+8 垂直分屏-2屏</p>
<p>Alt+Shift+9 垂直分屏-3屏</p>
<p>F11 全屏模式</p>
<h3 id="设置自动跳转"><a href="#设置自动跳转" class="headerlink" title="设置自动跳转"></a>设置自动跳转</h3><p>点击Preferences-&gt;Browse Packages进入Packages目录，然后打开User目录，查看User目录里面有没有Default (Windows).sublime-mousemap文件，如果没有则创建一个。这个文件是用来配置sublime的鼠标操作的。在文件中输入如下内容：linux下文件名为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;button&quot;</span>: <span class="string">&quot;button2&quot;</span>,</span><br><span class="line"><span class="attr">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;modifiers&quot;</span>: [<span class="string">&quot;ctrl&quot;</span>],</span><br><span class="line"><span class="attr">&quot;command&quot;</span>: <span class="string">&quot;jump_back&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;button&quot;</span>: <span class="string">&quot;button1&quot;</span>,</span><br><span class="line"><span class="attr">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;modifiers&quot;</span>: [<span class="string">&quot;ctrl&quot;</span>],</span><br><span class="line"><span class="attr">&quot;press_command&quot;</span>: <span class="string">&quot;drag_select&quot;</span>,</span><br><span class="line"><span class="attr">&quot;command&quot;</span>: <span class="string">&quot;goto_definition&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>点击保存即可。<br>ctrl+鼠标左键跳转到函数定义处；<br>ctrl+鼠标右键跳回来。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>sublinetext</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-tar</title>
    <url>/2018/06/06/linux-tar/</url>
    <content><![CDATA[<h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><p>zip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。</p>
<p>我们可以使用下列的命令压缩一个目录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">zip</span> -r xxxx.<span class="built_in">zip</span> directory_to_compress</span><br></pre></td></tr></table></figure>
<p>下面是如果解压一个zip文档：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>unzip xxxx.zip</span><br></pre></td></tr></table></figure>
<h3 id="TAR"><a href="#TAR" class="headerlink" title="TAR"></a>TAR</h3><p>Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。</p>
<p>下面是如何打包一个目录：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tar -cvf xxxx.tar directory_to_compress</span><br></pre></td></tr></table></figure>
<p>如何解包：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tar -xvf xxxx.tar.gz</span><br></pre></td></tr></table></figure>
<p>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ tar -xvf xxxx.tar -C <span class="regexp">/tmp/</span>extract_here/</span><br></pre></td></tr></table></figure>
<h3 id="TAR-GZ"><a href="#TAR-GZ" class="headerlink" title="TAR.GZ"></a>TAR.GZ</h3><p>这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。</p>
<p>使用下面这种格式去压缩一个目录：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ tar -zcvf xxxx<span class="selector-class">.tar</span><span class="selector-class">.gz</span> directory_to_compress</span><br></pre></td></tr></table></figure>
<p>解压缩：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tar -zxvf xxxx.tar.gz</span><br></pre></td></tr></table></figure>
<p>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf xxxx.tar.gz -C <span class="regexp">/tmp/</span>extract_here/</span><br></pre></td></tr></table></figure>
<h3 id="TAR-BZ2"><a href="#TAR-BZ2" class="headerlink" title="TAR.BZ2"></a>TAR.BZ2</h3><p>这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。</p>
<p>这个就是你如何使用tar.bz2进行压缩</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ tar -<span class="keyword">jcvf </span>xxxx.tar.<span class="keyword">bz2 </span><span class="keyword">directory_to_compress</span></span><br></pre></td></tr></table></figure>
<p>上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ tar -jxvf xxxx.tar.bz2 -C <span class="regexp">/tmp/</span>extract_here/</span><br></pre></td></tr></table></figure>
<h3 id="分段压缩与解压"><a href="#分段压缩与解压" class="headerlink" title="分段压缩与解压"></a>分段压缩与解压</h3><p>要将目录logs打包压缩并分割成多个1M的文件，可以用下面的命令：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$ tar cjf - logs/ <span class="string">|split -b 1m - logs.tar.bz2</span></span><br></pre></td></tr></table></figure>
<p>完成后会产生下列文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">logs</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span><span class="selector-class">.aa</span>, <span class="selector-tag">logs</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span><span class="selector-class">.ab</span>, <span class="selector-tag">logs</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span><span class="selector-class">.ac</span></span><br></pre></td></tr></table></figure>
<p>要解压的时候只要执行下面的命令就可以了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> logs.tar.bz2.a* | tar xj</span><br></pre></td></tr></table></figure>
<p>要将文件test.pdf分包压缩成500 bytes的文件：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ tar czf - <span class="keyword">test</span>.pdf | <span class="keyword">split</span> -b 500 - <span class="keyword">test</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>最后要提醒但是那两个”-“不要漏了，那是tar的ouput和split的input的参数。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$ tar cjf - logs/ <span class="string">|split -b 1m - logs.tar.bz2</span></span><br></pre></td></tr></table></figure>
<p>完成后会产生下列文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">logs</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span><span class="selector-class">.aa</span>, <span class="selector-tag">logs</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span><span class="selector-class">.ab</span>, <span class="selector-tag">logs</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span><span class="selector-class">.ac</span></span><br></pre></td></tr></table></figure>
<p>要解压的时候只要执行下面的命令就可以了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> logs.tar.bz2.a* | tar xj</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-ubuntu</title>
    <url>/2018/05/06/linux-ubuntu/</url>
    <content><![CDATA[<h3 id="一、关闭图形界面"><a href="#一、关闭图形界面" class="headerlink" title="一、关闭图形界面"></a>一、关闭图形界面</h3><p>1.删除图形界面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="builtin-name">disable</span> lightdm.service</span><br></pre></td></tr></table></figure>
<p>安装界面</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install <span class="comment">--reinstall lightdm</span></span><br></pre></td></tr></table></figure>
<p>2.修改默认启动界面</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="built_in">set-default</span> <span class="string">multi-user</span>.<span class="string">target</span></span><br></pre></td></tr></table></figure>
<p>切换回图形界面</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="built_in">set-default</span> <span class="string">graphical</span>.<span class="string">target</span></span><br></pre></td></tr></table></figure>
<p>3.临时开启</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="literal">start</span> lightdm</span><br></pre></td></tr></table></figure>
<h3 id="二、ubuntu安装ssh并设置开启启动"><a href="#二、ubuntu安装ssh并设置开启启动" class="headerlink" title="二、ubuntu安装ssh并设置开启启动"></a>二、ubuntu安装ssh并设置开启启动</h3><p>1.安装ssh</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install openssh-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>查看ssh是否启动</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> -<span class="keyword">e</span> | <span class="keyword">grep</span> ssh</span><br></pre></td></tr></table></figure>
<p>如果有sshd就代表服务已启动<br>2.启动，停止和重启ssh</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d/ssh start</span><br><span class="line"><span class="regexp">/etc/i</span>nit.d/ssh stop</span><br><span class="line"><span class="regexp">/etc/i</span>nit.d/ssh restart</span><br></pre></td></tr></table></figure>
<p>配置文件在/etc/ssh/sshd_config可以修改端口号等<br>3.开机启动<br>在/etc/rc.local文件里添加如下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d/ssh start</span><br></pre></td></tr></table></figure>
<h3 id="三、将另一块硬盘挂载到home分区"><a href="#三、将另一块硬盘挂载到home分区" class="headerlink" title="三、将另一块硬盘挂载到home分区"></a>三、将另一块硬盘挂载到home分区</h3><p>1、查看磁盘信息并格式化</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lsblk</span></span><br><span class="line"><span class="attribute">mkfs</span> -t ext<span class="number">4</span> /dev/sda<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>2、同步home目录内容到新磁盘</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo mount <span class="regexp">/dev/</span>sda1 /mnt</span><br><span class="line">sudo rsync -avx <span class="regexp">/hone /m</span>nt</span><br><span class="line">sudo rm -rf <span class="regexp">/home/</span>*</span><br></pre></td></tr></table></figure>
<p>3、挂载新硬盘并设在开机自动挂载<br>挂载硬盘</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo umount -l <span class="string">/home</span></span><br><span class="line">sudo mount <span class="string">/dev/sda1</span> <span class="string">/home</span></span><br></pre></td></tr></table></figure>
<p>获得磁盘uid</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo blkid</span></span><br></pre></td></tr></table></figure>
<p>修改/etc/fstab在文件末尾添加如下</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">UUID</span>=xxxxxxxxxxxxxxxxxxxxx     /home     ext<span class="number">4</span>     defaults     <span class="number">0</span>      <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="四、gnome扩展"><a href="#四、gnome扩展" class="headerlink" title="四、gnome扩展"></a>四、gnome扩展</h3><ul>
<li>Dash To Dock</li>
<li>Clipboard Indicator</li>
<li>Drop Down Terminal</li>
<li>Coverflow Alt-Tab</li>
<li>Dynamic Top Bar</li>
<li>Top Panel Workspace Scroll</li>
<li>Konsole</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-vim.md</title>
    <url>/2019/11/17/linux-vim-md/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>vim + cscope + ctags + tags + minibufexp + netrw查看代码</p>
<h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line">syntax on</span><br><span class="line"><span class="built_in">set</span> showmode</span><br><span class="line"><span class="built_in">set</span> showcmd</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8 </span><br><span class="line"><span class="built_in">set</span> t_Co=256</span><br><span class="line">filetype indent on</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> autochdir</span><br><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"><span class="built_in">set</span> wildmode=longest:list,full</span><br></pre></td></tr></table></figure>
<h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><ol>
<li>生成代码的符号索引文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cscope -Rbkq</span><br></pre></td></tr></table></figure>
这个命令会生成三个文件：cscope.out, cscope.in.out, cscope.po.out。其中cscope.out是基本的符号索引，后两个文件是使用”-q”选项生成的，可以加快cscope的索引速度。  </li>
</ol>
<p>-R: 在生成索引文件时，搜索子目录树中的代码<br>-b: 只生成索引文件，不进入cscope的界面<br>-k: 在生成索引文件时，不搜索/usr/include目录<br>-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-vpsSSR</title>
    <url>/2018/06/06/linux-vpsSSR/</url>
    <content><![CDATA[<h3 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h3><p>1、一键脚本安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget —no-check-certificate https:<span class="regexp">//</span>freed.ga<span class="regexp">/github/</span>shadowsocksR.sh; bashshadowsocksR.sh</span><br></pre></td></tr></table></figure>
<p>2、安装bbr加速</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:<span class="regexp">//gi</span>thub.com<span class="regexp">/teddysun/</span>across<span class="regexp">/raw/m</span>aster<span class="regexp">/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./</span>bbr.sh</span><br></pre></td></tr></table></figure>
<p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">uname -r</span></span><br></pre></td></tr></table></figure>
<p>查看内核版本，显示为最新版就表示 OK 了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sysctl</span> <span class="selector-tag">net</span><span class="selector-class">.ipv4</span><span class="selector-class">.tcp_available_congestion_control</span></span><br></pre></td></tr></table></figure>
<p>返回值一般为：<br>net.ipv4.tcp_available_congestion_control = bbr cubic reno<br>或者为：<br>net.ipv4.tcp_available_congestion_control = reno cubic bbr</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sysctl</span> <span class="selector-tag">net</span><span class="selector-class">.ipv4</span><span class="selector-class">.tcp_congestion_control</span></span><br></pre></td></tr></table></figure>
<p>返回值一般为：<br>net.ipv4.tcp_congestion_control = bbr</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sysctl</span> <span class="selector-tag">net</span><span class="selector-class">.core</span><span class="selector-class">.default_qdisc</span></span><br></pre></td></tr></table></figure>
<p>返回值一般为：<br>net.core.default_qdisc = fq</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">lsmod <span class="string">| grep bbr</span></span><br></pre></td></tr></table></figure>
<p>返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>
<h3 id="vps优化"><a href="#vps优化" class="headerlink" title="vps优化"></a>vps优化</h3><p>1、确认是否有SWAP，可以执行free -m 命令查看，如果有swap一行且total项下不为零的话就是存在swap，就不适合再进行添加swap。</p>
<p>2、以下以添加2GB SWAP为例，生成文件块：（SWAP一般设置为内存的2倍，并非完全以此为标准，只适合4GB以下内存，count后面的数为要设置的swap大小xxMB）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/zero <span class="attribute">of</span>=/var/swapfile <span class="attribute">bs</span>=1M <span class="attribute">count</span>=2048</span><br></pre></td></tr></table></figure>
<p>3、创建swap文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sbin/m</span>kswap <span class="regexp">/var/</span>swapfile</span><br></pre></td></tr></table></figure>
<p>4、激活swap文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sbin/</span>swapon <span class="regexp">/var/</span>swapfile</span><br></pre></td></tr></table></figure>
<p>5、查看一下swap是否正确：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sbin/</span>swapon -s</span><br></pre></td></tr></table></figure>
<p>另外为了安全建议执行：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">0600</span> <span class="regexp">/var/</span>swapfile</span><br></pre></td></tr></table></figure>
<p>改一下权限<br>6、到fstab文件中添加开机自动挂载设置</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>fstab</span><br></pre></td></tr></table></figure>
<p>在末尾增加以下内容：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">/var/swapfile <span class="keyword">swap</span> <span class="keyword">swap</span> defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>也可以执行如下命令，感觉这样更方便</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;/var/swapfile swap swap defaults 0 0&quot;</span> &gt;&gt;<span class="regexp">/etc/</span>fstab</span><br></pre></td></tr></table></figure>
<p>SWAP删除方法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sbin/</span>swapoff <span class="regexp">/var/</span>swapfile</span><br><span class="line">rm -f <span class="regexp">/var/</span>swapfile</span><br></pre></td></tr></table></figure>
<p>删掉添加的自动挂载swap的设置</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>fstab</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssr vps</tag>
      </tags>
  </entry>
  <entry>
    <title>openwrt-build</title>
    <url>/2018/11/22/openwrt-build/</url>
    <content><![CDATA[<h2 id="openwrt编译流程（vocore为例）"><a href="#openwrt编译流程（vocore为例）" class="headerlink" title="openwrt编译流程（vocore为例）"></a>openwrt编译流程（vocore为例）</h2><p>clone源码并解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://vonger.cn/misc/vocore2/openwrt.tar.bz2</span><br><span class="line">$ tar -jxvf openwrt.tar.bz2</span><br></pre></td></tr></table></figure>
<p>安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev libssl-dev python</span><br></pre></td></tr></table></figure>
<p>编译过程中会有报错缺少intltool这个工具执行以下命令安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install intltool</span><br></pre></td></tr></table></figure>
<p>更新并编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./scripts/feeds update -a</span><br><span class="line">$ ./scripts/feeds install -a</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make -j1 V=s</span><br></pre></td></tr></table></figure>
<h2 id="Makefile分析"><a href="#Makefile分析" class="headerlink" title="Makefile分析"></a>Makefile分析</h2><h3 id="主Makefile"><a href="#主Makefile" class="headerlink" title="主Makefile"></a>主Makefile</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TOPDIR:=<span class="variable">$&#123;CURDIR&#125;</span></span><br><span class="line">LC_ALL:=C</span><br><span class="line">LANG:=C</span><br><span class="line">TZ:=UTC</span><br><span class="line"><span class="built_in">export</span> TOPDIR LC_ALL LANG TZ</span><br><span class="line"></span><br><span class="line">empty:=</span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">$(<span class="keyword">if</span> $(findstring $(space),$(TOPDIR)),$(error ERROR: The path to the LEDE directory must not include any spaces))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置当前路径为编译顶层路径，将LC_ALL LANG设置为C并导出变量以在其他位置使用，同时openwrt路径不能包含空格路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">world:</span><br><span class="line"></span><br><span class="line">include $(TOPDIR)/include/host.mk</span><br><span class="line"></span><br><span class="line">ifneq ($(OPENWRT_BUILD),1)</span><br><span class="line">  _SINGLE=<span class="built_in">export</span> MAKEFLAGS=$(space);</span><br><span class="line"></span><br><span class="line">  override OPENWRT_BUILD=1</span><br><span class="line">  <span class="built_in">export</span> OPENWRT_BUILD</span><br><span class="line">  GREP_OPTIONS=</span><br><span class="line">  <span class="built_in">export</span> GREP_OPTIONS</span><br><span class="line">  include $(TOPDIR)/include/debug.mk</span><br><span class="line">  include $(TOPDIR)/include/depends.mk</span><br><span class="line">  include $(TOPDIR)/include/toplevel.mk</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  include rules.mk</span><br><span class="line">  include $(INCLUDE_DIR)/depends.mk</span><br><span class="line">  include $(INCLUDE_DIR)/subdir.mk</span><br><span class="line">  include target/Makefile</span><br><span class="line">  include package/Makefile</span><br><span class="line">  include tools/Makefile</span><br><span class="line">  include toolchain/Makefile</span><br><span class="line"></span><br><span class="line">$(toolchain/stamp-install): $(tools/stamp-install)</span><br><span class="line">$(target/stamp-compile): $(toolchain/stamp-install) $(tools/stamp-install) $(BUILD_DIR)/.prepared</span><br><span class="line">$(package/stamp-compile): $(target/stamp-compile) $(package/stamp-cleanup)</span><br><span class="line">$(package/stamp-install): $(package/stamp-compile)</span><br><span class="line">$(target/stamp-install): $(package/stamp-compile) $(package/stamp-install)</span><br><span class="line">check: $(tools/stamp-check) $(toolchain/stamp-check) $(package/stamp-check)</span><br></pre></td></tr></table></figure>
<p>这里目标word没有定义，是在include/topleve.mk文件里定义了，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifeq ($(SDK),1)</span><br><span class="line"></span><br><span class="line">%::</span><br><span class="line">	@+$(PREP_MK) $(NO_TRACE_MAKE) -r -s prereq</span><br><span class="line">	@./scripts/config/conf --defconfig=.config Config.in</span><br><span class="line">	@+$(ULIMIT_FIX) $(SUBMAKE) -r <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">%::</span><br><span class="line">	@+$(PREP_MK) $(NO_TRACE_MAKE) -r -s prereq</span><br><span class="line">	@( \</span><br><span class="line">		cp .config tmp/.config; \</span><br><span class="line">		./scripts/config/conf --defconfig=tmp/.config -w tmp/.config Config.in &gt; /dev/null 2&gt;&amp;1; \</span><br><span class="line">		<span class="keyword">if</span> ./scripts/kconfig.pl <span class="string">&#x27;&gt;&#x27;</span> .config tmp/.config | grep -q CONFIG; <span class="keyword">then</span> \</span><br><span class="line">			<span class="built_in">printf</span> <span class="string">&quot;<span class="subst">$(_R)</span>WARNING: your configuration is out of sync. Please run make menuconfig, oldconfig or defconfig!<span class="subst">$(_N)</span>\n&quot;</span> &gt;&amp;2; \</span><br><span class="line">		<span class="keyword">fi</span> \</span><br><span class="line">	)</span><br><span class="line">	@+$(ULIMIT_FIX) $(SUBMAKE) -r <span class="variable">$@</span> $(<span class="keyword">if</span> $(WARN_PARALLEL_ERROR), || &#123; \</span><br><span class="line">		<span class="built_in">printf</span> <span class="string">&quot;<span class="subst">$(_R)</span>Build failed - please re-run with -j1 to see the real error message<span class="subst">$(_N)</span>\n&quot;</span> &gt;&amp;2; \</span><br><span class="line">		<span class="literal">false</span>; \</span><br><span class="line">	&#125; )</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>%：：是为所有没有定义的目标匹配规则，其中NO_TRACE_MAKE := $(MAKE) V=s$(OPENWRT_VERBOSE)，PREP_MK= OPENWRT_BUILD= QUIET=0即当执行make V=s就化简为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@make V=s -r -s prereq</span><br><span class="line">@make -w -r world</span><br></pre></td></tr></table></figure>
<p>这会进入非第一次编译逻辑中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include rules.mk</span><br><span class="line">include $(INCLUDE_DIR)/depends.mk</span><br><span class="line">include $(INCLUDE_DIR)/subdir.mk</span><br><span class="line">include target/Makefile</span><br><span class="line">include package/Makefile</span><br><span class="line">include tools/Makefile</span><br><span class="line">include toolchain/Makefile</span><br></pre></td></tr></table></figure>
<p>其中subdir.mk文件中包含两个重要函数subdir和stampfile如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">define subdir</span><br><span class="line">  <span class="variable">$</span>(call warn,<span class="variable">$</span>(<span class="number">1</span>),d,D <span class="variable">$</span>(<span class="number">1</span>))</span><br><span class="line">  <span class="variable">$</span>(<span class="keyword">foreach</span> bd,<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/builddirs),</span><br><span class="line">    <span class="variable">$</span>(call warn,<span class="variable">$</span>(<span class="number">1</span>),d,BD <span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd))</span><br><span class="line">    <span class="variable">$</span>(<span class="keyword">foreach</span> target,<span class="variable">$</span>(SUBTARGETS),</span><br><span class="line">      <span class="variable">$</span>(<span class="keyword">foreach</span> btype,<span class="variable">$</span>(buildtypes-<span class="variable">$</span>(bd)),</span><br><span class="line">        <span class="variable">$</span>(call warn_eval,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd),t,T,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(btype)/<span class="variable">$</span>(target): <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(QUILT),,<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(btype)/<span class="variable">$</span>(target)) <span class="variable">$</span>(call <span class="variable">$</span>(<span class="number">1</span>)//<span class="variable">$</span>(btype)/<span class="variable">$</span>(target),<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(btype))))</span><br><span class="line">		  <span class="variable">$</span>(call log_make,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd),<span class="variable">$</span>(target),<span class="variable">$</span>(btype),<span class="variable">$</span>(<span class="keyword">filter</span><span class="literal">-out</span> __default,<span class="variable">$</span>(variant))) \</span><br><span class="line">			<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(findstring <span class="variable">$</span>(bd),<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/builddirs<span class="literal">-ignore</span>-<span class="variable">$</span>(btype)-<span class="variable">$</span>(target))), || <span class="variable">$</span>(call ERROR,<span class="variable">$</span>(<span class="number">1</span>),   ERROR: <span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd) [<span class="variable">$</span>(<span class="type">btype</span>)] failed to build.))</span><br><span class="line">        <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(call diralias,<span class="variable">$</span>(bd)),<span class="variable">$</span>(call warn_eval,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd),l,T,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(call diralias,<span class="variable">$</span>(bd))/<span class="variable">$</span>(btype)/<span class="variable">$</span>(target): <span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(btype)/<span class="variable">$</span>(target)))</span><br><span class="line">      )</span><br><span class="line">      <span class="variable">$</span>(call warn_eval,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd),t,T,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(target): <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(QUILT),,<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(target)) <span class="variable">$</span>(call <span class="variable">$</span>(<span class="number">1</span>)//<span class="variable">$</span>(target),<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd))))</span><br><span class="line">        <span class="variable">$</span>(<span class="keyword">foreach</span> variant,<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(BUILD_VARIANT),<span class="variable">$</span>(BUILD_VARIANT),<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(strip <span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/variants)),<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/variants),<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/default<span class="literal">-variant</span>),<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/default<span class="literal">-variant</span>),__default))),</span><br><span class="line">			<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(BUILD_LOG),@mkdir <span class="literal">-p</span> <span class="variable">$</span>(BUILD_LOG_DIR)/<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(<span class="keyword">filter</span><span class="literal">-out</span> __default,<span class="variable">$</span>(variant)))</span><br><span class="line">			<span class="variable">$</span>(call log_make,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd),<span class="variable">$</span>(target),,<span class="variable">$</span>(<span class="keyword">filter</span><span class="literal">-out</span> __default,<span class="variable">$</span>(variant))) \</span><br><span class="line">				<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(findstring <span class="variable">$</span>(bd),<span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/builddirs<span class="literal">-ignore</span>-<span class="variable">$</span>(target))), || <span class="variable">$</span>(call ERROR,<span class="variable">$</span>(<span class="number">1</span>),   ERROR: <span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd) failed to build<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(<span class="keyword">filter</span><span class="literal">-out</span> __default,<span class="variable">$</span>(variant)), (build variant: <span class="variable">$</span>(variant))).))</span><br><span class="line">        )</span><br><span class="line">      <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(PREREQ_ONLY)<span class="variable">$</span>(DUMP_TARGET_DB),,</span><br><span class="line">        <span class="comment"># aliases</span></span><br><span class="line">        <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(call diralias,<span class="variable">$</span>(bd)),<span class="variable">$</span>(call warn_eval,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd),l,T,<span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(call diralias,<span class="variable">$</span>(bd))/<span class="variable">$</span>(target): <span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(bd)/<span class="variable">$</span>(target)))</span><br><span class="line">	  )</span><br><span class="line">	)</span><br><span class="line">  )</span><br><span class="line">  <span class="variable">$</span>(<span class="keyword">foreach</span> target,<span class="variable">$</span>(SUBTARGETS),<span class="variable">$</span>(call subtarget,<span class="variable">$</span>(<span class="number">1</span>),<span class="variable">$</span>(target)))</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">ifndef DUMP_TARGET_DB</span><br><span class="line"><span class="comment"># Parameters: &lt;subdir&gt; &lt;name&gt; &lt;target&gt; &lt;depends&gt; &lt;config options&gt; &lt;stampfile location&gt;</span></span><br><span class="line">define stampfile</span><br><span class="line">  <span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>):=<span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(<span class="number">6</span>),<span class="variable">$</span>(<span class="number">6</span>),<span class="variable">$</span>(STAGING_DIR))/stamp/.<span class="variable">$</span>(<span class="number">2</span>)_<span class="variable">$</span>(<span class="number">3</span>)<span class="variable">$</span>(<span class="number">5</span>)</span><br><span class="line">  <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)): <span class="variable">$</span>(TMP_DIR)/.build <span class="variable">$</span>(<span class="number">4</span>)</span><br><span class="line">	<span class="selector-tag">@</span>+<span class="variable">$</span>(SCRIPT_DIR)/timestamp.pl <span class="literal">-n</span> <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)) <span class="variable">$</span>(<span class="number">1</span>) <span class="variable">$</span>(<span class="number">4</span>) || \</span><br><span class="line">		<span class="variable">$</span>(MAKE) <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(QUIET),-<span class="literal">-no</span><span class="literal">-print</span><span class="literal">-directory</span>) <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/flags-<span class="variable">$</span>(<span class="number">3</span>)) <span class="variable">$</span>(<span class="number">1</span>)/<span class="variable">$</span>(<span class="number">3</span>)</span><br><span class="line">	@mkdir <span class="literal">-p</span> <span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span>(dirname <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)))</span><br><span class="line">	@touch <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span><span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(call debug,<span class="variable">$</span>(<span class="number">1</span>),v),,.SILENT: <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">  .PRECIOUS: <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)) <span class="comment"># work around a make bug</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span>(<span class="number">1</span>)//clean:=<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)/clean</span><br><span class="line">  <span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>)/clean: FORCE</span><br><span class="line">	@<span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)/stamp-<span class="variable">$</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这两个函数比较复杂，我们以target/Makefile为例来分析subdir和stampfile函数。如下两条语句</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">eval</span> $(<span class="params">call</span> <span class="params">subdir</span>,$(<span class="params">curdir</span>)</span>))</span><br></pre></td></tr></table></figure>
<p>将其展开得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(call warn,target,d,D target)</span><br><span class="line"> $(foreach bd,$(target/builddirs),</span><br><span class="line">   $(call warn,target,d,BD target/$(bd))</span><br><span class="line">   $(foreach target,$(SUBTARGETS),</span><br><span class="line">     $(foreach btype,$(buildtypes-$(bd)),</span><br><span class="line">       $(call warn_eval,target/$(bd),t,T,target/$(bd)/$(btype)/$(target): $(<span class="keyword">if</span> $(QUILT),,$(target/$(bd)/$(btype)/$(target)) $(call target//$(btype)/$(target),target/$(bd)/$(btype))))</span><br><span class="line">	  $(call log_make,target/$(bd),$(target),$(btype),$(filter-out __default,$(variant))) \</span><br><span class="line">		$(<span class="keyword">if</span> $(findstring $(bd),$(target/builddirs-ignore-$(btype)-$(target))), || $(call ERROR,target,   ERROR: target/$(bd) [$(btype)] failed to build.))</span><br><span class="line">       $(<span class="keyword">if</span> $(call diralias,$(bd)),$(call warn_eval,target/$(bd),l,T,target/$(call diralias,$(bd))/$(btype)/$(target): target/$(bd)/$(btype)/$(target)))</span><br><span class="line">     )</span><br><span class="line">     $(call warn_eval,target/$(bd),t,T,target/$(bd)/$(target): $(<span class="keyword">if</span> $(QUILT),,$(target/$(bd)/$(target)) $(call target//$(target),target/$(bd))))</span><br><span class="line">       $(foreach variant,$(<span class="keyword">if</span> $(BUILD_VARIANT),$(BUILD_VARIANT),$(<span class="keyword">if</span> $(strip $(target/$(bd)/variants)),$(target/$(bd)/variants),$(<span class="keyword">if</span> $(target/$(bd)/default-variant),$(target/$(bd)/default-variant),__default))),</span><br><span class="line">		$(<span class="keyword">if</span> $(BUILD_LOG),@mkdir -p $(BUILD_LOG_DIR)/target/$(bd)/$(filter-out __default,$(variant)))</span><br><span class="line">		$(call log_make,target/$(bd),$(target),,$(filter-out __default,$(variant))) \</span><br><span class="line">			$(<span class="keyword">if</span> $(findstring $(bd),$(target/builddirs-ignore-$(target))), || $(call ERROR,target,   ERROR: target/$(bd) failed to build$(<span class="keyword">if</span> $(filter-out __default,$(variant)), (build variant: $(variant))).))</span><br><span class="line">       )</span><br><span class="line">     $(<span class="keyword">if</span> $(PREREQ_ONLY)$(DUMP_TARGET_DB),,</span><br><span class="line">       <span class="comment"># aliases</span></span><br><span class="line">       $(<span class="keyword">if</span> $(call diralias,$(bd)),$(call warn_eval,target/$(bd),l,T,target/$(call diralias,$(bd))/$(target): target/$(bd)/$(target)))</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"> )</span><br><span class="line"> $(foreach target,$(SUBTARGETS),$(call subtarget,target,$(target)))</span><br></pre></td></tr></table></figure>
<p> stampfile函数就是生成target/stamp-prereq规则而subdir函数则是进入子目录执行make -C操作。这样Makefile就通过这两个函数生成子目录构建规则和进入子目录进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  printdb:</span><br><span class="line">	@<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">prepare: $(target/stamp-compile)</span><br><span class="line"></span><br><span class="line">clean: FORCE</span><br><span class="line">	rm -rf $(BUILD_DIR) $(STAGING_DIR) $(BIN_DIR) $(OUTPUT_DIR)/packages/$(ARCH_PACKAGES) $(BUILD_LOG_DIR) $(TOPDIR)/staging_dir/packages</span><br><span class="line"></span><br><span class="line">dirclean: clean</span><br><span class="line">	rm -rf $(STAGING_DIR_HOST) $(TOOLCHAIN_DIR) $(BUILD_DIR_HOST) $(BUILD_DIR_TOOLCHAIN)</span><br><span class="line">	rm -rf $(TMP_DIR)</span><br></pre></td></tr></table></figure>
<p>定义一些规则。比较重要的是clean和distclean删除编译过程中的一些文件，distclean依赖clean命令会先执行clean命令之后再删除剩余的编译过程文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifndef DUMP_TARGET_DB</span><br><span class="line">$(BUILD_DIR)/.prepared: Makefile</span><br><span class="line">	@mkdir -p $$(dirname <span class="variable">$@</span>)</span><br><span class="line">	@touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">tmp/.prereq_packages: .config</span><br><span class="line">	<span class="built_in">unset</span> ERROR; \</span><br><span class="line">	<span class="keyword">for</span> package <span class="keyword">in</span> $(sort $(prereq-y) $(prereq-m)); <span class="keyword">do</span> \</span><br><span class="line">		$(_SINGLE)$(NO_TRACE_MAKE) -s -r -C package/$<span class="variable">$package</span> prereq || ERROR=1; \</span><br><span class="line">	<span class="keyword">done</span>; \</span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">&quot;$<span class="variable">$ERROR</span>&quot;</span> ]; <span class="keyword">then</span> \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Package prerequisite check failed.&quot;</span>; \</span><br><span class="line">		<span class="literal">false</span>; \</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	touch <span class="variable">$@</span></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>tmp/.prereq_packages目标是对所需软件包的预处理。目标依赖于.config，即执行make menuconfig后将会进行一次所需软件包的预处理。本次编译后tmp/.prereq_packages文件为空，并没有生成什么</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># check prerequisites before starting to build</span></span><br><span class="line">prereq: $(target/stamp-prereq) tmp/.prereq_packages</span><br><span class="line">	@<span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="subst">$(INCLUDE_DIR)</span>/site/<span class="subst">$(ARCH)</span>&quot;</span> ]; <span class="keyword">then</span> \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;ERROR: Missing site config for architecture &quot;$(ARCH)&quot; !&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;       The missing file will cause configure scripts to fail during compilation.&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;       Please provide a &quot;$(INCLUDE_DIR)/site/$(ARCH)&quot; file and restart the build.&#x27;</span>; \</span><br><span class="line">		<span class="built_in">exit</span> 1; \</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">checksum: FORCE</span><br><span class="line">	$(call sha256sums,$(BIN_DIR))</span><br><span class="line"></span><br><span class="line">diffconfig: FORCE</span><br><span class="line">	mkdir -p $(BIN_DIR)</span><br><span class="line">	$(SCRIPT_DIR)/diffconfig.sh &gt; $(BIN_DIR)/config.seed</span><br><span class="line"></span><br><span class="line">prepare: .config $(tools/stamp-install) $(toolchain/stamp-install)</span><br><span class="line">world: prepare $(target/stamp-compile) $(package/stamp-compile) $(package/stamp-install) $(target/stamp-install) FORCE</span><br><span class="line">	$(_SINGLE)$(SUBMAKE) -r package/index</span><br><span class="line">	$(_SINGLE)$(SUBMAKE) -r diffconfig</span><br><span class="line">	$(_SINGLE)$(SUBMAKE) -r checksum</span><br><span class="line"></span><br><span class="line">.PHONY: clean dirclean prereq prepare world package/symlinks package/symlinks-install package/symlinks-clean</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>prereq编译前的检查如果$(INCLUDE_DIR)/site/$(ARCH)不是常规文件打印提示信息然后返回。checksum对目标文件进行sha256校验。word为目标文件。PHONY说明clean dirclean prereq prepareworld package/symlinks package/symlinks-installpackage/symlinks-clean属于伪目标。</p>
<p>这样主Makefile就分析完了，其实就是构建了world目标，并生成依赖，然后调用其他目录下的Makefile，这些Makefile再调用subdir和stampfile函数进行子目录的构建，从而完成整个系统的构建。</p>
<h3 id="kernel的构建"><a href="#kernel的构建" class="headerlink" title="kernel的构建"></a>kernel的构建</h3><p>以mtk芯片为例简单分析一下kernel的编译，其Makefile在/target/linux/ramips/Makefile文件中，最关键的一句是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">eval</span> $(call BuildTarget))</span><br></pre></td></tr></table></figure>
<p>在include $(INCLUDE_DIR)/target.mk文件中定义如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_BUILD)</span>,1)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(INCLUDE_DIR)</span>/kernel-build.mk</span><br><span class="line">  BuildTarget?=<span class="variable">$(BuildKernel)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>BuildKernel可以通过include $(INCLUDE_DIR)/kernel-build.mk这句找到，其定义如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">define BuildKernel</span><br><span class="line">  <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(QUILT),<span class="variable">$</span>(Build/Quilt))</span><br><span class="line">  <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(LINUX_SITE),<span class="variable">$</span>(call Download,kernel))	//下载内核</span><br><span class="line">  <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(call qstrip,<span class="variable">$</span>(CONFIG_KERNEL_GIT_CLONE_URI)),<span class="variable">$</span>(call Download,git<span class="literal">-kernel</span>))	//通过git clone</span><br><span class="line"></span><br><span class="line">  .NOTPARALLEL:</span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span>(Kernel/Autoclean)			//删除buidir目录重新构建</span><br><span class="line">  <span class="variable">$</span>(STAMP_PREPARED): <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(LINUX_SITE),<span class="variable">$</span>(DL_DIR)/<span class="variable">$</span>(LINUX_SOURCE))</span><br><span class="line">	<span class="literal">-rm</span> <span class="literal">-rf</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)</span><br><span class="line">	<span class="literal">-mkdir</span> <span class="literal">-p</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)</span><br><span class="line">	<span class="variable">$</span>(Kernel/Prepare)</span><br><span class="line">	touch <span class="variable">$</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span>(KERNEL_BUILD_DIR)/symtab.h: FORCE</span><br><span class="line">	<span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/symtab.h</span><br><span class="line">	touch <span class="variable">$</span>(KERNEL_BUILD_DIR)/symtab.h</span><br><span class="line">	+<span class="variable">$</span>(MAKE) <span class="variable">$</span>(KERNEL_MAKEOPTS) vmlinux		//构建vmlinux</span><br><span class="line">	find <span class="variable">$</span>(LINUX_DIR) <span class="variable">$</span>(STAGING_DIR_ROOT)/lib/modules <span class="literal">-name</span> \*.ko | \</span><br><span class="line">		xargs <span class="variable">$</span>(TARGET_CROSS)nm | \</span><br><span class="line">		awk <span class="string">&#x27;$$$$1 == &quot;U&quot; &#123; print $$$$2 &#125; &#x27;</span> | \</span><br><span class="line">		<span class="built_in">sort</span> <span class="literal">-u</span> &gt; <span class="variable">$</span>(KERNEL_BUILD_DIR)/mod_symtab.txt</span><br><span class="line">	<span class="variable">$</span>(TARGET_CROSS)nm <span class="literal">-n</span> <span class="variable">$</span>(LINUX_DIR)/vmlinux.o | grep <span class="string">&#x27; [rR] __ksymtab&#x27;</span> | sed <span class="literal">-e</span> <span class="string">&#x27;s,........ [rR] __ksymtab_,,&#x27;</span> &gt; <span class="variable">$</span>(KERNEL_BUILD_DIR)/kernel_symtab.txt 		//构建vmlinux</span><br><span class="line">	grep <span class="literal">-Ff</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/mod_symtab.txt <span class="variable">$</span>(KERNEL_BUILD_DIR)/kernel_symtab.txt &gt; <span class="variable">$</span>(KERNEL_BUILD_DIR)/sym_include.txt</span><br><span class="line">	grep <span class="literal">-Fvf</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/mod_symtab.txt <span class="variable">$</span>(KERNEL_BUILD_DIR)/kernel_symtab.txt &gt; <span class="variable">$</span>(KERNEL_BUILD_DIR)/sym_exclude.txt</span><br><span class="line">	( \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;#define SYMTAB_KEEP \&#x27;</span>; \</span><br><span class="line">		<span class="built_in">cat</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/sym_include.txt | \</span><br><span class="line">			awk <span class="string">&#x27;&#123;print &quot;KEEP(*(___ksymtab+&quot; $$$$1 &quot;)) \\&quot; &#125;&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;#define SYMTAB_KEEP_GPL \&#x27;</span>; \</span><br><span class="line">		<span class="built_in">cat</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/sym_include.txt | \</span><br><span class="line">			awk <span class="string">&#x27;&#123;print &quot;KEEP(*(___ksymtab_gpl+&quot; $$$$1 &quot;)) \\&quot; &#125;&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;#define SYMTAB_DISCARD \&#x27;</span>; \</span><br><span class="line">		<span class="built_in">cat</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/sym_exclude.txt | \</span><br><span class="line">			awk <span class="string">&#x27;&#123;print &quot;*(___ksymtab+&quot; $$$$1 &quot;) \\&quot; &#125;&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;#define SYMTAB_DISCARD_GPL \&#x27;</span>; \</span><br><span class="line">		<span class="built_in">cat</span> <span class="variable">$</span>(KERNEL_BUILD_DIR)/sym_exclude.txt | \</span><br><span class="line">			awk <span class="string">&#x27;&#123;print &quot;*(___ksymtab_gpl+&quot; $$$$1 &quot;) \\&quot; &#125;&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span>; \</span><br><span class="line">	) &gt; <span class="variable">$</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span>(STAMP_CONFIGURED): <span class="variable">$</span>(STAMP_PREPARED) <span class="variable">$</span>(LINUX_KCONFIG_LIST) <span class="variable">$</span>(TOPDIR)/.config FORCE</span><br><span class="line">	<span class="variable">$</span>(Kernel/Configure)</span><br><span class="line">	touch <span class="variable">$</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span>(LINUX_DIR)/.modules: <span class="variable">$</span>(STAMP_CONFIGURED) <span class="variable">$</span>(LINUX_DIR)/.config FORCE</span><br><span class="line">	<span class="variable">$</span>(Kernel/CompileModules)</span><br><span class="line">	touch <span class="variable">$</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$</span>(LINUX_DIR)/.image: <span class="variable">$</span>(STAMP_CONFIGURED) <span class="variable">$</span>(<span class="keyword">if</span> <span class="variable">$</span>(CONFIG_STRIP_KERNEL_EXPORTS),<span class="variable">$</span>(KERNEL_BUILD_DIR)/symtab.h) FORCE</span><br><span class="line">	<span class="variable">$</span>(Kernel/CompileImage)</span><br><span class="line">	<span class="variable">$</span>(Kernel/CollectDebug)</span><br><span class="line">	touch <span class="variable">$</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line">	</span><br><span class="line">  mostlyclean: FORCE</span><br><span class="line">	<span class="variable">$</span>(Kernel/Clean)</span><br><span class="line"></span><br><span class="line">  define BuildKernel</span><br><span class="line">  endef</span><br></pre></td></tr></table></figure>
<p>  这里定义了一些列构建规则包括获取源码，自动清除和构建vmlinux，kernel-build.mk这个文件是关于如何构建linux kernel的，除了BuildKernel的定义外还有就是以下关键内容</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">compile</span>: $(LINUX_DIR)/.modules</span><br><span class="line">$(<span class="built_in">MAKE</span>) -C image <span class="keyword">compile</span> TARGET_BUILD=</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建image compile TARGET_BUILD</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">oldconfig menuconfig nconfig: <span class="variable">$</span>(STAMP_PREPARED) <span class="variable">$</span>(STAMP_CHECKED) FORCE</span><br><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span>(LINUX_DIR)/.config.prev</span><br><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span>(STAMP_CONFIGURED)</span><br><span class="line"><span class="variable">$</span>(LINUX_RECONF_CMD) &gt; <span class="variable">$</span>(LINUX_DIR)/.config</span><br><span class="line"><span class="variable">$</span>(_SINGLE)<span class="variable">$</span>(MAKE) <span class="literal">-C</span> <span class="variable">$</span>(LINUX_DIR) <span class="variable">$</span>(KERNEL_MAKEOPTS) HOST_LOADLIBES=<span class="string">&quot;-L<span class="variable">$</span>(STAGING_DIR_HOST)/lib -lncurses&quot;</span> <span class="variable">$</span><span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"><span class="variable">$</span>(LINUX_RECONF_DIFF) <span class="variable">$</span>(LINUX_DIR)/.config &gt; <span class="variable">$</span>(LINUX_RECONFIG_TARGET)</span><br></pre></td></tr></table></figure>
<p>配置内核模块</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"> install: $(LINUX_DIR)/.<span class="keyword">image</span></span><br><span class="line">+$(MAKE) -C <span class="keyword">image</span> compile install TARGET_BUILD=</span><br></pre></td></tr></table></figure>
<p>生成vmlinux</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">clean: FORCE</span><br><span class="line">rm -rf $(KERNEL_BUILD_DIR)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">image</span>-prereq:</span><br><span class="line">@+$(NO_TRACE_MAKE) -s -C <span class="keyword">image</span> prereq TARGET_BUILD=</span><br><span class="line"></span><br><span class="line"> prereq: <span class="keyword">image</span>-prereq</span><br></pre></td></tr></table></figure>
<p> 还有一些其他操作clean清除之类的；这里主要完成kernel的构建生成vmlinux</p>
<h3 id="生成bin格式的firmware"><a href="#生成bin格式的firmware" class="headerlink" title="生成bin格式的firmware"></a>生成bin格式的firmware</h3><p> firmware由vmlinux和rootfs两部分组成。”target/linux/ramips/image/Makefile” 文件中的最后一句：$(eval $(call BuildImage))，将BuildImage展开在这里。BuildImage定义在 include/image.mk 文件中，其中定义了数个目标的规则。<br> <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> define BuildImage</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  ifeq (<span class="constructor">$(IB)</span>,)</span><br><span class="line">    .PHONY: download prepare compile clean image_prepare kernel_prepare install install-images</span><br><span class="line">    compile:</span><br><span class="line">		<span class="constructor">$(<span class="params">call</span> Build<span class="operator">/</span>Compile)</span></span><br><span class="line"></span><br><span class="line">    clean:</span><br><span class="line">		<span class="constructor">$(<span class="params">call</span> Build<span class="operator">/</span>Clean)</span></span><br><span class="line"></span><br><span class="line">    image_prepare: compile</span><br><span class="line">		mkdir -p <span class="constructor">$(BIN_DIR)</span> <span class="constructor">$(KDIR)</span>/tmp</span><br><span class="line">		<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>Prepare)</span></span><br><span class="line"></span><br><span class="line">    legacy-images-prepare-make: image_prepare</span><br><span class="line">		<span class="constructor">$(MAKE)</span> legacy-images-prepare</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    image_prepare:</span><br><span class="line">		mkdir -p <span class="constructor">$(BIN_DIR)</span> <span class="constructor">$(KDIR)</span>/tmp</span><br><span class="line">  endif</span><br><span class="line"></span><br><span class="line">  kernel_prepare: image_prepare</span><br><span class="line">	<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>Build<span class="operator">/</span><span class="params">targz</span>)</span></span><br><span class="line">	<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>Build<span class="operator">/</span><span class="params">cpiogz</span>)</span></span><br><span class="line">	<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>BuildKernel)</span>	<span class="comment">//处理vmlinux</span></span><br><span class="line">	<span class="constructor">$(<span class="params">if</span> $(CONFIG_TARGET_ROOTFS_INITRAMFS)</span>,<span class="constructor">$(<span class="params">if</span> $(IB)</span>,,<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>BuildKernel<span class="operator">/</span>Initramfs)</span>))</span><br><span class="line">	<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>InstallKernel)</span></span><br><span class="line"></span><br><span class="line">  <span class="constructor">$(<span class="params">foreach</span> <span class="params">device</span>,$(TARGET_DEVICES)</span>,<span class="constructor">$(<span class="params">call</span> Device,$(<span class="params">device</span>)</span>))</span><br><span class="line">  <span class="constructor">$(<span class="params">foreach</span> <span class="params">device</span>,$(LEGACY_DEVICES)</span>,<span class="constructor">$(<span class="params">call</span> LegacyDevice,$(<span class="params">device</span>)</span>))</span><br><span class="line"></span><br><span class="line">  install-images: kernel_prepare <span class="constructor">$(<span class="params">foreach</span> <span class="params">fs</span>,$(<span class="params">filter</span>-<span class="params">out</span> $(<span class="params">if</span> $(UBIFS_OPTS)</span>,,ubifs),<span class="constructor">$(TARGET_FILESYSTEMS)</span> <span class="constructor">$(<span class="params">fs</span>-<span class="params">subtypes</span>-<span class="params">y</span>)</span>),<span class="constructor">$(KDIR)</span>/root.<span class="constructor">$(<span class="params">fs</span>)</span>)</span><br><span class="line">	<span class="constructor">$(<span class="params">foreach</span> <span class="params">fs</span>,$(TARGET_FILESYSTEMS)</span>,</span><br><span class="line">		<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>Build,$(<span class="params">fs</span>)</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">  legacy-images-make: install-images</span><br><span class="line">	<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span><span class="params">mkfs</span><span class="operator">/</span><span class="params">ubifs</span><span class="operator">/</span><span class="params">legacy</span>)</span></span><br><span class="line">	<span class="constructor">$(MAKE)</span> legacy-images</span><br><span class="line"></span><br><span class="line">  install: install-images</span><br><span class="line">	<span class="constructor">$(<span class="params">call</span> Image<span class="operator">/</span>Manifest)</span></span><br><span class="line"></span><br><span class="line">endef</span><br></pre></td></tr></table></figure><br>最终生成bin文件的Makefile在/target/linux/ramips/image/Makefile文件里</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> Image/BuildKernel</span><br><span class="line">	cp <span class="variable">$(KDIR)</span>/vmlinux.elf <span class="variable">$(BIN_DIR)</span>/<span class="variable">$(VMLINUX)</span>.elf</span><br><span class="line">	cp <span class="variable">$(KDIR)</span>/vmlinux <span class="variable">$(BIN_DIR)</span>/<span class="variable">$(VMLINUX)</span>.bin</span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> CompressLzma,<span class="variable">$(KDIR)</span>/vmlinux,<span class="variable">$(KDIR)</span>/vmlinux.bin.lzma)</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> MkImage,lzma,<span class="variable">$(KDIR)</span>/vmlinux.bin.lzma,<span class="variable">$(KDIR)</span>/uImage.lzma)</span></span><br><span class="line">	cp <span class="variable">$(KDIR)</span>/uImage.lzma <span class="variable">$(BIN_DIR)</span>/<span class="variable">$(UIMAGE)</span>.bin</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>该文件对文件系统和vmlinx进行组合，对内核进行压缩最后得到需要的固件。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
      </tags>
  </entry>
  <entry>
    <title>openwrt-feeds</title>
    <url>/2018/11/23/openwrt-feeds/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>feeds是一个软件包的集合,他可以位于远程服务器,本地文件或其他位置,openwrt自带了很多feeds软件包,包括luci,routing,telephony,packages等.构建过程中可以通过feeds命令下载和安装这些软件包,其配置文件为feeds.conf,默认配置文件为feeds.conf.default,可以在里面配置我们自己的软件包.<br>例如openwrt默认配置文件是这样的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">src-git</span> <span class="selector-tag">packages</span> <span class="selector-tag">https</span>://<span class="selector-tag">git</span><span class="selector-class">.openwrt</span><span class="selector-class">.org</span>/<span class="selector-tag">feed</span>/<span class="selector-tag">packages</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-tag">src-git</span> <span class="selector-tag">luci</span> <span class="selector-tag">https</span>://<span class="selector-tag">git</span><span class="selector-class">.openwrt</span><span class="selector-class">.org</span>/<span class="selector-tag">project</span>/<span class="selector-tag">luci</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-tag">src-git</span> <span class="selector-tag">routing</span> <span class="selector-tag">https</span>://<span class="selector-tag">git</span><span class="selector-class">.openwrt</span><span class="selector-class">.org</span>/<span class="selector-tag">feed</span>/<span class="selector-tag">routing</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-tag">src-git</span> <span class="selector-tag">telephony</span> <span class="selector-tag">https</span>://<span class="selector-tag">git</span><span class="selector-class">.openwrt</span><span class="selector-class">.org</span>/<span class="selector-tag">feed</span>/<span class="selector-tag">telephony</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-id">#src-git</span> <span class="selector-tag">video</span> <span class="selector-tag">https</span>://<span class="selector-tag">github</span><span class="selector-class">.com</span>/<span class="selector-tag">openwrt</span>/<span class="selector-tag">video</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-id">#src-git</span> <span class="selector-tag">targets</span> <span class="selector-tag">https</span>://<span class="selector-tag">github</span><span class="selector-class">.com</span>/<span class="selector-tag">openwrt</span>/<span class="selector-tag">targets</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-id">#src-git</span> <span class="selector-tag">management</span> <span class="selector-tag">https</span>://<span class="selector-tag">github</span><span class="selector-class">.com</span>/<span class="selector-tag">openwrt-management</span>/<span class="selector-tag">packages</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-id">#src-git</span> <span class="selector-tag">oldpackages</span> <span class="selector-tag">http</span>://<span class="selector-tag">git</span><span class="selector-class">.openwrt</span><span class="selector-class">.org</span>/<span class="selector-tag">packages</span><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-id">#src-link</span> <span class="selector-tag">custom</span> /<span class="selector-tag">usr</span>/<span class="selector-tag">src</span>/<span class="selector-tag">openwrt</span>/<span class="selector-tag">custom-feed</span></span><br></pre></td></tr></table></figure>
<p>#是注释,src-git代表代码在git仓库里通过git方式获取软件包,packages等是软件包下载到本地后的 文件夹名称,再之后是代码仓库地址,在通过git方式获取代码时有时需要指定分支名称,以第一个为例添加master分支修改为:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">src-git packages https:<span class="regexp">//gi</span>t.openwrt.org<span class="regexp">/feed/</span>packages.git:master</span><br></pre></td></tr></table></figure>
<p>这样就指定了代码分支,link是连接本地文件后面跟代码路径,还有svn是通过svn获取代码,具体在openwrt官网上给出具体介绍如下<br><img src="/picture/feeds1.png" alt="feeds格式"></p>
<h3 id="feed命令"><a href="#feed命令" class="headerlink" title="feed命令"></a>feed命令</h3><p><strong>update</strong><br>通过OpenWrt根目录下的scripts/feeds脚本文件使用feeds,大多数命令需要从本地获取信息,因此首先需要更新,scripts/feeds update -a更新所有,也可以指定只更新一个文件,例如</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="class">scripts</span></span>/<span class="variable">feeds</span> <span class="variable">update</span> <span class="variable">luci</span></span><br></pre></td></tr></table></figure>
<p><strong>install</strong><br>只更新luci这一个软件包通过install命令安装所有下载下来的软件包以及软件包的依赖,安装过程包括创建从 packages/feeds/$feed_name/$package_name到feeds/$feed_name/$package_name的软件接,以便于编译过程中编译package时会通过软连接去编译feeds目录下的软件包.feeds安装命令如下:<br><img src="/picture/feeds2.png" alt="install command"><br><strong>list</strong><br>下载下来的文件会有一个以.index为后缀名的文件那个是软件包的索引文件,list命令就是通过这个index后缀名的文件将软件包列出来.<br><strong>uninstall及clean</strong><br>uninstall卸载软件包,只是移除了软连接.clean是删除本地feeds目录下的软件包以及索引文件.</p>
<h3 id="添加自己的软接包"><a href="#添加自己的软接包" class="headerlink" title="添加自己的软接包"></a>添加自己的软接包</h3><p>修改feeds.conf文件添加自己的代码路径及获取方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">src-git</span> <span class="selector-tag">your_package_name</span> <span class="selector-tag">url</span><span class="selector-pseudo">:branch</span></span><br></pre></td></tr></table></figure>
<p>把相关package添加到config文件编译就可以了.</p>
<h3 id="package相关"><a href="#package相关" class="headerlink" title="package相关"></a>package相关</h3><p>这里以添加一个较为常用的lrzsz软件包为例来说明构建一个package的过程,一般一个package里包含三个文件Makefile,patches,files.Makefile提供获取软件包的命令,包名称等一系列内容,其他两项是可选的其中patches一般包含的是补丁文件,针对源码存在的bug进行添加补丁,files目录下包含一些针对该软件的默认配置及启动脚本等文件.lrzsz的makefile文件如下:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> $(TOPDIR)/rules.mk</span><br><span class="line"></span><br><span class="line">PKG_NAME:=lrzsz</span><br><span class="line">PKG_VERSION:=<span class="number">0.12</span>.<span class="number">20</span></span><br><span class="line">PKG_RELEASE:=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">PKG_SOURCE:=$&#123;PKG_NAME&#125;-$&#123;PKG_VERSION&#125;.tar.gz</span><br><span class="line">PKG_SOURCE_URL:=https:<span class="comment">//ohse.de/uwe/releases/</span></span><br><span class="line">PKG_MD5SUM:=b5ce6a74abc9b9eb2af94dffdfd372a4</span><br><span class="line"></span><br><span class="line">PKG_MAINTAINER:=Bruno Randolf &lt;ohse.de@gnu.org&gt;</span><br><span class="line">PKG_LICENSE:=GPL-<span class="number">2.0</span></span><br><span class="line">PKG_LICENSE_FILES:=COPYING</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> $(INCLUDE_DIR)/<span class="keyword">package</span>.mk</span><br><span class="line"></span><br><span class="line">define <span class="keyword">Package</span><span class="regexp">/lrzsz/</span><span class="keyword">Default</span></span><br><span class="line">  SECTION:=Applications</span><br><span class="line">  CATEGORY:=apps</span><br><span class="line">  URL:=https:<span class="comment">//ohse.de/uwe/software/lrzsz.html</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define <span class="keyword">Package</span>/lrzsz</span><br><span class="line">  $(<span class="keyword">call</span> <span class="keyword">Package</span><span class="regexp">/lrzsz/</span><span class="keyword">Default</span>)</span><br><span class="line">  TITLE:=Linux z-mode transport</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define <span class="keyword">Package</span><span class="regexp">/lrzsz/</span><span class="keyword">description</span></span><br><span class="line"> lrzsz is a language that supports arbitrary precision numbers with</span><br><span class="line"> interactive execution of statements.</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define <span class="keyword">Package</span><span class="regexp">/lrzsz/i</span>nstall</span><br><span class="line">	$(INSTALL_DIR) $(<span class="number">1</span>)<span class="regexp">/usr/</span>bin</span><br><span class="line">	$(INSTALL_BIN) $(PKG_BUILD_DIR)<span class="regexp">/src/</span>lrz $(<span class="number">1</span>)<span class="regexp">/usr/</span>bin/rz</span><br><span class="line">	$(INSTALL_BIN) $(PKG_BUILD_DIR)<span class="regexp">/src/</span>lsz $(<span class="number">1</span>)<span class="regexp">/usr/</span>bin/sz</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">$(eval $(<span class="keyword">call</span> BuildPackage,lrzsz))</span><br></pre></td></tr></table></figure>
<ul>
<li>PKG_NAME - 定义这个包的名字，在menucongfig中看到的包名字就是这里指定的。</li>
<li>PKG_VERSION - 定义了我们要下载的软件的上游版本号。</li>
<li>PKG_RELEASE - 这个包的Makefile版本号，可以理解为OpenWrt自己对每个pacakge赋予的版本。</li>
<li>PKG_LICENSE - 这个包的授权协议，一般都来自上游软件商。</li>
<li>PKG_LICENSE_FILE - 描述授权协议的文件。</li>
<li>PKG_BUILD_DIR - 将要在那个位置存储并编译这个包的软件源码。</li>
<li>PKG_SOURCE - 这个包的原始码的文件名。</li>
<li>PKG_SOURCE_URL - 从哪里下载这个包的源码。</li>
<li>PKG_MD5SUM - 用于验证所下载内容的校验码，可以使MD5或者SHA256其中之一。</li>
<li>PKG_CAT - 定义要用哪种方式压缩并释放原始码（zcat，bzcat，还是unzip）</li>
<li>PKG_BUILD_DEPENDS - 定义这要编译这个包之前必须先编译的包，也就是这个包在编译过程的依赖包，运行时不一定需要。一般而言都是一些提供链接时的依赖库或者头文件等的包，使用的语法和后面要说到的DEPENDS相同。</li>
<li>PKG_INSTALL - 如果将这个变量设置为1，将会调用这个软件原代码中的原生make install，并将prefix设置为PKG_INSTALL_DIR的值。</li>
<li>PKG_INSTALL_DIR - 定义了make install将会把编译好的文件拷贝到哪里。</li>
<li>PKG_FIXUP - 这个变量的含义后面会详述，请参见下面的内容。</li>
<li>PKG_SOURCE_PROTO - 定义了用于获取原始代码的协议（git，svn）</li>
<li>PKG_REV - svn revision要用的到，如果proto是svn时必须指定。</li>
<li>PKG_SOURCE_SUBDIR - 如果proto是svn或者git必须要指定这个，如：PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)</li>
<li>PKG_SOURCE_VERSION - 如果proto是git必须指定这个，表示git中的commit hash（一个tag名或者commit id），用于git的checkout操作。</li>
<li>PKG_CONFIG_DEPENDS - 指定了哪些依赖这个包的配置选项将被选中。</li>
</ul>
<p>一般makefile文件的写法参考已有的软件包进行写.其他软件包可以以相同方式进行添加.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
      </tags>
  </entry>
  <entry>
    <title>openwrt-hardware</title>
    <url>/2018/11/22/openwrt-hardware/</url>
    <content><![CDATA[<h3 id="mt7628an-Soc特性"><a href="#mt7628an-Soc特性" class="headerlink" title="mt7628an Soc特性"></a>mt7628an Soc特性</h3><p>嵌入式MIPS24KEc(575/580 MHz)，具有64 KB的iCache和32 KB的D-Cache；</p>
<p>2T2R 2.4 GHz和300 Mbps PHY数据速率；</p>
<p>传统802.11b/g和HT802.11n模式；</p>
<p>20/40 MHz信道带宽；</p>
<p>反向数据授予(RDG)；</p>
<p>MCM 8 Mbytes DDR1 KGD (MT7628KN)；</p>
<p>16位DDR 1/2最多128/256 Mbytes(MT7628AN/KN)；</p>
<p>SPI/SD-XC/eMMC；</p>
<p>支持I2C, I2S, SPI, PCM, UART, JTAG, GPIO；</p>
<p>支持WEP64/128, TKIP, AES, WPA, WPA2, WAPI<br><img src="/picture/mt7628.png" alt="mt7628系统框图"><br>可以看到该处理器集成了Switch芯片、Wi-Fi芯片，以及其他常用接口是典型的SOC设计。5portPHY通过switch连接PDMA，2.4G支持双天线2T2R模式。因此在硬件设计时不需要太多外部器件，外接一个spiflash和一个ddr内存就足以让系统跑起来.</p>
<h3 id="HDK分析"><a href="#HDK分析" class="headerlink" title="HDK分析"></a>HDK分析</h3><p><strong>电源模块</strong><br><img src="/picture/power1.png" alt="整体电源结构"><br>12V2A的DC外部供电,然后经过两个AP3503H芯片分别将12V转化为5V和3.3V,其原理图如下:<br><img src="/picture/ap3503h.png" alt="AP3503H"><br>3.3V经过ap2127转化为1.2V,如下<br><img src="/picture/ap2127.png" alt="AP2127"><br>5v经过ap3418转化为1.14v,如下<br><img src="/picture/ap3418.png" alt="AP3418"><br>当然还有一些其他器件共同构成了整个电源电路.<br><strong>WIFI模块</strong><br>5G芯片选择的是MT7612E该芯片通过PCIe接口与MT7621A连接,同时MT7612E和MT7603E又与PA和LAN芯连接并外接天线,构成了整个WIFI模块.系统框图如下:<br><img src="/picture/wifi.png" alt="WIFI"><br><strong>以太网</strong><br>主控芯片通过网络变压器与RJ45连接,接网络变压器，主要用于信号电平耦合，其一增强信号驱动能力，可以传输更远的距离；其二，芯片端与外部隔离，抗干扰能力大大增强，增强抗电击和抗电磁脉冲的能力.<br><img src="/picture/5port.png" alt="网口"><br>G比特以太网通过IP1001芯片与RGMII接口进行扩展,如下:<br><img src="/picture/gbit.png" alt="GiBit"><br>IP1001与RJ45的接口如下:<br><img src="/picture/gbitport.png" alt="IP1001 to RJ45"><br>IP1001与RGMII接口如下:<br><img src="/picture/rgmii.png" alt="RGMII"><br>其他还有USB接口PCIe接口GPIO接口等都是一些常规的外设接口,这里不一一罗列出来了.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
      </tags>
  </entry>
  <entry>
    <title>qt-container</title>
    <url>/2020/02/06/qt-vector/</url>
    <content><![CDATA[<h3 id="qt-container概述"><a href="#qt-container概述" class="headerlink" title="qt-container概述"></a>qt-container概述</h3><p>Qt 提供了多个基于模板的容器类，这些容器类可以用于存储指定类型的数据项，例如常用的字符串列表类 QStringList 就是从容器类 QLiSt<QString> 继承的，实现对字符串列表的添加、存储、删除等操作。</p>
<p>Qt 的容器类比标准模板库（STL）中的容器类更轻巧、安全和易于使用。这些容器类是隐式共享和可重入的，而且它们进行了速度和存储优化，因此可以减少可执行文件的大小。此外，它们还是线程安全的，也就是说它们作为只读容器时可被多个线程访问。</p>
<p>容器类是基于模板的类，如常用的容器类 QList<T>，T 是一个具体的类型，可以是 int、float 等简单类型，也可以是 Qstring、QDate 等类，但不能是 QObject 或任何其子类。T 必须是一个可赋值的类型，即T必须提供一个缺省的构造函数，一个可复制构造函数和一个赋值运算符。</p>
<h3 id="qt-container列表"><a href="#qt-container列表" class="headerlink" title="qt-container列表"></a>qt-container列表</h3><p>1&gt; QLinkedList<T> 基于链表实现，元素存储空间不连续，提供基于index的对元素的快速访问，有较多插入操作，删除时建议使用。 类似于QList，但是一般通过迭代器访问元素，而不是index。</p>
<p>2&gt; QVector<T> 存储空间连续，插入操作性能不理想，访问性能佳。 数组的区别在于:可以随时改变大小。</p>
<p>3&gt; QList<T> 集合了QLinkedList<T>和QVector<T>的优点 具有很好的扩展性，比如QStringList。 QList::append()：后端插入 QList::prepend(): 前端插入 QList::insert()：按index插入</p>
<p>4&gt;QStack<T> 继承于QVector，提供LIFO功能。 新增push(), pop(), 和 top()等。</p>
<p>5&gt; QQueue<T> 继承于QList，提供FIFO功能。 新增enqueue(), dequeue(), and head().</p>
<p>6&gt; QSet<T> 提供对不可重复的集合的快速查找。</p>
<p>7&gt; QMap&lt;Key, T&gt; 按照键排序，存储键值对。</p>
<p>8&gt; QMultiMap&lt;Key, T&gt; 与QMap不同在于，一键可以对应多值。</p>
<p>9&gt; QHash&lt;Key, T&gt; 与QMap类似，不同之处在于，对于元素查找，利用hash函数进行，并且元素并没有按照键值排序。</p>
<p>10&gt; QMultiHash&lt;Key, T&gt; 与QHash的不同之处在于，可以一键对应多值。</p>
<h3 id="顺序容器类"><a href="#顺序容器类" class="headerlink" title="顺序容器类"></a>顺序容器类</h3><p>Qt 的顺序容器类有 QList、QLinkedList、QVector、QStack 和 QQueue。</p>
<h4 id="QList"><a href="#QList" class="headerlink" title="QList"></a>QList</h4><p>QList 是最常用的容器类，虽然它是以数组列表的形式实现的，但是在其前或后添加数据非常快，QList 以下标索引的方式对数据项进行访问。</p>
<p>QList 用于添加、插入、替换、移动、删除数据项的函数有：insert()、replace()、removeAt()、move()、swap()、append()、prepend()、removeFirst() 和 removeLast() 等。</p>
<p>QList 提供下标索引方式访问数据项，如同数组一样，也提供 at() 函数，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QList&lt;QString&gt; list;</span><br><span class="line">list &lt;&lt; <span class="string">&quot;one&quot;</span> &lt;&lt; <span class="string">&quot;two&quot;</span> &lt;&lt; <span class="string">&quot;three&quot;</span>;</span><br><span class="line">QString str1=list[1]; //str1==<span class="string">&quot;two&quot;</span></span><br><span class="line">QString str0=list.at(0); //str0==<span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>
<p>QList 的 isEmpty() 函数在数据项为空时返回 true，size() 函数返回数据项的个数。</p>
<p>QList 是 Qt 中最常用的容器类，很多函数的参数传递都是采用 QList 容器类，例如 QAudioDeviceInfo 的静态函数 availableDevices() 的函数原型是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QList&lt;QAudioDeviceInfo&gt; QAudioDeviceInfo::availableDevices(QAudio::Mode mode)</span><br></pre></td></tr></table></figure>
<p>其返回数据就是 QAudioDeviceInfo 类型的 QList 列表。</p>
<h4 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a>QLinkedList</h4><p>QLinkedList<T> 是链式列表，数据项不是用连续的内存存储的，它基于迭代器访问数据项，并且插入和删除数据项的操作时间相同。</p>
<p>除了不提供基于下标索引的数据项访问外，QLinkedList 的其他接口函数与 QList 基本相同。</p>
<h4 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a>QVector</h4><p>QVector<T> 提供动态数组的功能，以下标索引访问数据。</p>
<p>QVector 的函数接口与 QList 几乎完全相同，QVector<T> 的性能比 QList<T> 更高，因为 QVector<P> 的数据项是连续存储的。</p>
<h4 id="QStack"><a href="#QStack" class="headerlink" title="QStack"></a>QStack</h4><p>QStack<T> 是提供类似于堆栈的后入先出（LIFO）操作的容器类，push() 和 pop() 是主要的接口函数。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QStack&lt;int&gt; stack;</span><br><span class="line">stack.push(10);</span><br><span class="line">stack.push(20);</span><br><span class="line">stack.push(30);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">    cout &lt;&lt; <span class="string">stack.pop() &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<p>程序会依次输出 30, 20, 10。</p>
<h4 id="QQueue"><a href="#QQueue" class="headerlink" title="QQueue"></a>QQueue</h4><p>QQueue<T> 是提供类似于队列先入先出（FIFO）操作的容器类。enqueue() 和 dequeue() 是主要操作函数。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QQueue&lt;int&gt; queue;</span><br><span class="line">queue.enqueue (10);</span><br><span class="line">queue.enqueue(20);</span><br><span class="line">queue.enqueue (30);</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">    cout &lt;&lt; <span class="string">queue.dequeue() &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<p>程序会依次输出 10, 20，30。</p>
<h3 id="关联容器类"><a href="#关联容器类" class="headerlink" title="关联容器类"></a>关联容器类</h3><p>Qt 还提供关联容器类 QMap、QMultiMap、QHash、QMultiHash 和 QSet。</p>
<p>QMultiMap 和 QMultiHash 支持一个键关联多个值，QHash 和 QMultiHash 类使用散列函数进行查找，查找速度更快。</p>
<h4 id="QSet"><a href="#QSet" class="headerlink" title="QSet"></a>QSet</h4><p>QSet 是基于散列表的集合模板类，它存储数据的顺序是不定的，查找值的速度非常快。 QSet<T> 内部就是用 QHash 实现的。</p>
<p>定义 QSet<T> 容器和输入数据的实例代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QSet&lt;QString&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="built_in">set</span> &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; <span class="string">&quot;cat&quot;</span> &lt;&lt; <span class="string">&quot;tiger&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>测试一个值是否包含于这个集合，用 contains() 函数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!set.contains(<span class="string">&quot;cat&quot;</span>))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4 id="QMap"><a href="#QMap" class="headerlink" title="QMap"></a>QMap</h4><p>QMap&lt;Key, T&gt; 提供一个字典（关联数组)，一个键映射到一个值。QMap 存储数据是按照键的顺序，如果不在乎存储顺序，使用 QHash 会更快。</p>
<p>定义 QMap&lt;QString，int&gt; 类型变量和赋值的示例代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QMap&lt;QString, int&gt; map;</span><br><span class="line">map[<span class="string">&quot;one&quot;</span>] = 1;</span><br><span class="line">map[<span class="string">&quot;two&quot;</span>] = 2;</span><br><span class="line">map[<span class="string">&quot;three &quot;</span>] = 3;</span><br></pre></td></tr></table></figure>
<p>也可以使用 insert() 函数赋值，或 remove() 移除一个键值对，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">map.insert(<span class="string">&quot;four&quot;</span>, 4);</span><br><span class="line">map.remove(<span class="string">&quot;two&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>要查找一个值，使用运算符“[]”或 value() 函数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int num1 = map[<span class="string">&quot;one&quot;</span>];</span><br><span class="line">int num2 = map.value(<span class="string">&quot;two&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在映射表中没有找到指定的键，会返回一个缺省构造值，例如，如果值的类型是字符串，会返回一个空的字符串。</p>
<p>在使用 value() 函数查找键值时，还可以指定一个缺省的返回值，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timeout = map.value(<span class="string">&quot;TIMEOUT&quot;</span>,30);</span><br></pre></td></tr></table></figure>
<p>这表示如果在 map 里找到键“TIMEOUT”，就返回关联的值，否则返回值为 30。</p>
<h4 id="QMultiMap"><a href="#QMultiMap" class="headerlink" title="QMultiMap"></a>QMultiMap</h4><p>QMultiMap 是 QMap 的子类，是用于处理多值映射的便利类。</p>
<p>多值映射就是一个键可以对应多个值。QMap 正常情况下不允许多值映射，除非使用 QMap::insertMulti() 添加键值对。</p>
<p>QMultiMap 是 QMap 的子类，所以 QMap 的大多数函数在 QMultiMap 都是可用的，但是有几个特殊的，QMultiMap::insert() 等效于 QMap::insertMulti() , QMultiMap::replace() 等效于 QMap::insert()。</p>
<p>QMultiMap 使用示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QMultiMap&lt;QString, int&gt; map1, map2, map3;</span><br><span class="line">map1.insert(<span class="string">&quot;plenty&quot;</span>, 100);</span><br><span class="line">mapl.insert(<span class="string">&quot;plenty&quot;</span>, 2000); // map1.size() == 2</span><br><span class="line">map2.insert(<span class="string">&quot;plenty&quot;</span>, 5000); // map2.size() == 1</span><br><span class="line">map3 = map1 + map2; // map3.size() == 3</span><br></pre></td></tr></table></figure>
<p>QMultiMap 不提供“[]”操作符，使用 value() 函数访问最新插入的键的单个值。如果要获取一个键对应的所有值，使用 values() 函数，返回值是 QList<T> 类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QList&lt;int&gt; values = map.values(<span class="string">&quot;plenty&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; values.size(); ++i)</span><br><span class="line">    cout &lt;&lt; <span class="string">values.at(i) &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<h4 id="QHash"><a href="#QHash" class="headerlink" title="QHash"></a>QHash</h4><p>QHash 是基于散列表来实现字典功能的模板类，QHash&lt;Key，T&gt; 存储的键值对具有非常快的查找速度。</p>
<p>QHash 与 QMap 的功能和用法相似，区别在于以下几点：<br>QHash 比 QMap 的查找速度快；<br>在 QMap 上遍历时，数据项是按照键排序的，而 QHash 的数据项是任意顺序的；<br>QMap 的键必须提供“&lt;”运算符，QHash 的键必须提供“==”运算符和一个名称为 qHash() 的全局散列函数。</p>
<h4 id="QMultiHash"><a href="#QMultiHash" class="headerlink" title="QMultiHash"></a>QMultiHash</h4><p>QMultiHash 是 QHash 的子类，是用于处理多值映射的便利类，其用法与 QMultiMap 类似。</p>
<h3 id="Foreach关键字"><a href="#Foreach关键字" class="headerlink" title="Foreach关键字"></a>Foreach关键字</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QString str;</span><br><span class="line"></span><br><span class="line">foreach (str, list)</span><br><span class="line"></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">str;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ProgramingLanguage</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3308-setup.md</title>
    <url>/2019/11/16/rk3308-setup-md/</url>
    <content><![CDATA[<h3 id="一、编译固件"><a href="#一、编译固件" class="headerlink" title="一、编译固件"></a>一、编译固件</h3><ul>
<li>安装 Kernel 及 U-Boot 编译需要依赖的软件包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl \</span><br><span class="line">zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev \</span><br><span class="line">x11proto-core-dev libx11-dev lib32z1-dev ccache libgl1-mesa-dev \</span><br><span class="line">libxml2-utils xsltproc unzip device-tree-compiler</span><br></pre></td></tr></table></figure></li>
<li>安装 Buildroot 编译需要依赖的软件包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libfile-which-perl sed make binutils gcc g++ bash \</span><br><span class="line">patch gzip bzip2 perl tar cpio python unzip rsync file bc libmpc3 \</span><br><span class="line">git repo texinfo pkg-config cmake tree</span><br></pre></td></tr></table></figure></li>
<li>必要工具安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install genext2fs</span><br><span class="line">sudo apt install gawk</span><br></pre></td></tr></table></figure></li>
<li>编译uboot<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> u-boot/</span><br><span class="line">./make.sh rk3308</span><br></pre></td></tr></table></figure></li>
<li>编译kernel<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> kernel/</span><br><span class="line">make arch=arm64 firefly-rk3308_linux_defconfig</span><br><span class="line">make arch=arm64 rk3308-roc-cc-dmic-pdm_emmc.img</span><br></pre></td></tr></table></figure></li>
<li>编译Buildroot<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> buildroot</span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li>
<li>打包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure>
<h3 id="二、-烧写固件"><a href="#二、-烧写固件" class="headerlink" title="二、 烧写固件"></a>二、 烧写固件</h3></li>
</ul>
<ol>
<li>烧写统一固件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo upgrade_tool uf update.img</span><br></pre></td></tr></table></figure></li>
<li>烧写分区镜像<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo upgrade_tool ul MiniLoaderAll.bin</span><br><span class="line">sudo upgrade_tool di -p parameter.txt</span><br><span class="line">sudo upgrade_tool di -u uboot.img</span><br><span class="line">sudo upgrade_tool di -t trust.img</span><br><span class="line">sudo upgrade_tool di -misc misc.img</span><br><span class="line">sudo upgrade_tool di -r recovery.img</span><br><span class="line">sudo upgrade_tool di -b zboot.img</span><br><span class="line">sudo upgrade_tool di -rootfs rootfs.img</span><br><span class="line">sudo upgrade_tool di -oem oem.img</span><br><span class="line">sudo upgrade_tool di -userdata userdata.img</span><br><span class="line">sudo upgrade_tool rd</span><br></pre></td></tr></table></figure></li>
<li>格式化，擦除 flash<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo upgrade_tool lf   <span class="comment"># 低级格式化</span></span><br><span class="line">sudo upgrade_tool ef   <span class="comment"># 擦除</span></span><br></pre></td></tr></table></figure>
本文参考 <a href="http://wiki.t-firefly.com/ROC-RK3308-CC/intro.html">http://wiki.t-firefly.com/ROC-RK3308-CC/intro.html</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>rk3308</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-1.1.6-Makefile</title>
    <url>/2018/09/06/u-boot-1-1-6-Makefile/</url>
    <content><![CDATA[<h3 id="make-100ask24x0-config"><a href="#make-100ask24x0-config" class="headerlink" title="make 100ask24x0_config"></a>make 100ask24x0_config</h3><p>在Makefile中搜索到</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>ask<span class="number">24</span><span class="keyword">x</span><span class="number">0</span>_config	:	unconfig</span><br><span class="line"> <span class="title">@$</span>(MKCONFIG) $(@:_config<span class="operator">=</span>) arm arm<span class="number">920</span>t <span class="number">100</span>ask<span class="number">24</span><span class="keyword">x</span><span class="number">0</span> NULL s<span class="number">3</span><span class="keyword">c</span><span class="number">24</span><span class="keyword">x</span><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以搜索到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">MKCONFIG	:= <span class="variable">$(SRCTREE)</span>/mkconfig</span><br><span class="line">SRCTREE	:= <span class="variable">$(CURDIR)</span></span><br><span class="line">OBJTREE	:= <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(BUILD_DIR)</span>,<span class="variable">$(BUILD_DIR)</span>,<span class="variable">$(CURDIR)</span>)</span></span><br></pre></td></tr></table></figure>
<p>展开后为 mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0<br>执行当前目录下的mkconfig文件，传递的参数为100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0且</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> mkconfig 100ask24x0  arm  arm920t  100ask24x0  NULL  s3c24x0</span><br><span class="line">  <span class="variable">$0</span>       <span class="variable">$1</span>        <span class="variable">$2</span>     <span class="variable">$3</span>       <span class="variable">$4</span>        <span class="variable">$5</span>      <span class="variable">$6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ] ; <span class="keyword">do</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"> --) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</span><br><span class="line"> -a) <span class="built_in">shift</span> ; APPEND=yes ;;</span><br><span class="line"> -n) <span class="built_in">shift</span> ; BOARD_NAME=<span class="string">&quot;<span class="variable">$&#123;1%%_config&#125;</span>&quot;</span> ; <span class="built_in">shift</span> ;;</span><br><span class="line"> *) <span class="built_in">break</span> ;;</span><br><span class="line"> <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>执行break跳过</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;BOARD_NAME&#125;</span>&quot;</span> ] || <span class="attribute">BOARD_NAME</span>=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里BOARD_NAME = “$1”即BOARD_NAME = 100ask24x0</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$SRCTREE&quot;</span> != <span class="string">&quot;$OBJTREE&quot;</span> ] ; then</span><br><span class="line"> <span class="keyword">mkdir</span> -p <span class="variable">$&#123;OBJTREE&#125;</span>/<span class="keyword">include</span></span><br><span class="line"> <span class="keyword">mkdir</span> -p <span class="variable">$&#123;OBJTREE&#125;</span>/include2</span><br><span class="line"> <span class="keyword">cd</span> <span class="variable">$&#123;OBJTREE&#125;</span>/include2</span><br><span class="line"> <span class="keyword">rm</span> -f asm</span><br><span class="line"> ln -s <span class="variable">$&#123;SRCTREE&#125;</span>/<span class="keyword">include</span>/asm-<span class="variable">$2</span> asm</span><br><span class="line"> LNPREFIX=<span class="string">&quot;../../include2/asm/&quot;</span></span><br><span class="line"> <span class="keyword">cd</span> ../<span class="keyword">include</span></span><br><span class="line"> <span class="keyword">rm</span> -rf asm-<span class="variable">$2</span></span><br><span class="line"> <span class="keyword">rm</span> -f asm</span><br><span class="line"> <span class="keyword">mkdir</span> asm-<span class="variable">$2</span></span><br><span class="line"> ln -s asm-<span class="variable">$2</span> asm</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="keyword">cd</span> ./<span class="keyword">include</span></span><br><span class="line"> <span class="keyword">rm</span> -f asm</span><br><span class="line"> ln -s asm-<span class="variable">$2</span> asm</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>执行else<br>ln -s asm-$2 asm is ln -s asm-arm asm可以通过ll include/asm查看</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rm</span> -f asm-<span class="variable">$2</span>/<span class="keyword">arch</span>删除asm-arm/<span class="keyword">arch</span>目录</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;$6&quot;</span> -o <span class="string">&quot;$6&quot;</span> = <span class="string">&quot;NULL&quot;</span> ] ; then</span><br><span class="line"> ln -s <span class="variable">$&#123;LNPREFIX&#125;</span><span class="keyword">arch</span>-<span class="variable">$3</span> asm-<span class="variable">$2</span>/<span class="keyword">arch</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> ln -s <span class="variable">$&#123;LNPREFIX&#125;</span><span class="keyword">arch</span>-<span class="variable">$6</span> asm-<span class="variable">$2</span>/<span class="keyword">arch</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>$6不为空执行else<br>ln -s ${LNPREFIX}arch-$6 asm-$2/arch展开为ln -s arch-s3c24x0 asm-$2/arch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ARCH = <span class="variable">$2</span>&quot;</span> &gt; config.mk</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;CPU = <span class="variable">$3</span>&quot;</span> &gt;&gt; config.mk</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;BOARD = <span class="variable">$4</span>&quot;</span> &gt;&gt; config.mk</span><br></pre></td></tr></table></figure>
<p>将这三行内容echo到config.mk文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$5</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$5</span>&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;VENDOR = <span class="variable">$5</span>&quot;</span> &gt;&gt; config.mk</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$6</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$6</span>&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;SOC = <span class="variable">$6</span>&quot;</span> &gt;&gt; config.mk</span><br></pre></td></tr></table></figure>
<p>$5为空$6不为空执行下面一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$APPEND</span>&quot;</span> = <span class="string">&quot;yes&quot;</span> ]	<span class="comment"># Append to existing config file</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> &gt;&gt; config.h</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> &gt; config.h	<span class="comment"># Create new config file</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/* Automatically generated - do not edit */&quot;</span> &gt;&gt;config.h</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#include &lt;configs/<span class="variable">$1</span>.h&gt;&quot;</span> &gt;&gt;config.h</span><br></pre></td></tr></table></figure>
<p>创建config.h并写入下面两行内容<br>自此该命令执行完</p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>默认目标为all</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ALL = <span class="constructor">$(<span class="params">obj</span>)</span>u-boot.srec <span class="constructor">$(<span class="params">obj</span>)</span>u-boot.bin <span class="constructor">$(<span class="params">obj</span>)</span><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>map <span class="constructor">$(U_BOOT_NAND)</span></span><br><span class="line"></span><br><span class="line">all:	<span class="constructor">$(ALL)</span></span><br></pre></td></tr></table></figure>
<p>$(obj)为空</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span>(obj)u-boot.bin:	<span class="symbol">$</span>(obj)u-boot</span><br><span class="line">  <span class="symbol">$</span>(OBJCOPY) <span class="symbol">$</span>&#123;OBJCFLAGS&#125; -O <span class="keyword">binary</span> <span class="symbol">$</span>&lt; <span class="symbol">$</span>@</span><br></pre></td></tr></table></figure>
<p>u-boot.bin依赖u-boot且通过armlinuxobjcopy命令转化-O binary指定目标格式 $&lt; $@第一个依赖文件和目标文件即u-boot和u-boot.bin</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span>(obj)u<span class="literal">-boot</span>:	depend version <span class="variable">$</span>(SUBDIRS) <span class="variable">$</span>(OBJS) <span class="variable">$</span>(LIBS) <span class="variable">$</span>(LDSCRIPT)</span><br><span class="line">  UNDEF_SYM=`$(OBJDUMP) <span class="literal">-x</span> <span class="variable">$</span>(LIBS) |sed <span class="literal">-n</span> <span class="literal">-e</span> <span class="string">&#x27;s/.*\(__u_boot_cmd_.*\)/-u\1/p&#x27;</span>|<span class="built_in">sort</span>|uniq`;\</span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$</span>(LNDIR) &amp;&amp; <span class="variable">$</span>(LD) <span class="variable">$</span>(LDFLAGS) <span class="variable">$</span><span class="variable">$UNDEF_SYM</span> <span class="variable">$</span>(__OBJS) \</span><br><span class="line">   -<span class="literal">-start</span><span class="literal">-group</span> <span class="variable">$</span>(__LIBS) -<span class="literal">-end</span><span class="literal">-group</span> <span class="variable">$</span>(PLATFORM_LIBS) \</span><br><span class="line">   <span class="literal">-Map</span> u<span class="literal">-boot</span>.map <span class="literal">-o</span> u<span class="literal">-boot</span></span><br></pre></td></tr></table></figure>
<p>这就是生成u-boot的规则 depend如果不使用这个功能， 则当你修改一个头文件时， 必须重新把所有的源文件都编译一次， 使用depend ,就可只编译包含此头文件的源文件，可大大节省时间<br>执行make打印信息为</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">UNDEF_SYM=`arm-linux-objdump -x lib_generic/libgeneric.a board/<span class="number">100</span>ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/<span class="keyword">nand</span>/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a |sed -n -e <span class="symbol">&#x27;s</span>/.*\(__u_boot_cmd_.*\)/-u\<span class="number">1</span>/p&#x27;|sort|uniq`;\</span><br><span class="line">        cd /home/techliu/myPrograms/jz2440/source/JZ2440V3/system/u-boot-<span class="number">1.1</span>.<span class="number">6</span> &amp;&amp; arm-linux-ld -Bstatic -T /home/techliu/myPrograms/jz2440/source/JZ2440V3/system/u-boot-<span class="number">1.1</span>.<span class="number">6</span>/board/<span class="number">100</span>ask24x0/u-boot.lds -Ttext <span class="number">0</span>x33F80000 $UNDEF_SYM cpu/arm920t/start.o \</span><br><span class="line">                <span class="comment">--start-group lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a --end-group \</span></span><br><span class="line">                -<span class="keyword">Map</span> u-boot.<span class="keyword">map</span> -o u-boot</span><br><span class="line">arm-linux-objcopy <span class="comment">--gap-fill=0xff -O srec u-boot u-boot.srec</span></span><br><span class="line">arm-linux-objcopy <span class="comment">--gap-fill=0xff -O binary u-boot u-boot.bin</span></span><br></pre></td></tr></table></figure>
<p>$(OBJDUMP)就是rm-linux-objdump<br>$(LIBS)是如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = cpu/<span class="variable">$(CPU)</span>/start.o</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,i386)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/start16.o</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/reset.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,ppc4xx)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/resetvec.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,mpc83xx)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/resetvec.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,mpc85xx)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/resetvec.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,mpc86xx)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/resetvec.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,bf533)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/start1.o	cpu/<span class="variable">$(CPU)</span>/interrupt.o	cpu/<span class="variable">$(CPU)</span>/cache.o</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/cplbhdlr.o	cpu/<span class="variable">$(CPU)</span>/cplbmgr.o	cpu/<span class="variable">$(CPU)</span>/flush.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">LIBS = lib_generic/libgeneric.a</span><br><span class="line">LIBS += board/<span class="variable">$(BOARDDIR)</span>/lib<span class="variable">$(BOARD)</span>.a</span><br><span class="line">LIBS += cpu/<span class="variable">$(CPU)</span>/lib<span class="variable">$(CPU)</span>.a</span><br><span class="line"><span class="keyword">ifdef</span> SOC</span><br><span class="line">LIBS += cpu/<span class="variable">$(CPU)</span>/<span class="variable">$(SOC)</span>/lib<span class="variable">$(SOC)</span>.a</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">LIBS += lib_<span class="variable">$(ARCH)</span>/lib<span class="variable">$(ARCH)</span>.a</span><br><span class="line">LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \</span><br><span class="line"> fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a</span><br><span class="line">LIBS += net/libnet.a</span><br><span class="line">LIBS += disk/libdisk.a</span><br><span class="line">LIBS += rtc/librtc.a</span><br><span class="line">LIBS += dtt/libdtt.a</span><br><span class="line">LIBS += drivers/libdrivers.a</span><br><span class="line">LIBS += drivers/nand/libnand.a</span><br><span class="line">LIBS += drivers/nand_legacy/libnand_legacy.a</span><br><span class="line">LIBS += drivers/usb/libusb.a</span><br><span class="line">LIBS += drivers/sk98lin/libsk98lin.a</span><br><span class="line">LIBS += common/libcommon.a</span><br><span class="line">LIBS += <span class="variable">$(BOARDLIBS)</span></span><br><span class="line"></span><br><span class="line">LIBS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>,<span class="variable">$(LIBS)</span>)</span></span><br></pre></td></tr></table></figure>
<p>编译子目录</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">SUBDIRS</span>	= <span class="string">tools \</span></span><br><span class="line">   <span class="attr">examples</span> <span class="string">\</span></span><br><span class="line">   <span class="attr">post</span> <span class="string">\</span></span><br><span class="line">   <span class="attr">post/cpu</span></span><br></pre></td></tr></table></figure>
<p>链接脚本</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> LDSCRIPT</span><br><span class="line"><span class="comment">#LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_NAND_U_BOOT)</span>,y)</span><br><span class="line">LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot-nand.lds</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot.lds</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>整个Makefile指定了目标和依赖以及链接脚本和链接地址组织成为一个u-boot.bin</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-1.1.6-secondStage</title>
    <url>/2018/09/06/u-boot-1-1-6-secondStage/</url>
    <content><![CDATA[<h2 id="board-c"><a href="#board-c" class="headerlink" title="board.c"></a>board.c</h2><h3 id="void-start-armboot-void"><a href="#void-start-armboot-void" class="headerlink" title="void start_armboot (void)"></a>void start_armboot (void)</h3><ul>
<li>gd指针赋值<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Pointer is writable since we allocated a register <span class="keyword">for</span> it */</span><br><span class="line">gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));</span><br></pre></td></tr></table></figure></li>
<li> 函数指针数组进行初始化<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((*init_fnc_ptr)() != 0) &#123;</span><br><span class="line">  hang ();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init_fnc_t *init_sequence[] = &#123;</span><br><span class="line"> cpu_init,	/* basic cpu dependent setup */</span><br><span class="line"> board_init,	/* basic board dependent setup */</span><br><span class="line"> interrupt_init,	/* <span class="built_in">set</span> up exceptions */</span><br><span class="line"> env_init,	/* initialize environment */</span><br><span class="line"> init_baudrate,	/* initialze baudrate settings */</span><br><span class="line"> serial_init,	/* serial communications setup */</span><br><span class="line"> console_init_f,	/* stage 1 init of console */</span><br><span class="line"> display_banner,	/* say that we are here */</span><br><span class="line"><span class="comment">#if defined(CONFIG_DISPLAY_CPUINFO)</span></span><br><span class="line"> print_cpuinfo,	/* display cpu info (and speed) */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_DISPLAY_BOARDINFO)</span></span><br><span class="line"> checkboard,	/* display board info */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"> dram_init,	/* configure available RAM banks */</span><br><span class="line"> display_dram_config,</span><br><span class="line"> NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li> 一系列初始化<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">size = flash_init ();</span><br><span class="line">display_flash_config (size);</span><br><span class="line"></span><br><span class="line">addr = (_bss_end + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">size = lcd_setmem (addr);</span><br><span class="line">gd-&gt;fb_base = addr;</span><br><span class="line"></span><br><span class="line">   /* armboot_start is defined <span class="keyword">in</span> the board-specific linker script */</span><br><span class="line">mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);</span><br><span class="line"></span><br><span class="line">   /* initialize environment */</span><br><span class="line">env_relocate ();</span><br><span class="line"></span><br><span class="line">   devices_init ();	/* get the devices list going. */</span><br><span class="line"></span><br><span class="line">   console_init_r ();	/* fully init console as a device */</span><br><span class="line"></span><br><span class="line">/* miscellaneous platform dependent initialisations */</span><br><span class="line">misc_init_r ();</span><br><span class="line"></span><br><span class="line">   board_late_init ();</span><br></pre></td></tr></table></figure></li>
<li>进入u-boot界面<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> main_loop ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> 读取kernel引导kernel<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  s = getenv (<span class="string">&quot;bootcmd&quot;</span>);</span><br><span class="line"></span><br><span class="line"> debug (<span class="string">&quot;### main_loop: bootcmd=\&quot;%s\&quot;\n&quot;</span>, s ? s : <span class="string">&quot;&lt;UNDEFINED&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (bootdelay &gt;= 0 &amp;&amp; s &amp;&amp; !abortboot (bootdelay)) &#123;</span><br><span class="line"><span class="comment"># ifdef CONFIG_AUTOBOOT_KEYED</span></span><br><span class="line">  int prev = disable_ctrlc(1);	/* <span class="built_in">disable</span> Control C checking */</span><br><span class="line"><span class="comment"># endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ifndef CFG_HUSH_PARSER</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Booting Linux ...\n&quot;</span>);            </span><br><span class="line">         run_command (s, 0);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment"># else</span></span><br><span class="line">  parse_string_outer(s, FLAG_PARSE_SEMICOLON |</span><br><span class="line">        FLAG_EXIT_FROM_LOOP);</span><br><span class="line"><span class="comment"># endif</span></span><br></pre></td></tr></table></figure></li>
<li> u-boot倒计时超时进入命令控制<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  len = readline (CFG_PROMPT);</span><br><span class="line"></span><br><span class="line">  flag = 0;	/* assume no special flags <span class="keyword">for</span> now */</span><br><span class="line">  <span class="keyword">if</span> (len &gt; 0)</span><br><span class="line">   strcpy (lastcommand, console_buffer);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (len == 0)</span><br><span class="line">   flag |= CMD_FLAG_REPEAT;</span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOT_RETRY_TIME</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (len == -2) &#123;</span><br><span class="line">   /* -2 means timed out, retry autoboot</span><br><span class="line">    */</span><br><span class="line">   puts (<span class="string">&quot;\nTimed out waiting for command\n&quot;</span>);</span><br><span class="line"><span class="comment"># ifdef CONFIG_RESET_TO_RETRY</span></span><br><span class="line">   /* Reinit board to run initialization code again */</span><br><span class="line">   do_reset (NULL, 0, 0, NULL);</span><br><span class="line"><span class="comment"># else</span></span><br><span class="line">   <span class="built_in">return</span>;	/* retry autoboot */</span><br><span class="line"><span class="comment"># endif</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len == -1)</span><br><span class="line">   puts (<span class="string">&quot;&lt;INTERRUPT&gt;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   rc = run_command (lastcommand, flag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rc &lt;= 0) &#123;</span><br><span class="line">   /* invalid <span class="built_in">command</span> or not repeatable, forget it */</span><br><span class="line">   lastcommand[0] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">#endif /*CFG_HUSH_PARSER*/</span></span><br></pre></td></tr></table></figure></li>
<li>run_command 函数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Find separator, or string end</span><br><span class="line"> * Allow simple escape of <span class="string">&#x27;;&#x27;</span> by writing <span class="string">&quot;\;&quot;</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">for</span> (inquotes = 0, sep = str; *sep; sep++) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((*sep==<span class="string">&#x27;\&#x27;</span><span class="string">&#x27;) &amp;&amp;</span></span><br><span class="line"><span class="string">     (*(sep-1) != &#x27;</span>\\<span class="string">&#x27;))</span></span><br><span class="line"><span class="string">  inquotes=!inquotes;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> if (!inquotes &amp;&amp;</span></span><br><span class="line"><span class="string">     (*sep == &#x27;</span>;<span class="string">&#x27;) &amp;&amp;	/* separator	*/</span></span><br><span class="line"><span class="string">     ( sep != str) &amp;&amp;	/* past string start	*/</span></span><br><span class="line"><span class="string">     (*(sep-1) != &#x27;</span>\\<span class="string">&#x27;))	/* and NOT escaped	*/</span></span><br><span class="line"><span class="string">  break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
支持同时输入多条命令以;隔开<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Look up <span class="built_in">command</span> <span class="keyword">in</span> <span class="built_in">command</span> table */</span><br><span class="line"><span class="keyword">if</span> ((cmdtp = find_cmd(argv[0])) == NULL) &#123;</span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">&quot;Unknown command &#x27;%s&#x27; - try &#x27;help&#x27;\n&quot;</span>, argv[0]);</span><br><span class="line"> rc = -1;	/* give up after bad <span class="built_in">command</span> */</span><br><span class="line"> <span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
查找命令对应结构体并运行对应函数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (cmdtp = &amp;__u_boot_cmd_start;</span><br><span class="line">     cmdtp != &amp;__u_boot_cmd_end;</span><br><span class="line">     cmdtp++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (strncmp (cmd, cmdtp-&gt;name, len) == 0) &#123;</span><br><span class="line">  <span class="keyword">if</span> (len == strlen (cmdtp-&gt;name))</span><br><span class="line">   <span class="built_in">return</span> cmdtp;	/* full match */</span><br><span class="line"></span><br><span class="line">  cmdtp_temp = cmdtp;	/* abbreviated <span class="built_in">command</span> ? */</span><br><span class="line">  n_found++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
__u_boot_cmd_start和__u_boot_cmd_end在链接脚本里定义<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__u_boot_cmd_start = .;</span><br><span class="line">.u_boot_cmd : &#123; *(.u_boot_cmd) &#125;</span><br><span class="line">__u_boot_cmd_end = .;</span><br></pre></td></tr></table></figure>
通过U_BOOT_CMD定义一个新的命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line"> spiinfo,	1,	1,	do_spiinfo,</span><br><span class="line"> <span class="string">&quot;spiinfo - print Serial Peripheral Interface (SPI) registers\n&quot;</span>,</span><br><span class="line"> NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
其定义为<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define Struct_Section __attribute__ ((unused,section (&quot;.u_boot_cmd&quot;)))</span></span><br><span class="line"><span class="comment">#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \</span></span><br><span class="line">cmd_tbl_t __u_boot_cmd_<span class="comment">##name Struct_Section = &#123;#name, maxargs, rep, cmd, usage, help&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>bootm函数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">image_header_t *hdr = &amp;header;</span><br></pre></td></tr></table></figure>
image_header_t是uimage的头部信息结构体<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * all data <span class="keyword">in</span> network byte order (aka natural aka bigendian)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef struct image_header &#123;</span><br><span class="line"> uint32_t	ih_magic;	/* Image Header Magic Number	*/</span><br><span class="line"> uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/</span><br><span class="line"> uint32_t	ih_time;	/* Image Creation Timestamp	*/</span><br><span class="line"> uint32_t	ih_size;	/* Image Data Size	*/</span><br><span class="line"> uint32_t	ih_load;	/* Data	Load Address	*/</span><br><span class="line"> uint32_t	ih_ep;	/* Entry Point Address	*/</span><br><span class="line"> uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/</span><br><span class="line"> uint8_t	ih_os;	/* Operating System	*/</span><br><span class="line"> uint8_t	ih_arch;	/* CPU architecture	*/</span><br><span class="line"> uint8_t	ih_type;	/* Image Type	*/</span><br><span class="line"> uint8_t	ih_comp;	/* Compression Type	*/</span><br><span class="line"> uint8_t	ih_name[IH_NMLEN];	/* Image Name	*/</span><br><span class="line">&#125; image_header_t;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* Copy header so we can blank CRC field for re-calculation */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAS_DATAFLASH</span></span><br><span class="line"> <span class="keyword">if</span> (addr_dataflash(addr))&#123;</span><br><span class="line">  read_dataflash(addr, <span class="keyword">sizeof</span>(<span class="keyword">image_header_t</span>), (<span class="keyword">char</span> *)&amp;header);</span><br><span class="line"> &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> memmove (&amp;header, (<span class="keyword">char</span> *)addr, <span class="keyword">sizeof</span>(<span class="keyword">image_header_t</span>));</span><br></pre></td></tr></table></figure>
读取uimage头部信息<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (hdr-&gt;ih_comp) &#123;</span><br><span class="line"> <span class="keyword">case</span> IH_COMP_NONE:</span><br><span class="line">  <span class="keyword">if</span>(ntohl(hdr-&gt;ih_load) == data) &#123;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot; XIP %s ... &quot;</span>, name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)</span></span><br><span class="line">   <span class="keyword">size_t</span> l = len;</span><br><span class="line">   <span class="keyword">void</span> *to = (<span class="keyword">void</span> *)ntohl(hdr-&gt;ih_load);</span><br><span class="line">   <span class="keyword">void</span> *from = (<span class="keyword">void</span> *)data;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot; Loading %s ... &quot;</span>, name);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tail = (l &gt; CHUNKSZ) ? CHUNKSZ : l;</span><br><span class="line">    WATCHDOG_RESET();</span><br><span class="line">    memmove (to, from, tail);</span><br><span class="line">    to += tail;</span><br><span class="line">    from += tail;</span><br><span class="line">    l -= tail;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */</span></span></span><br><span class="line">   memmove ((<span class="keyword">void</span> *) ntohl(hdr-&gt;ih_load), (uchar *)data, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> IH_COMP_GZIP:</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot; Uncompressing %s ... &quot;</span>, name);</span><br><span class="line">  <span class="keyword">if</span> (gunzip ((<span class="keyword">void</span> *)ntohl(hdr-&gt;ih_load), unc_len,</span><br><span class="line">       (uchar *)data, &amp;len) != <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">puts</span> (<span class="string">&quot;GUNZIP ERROR - must RESET board to recover\n&quot;</span>);</span><br><span class="line">   SHOW_BOOT_PROGRESS (<span class="number">-6</span>);</span><br><span class="line">   do_reset (cmdtp, flag, argc, argv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BZIP2</span></span><br><span class="line"> <span class="keyword">case</span> IH_COMP_BZIP2:</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot; Uncompressing %s ... &quot;</span>, name);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * If we&#x27;ve got less than 4 MB of malloc() space,</span></span><br><span class="line"><span class="comment">   * use slower decompression algorithm which requires</span></span><br><span class="line"><span class="comment">   * at most 2300 KB of memory.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  i = BZ2_bzBuffToBuffDecompress ((<span class="keyword">char</span>*)ntohl(hdr-&gt;ih_load),</span><br><span class="line">      &amp;unc_len, (<span class="keyword">char</span> *)data, len,</span><br><span class="line">      CFG_MALLOC_LEN &lt; (<span class="number">4096</span> * <span class="number">1024</span>), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (i != BZ_OK) &#123;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;BUNZIP2 ERROR %d - must RESET board to recover\n&quot;</span>, i);</span><br><span class="line">   SHOW_BOOT_PROGRESS (<span class="number">-6</span>);</span><br><span class="line">   udelay(<span class="number">100000</span>);</span><br><span class="line">   do_reset (cmdtp, flag, argc, argv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_BZIP2 */</span></span></span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  <span class="keyword">if</span> (iflag)</span><br><span class="line">   enable_interrupts();</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Unimplemented compression type %d\n&quot;</span>, hdr-&gt;ih_comp);</span><br><span class="line">  SHOW_BOOT_PROGRESS (<span class="number">-7</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span> (<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line"> SHOW_BOOT_PROGRESS (<span class="number">7</span>);</span><br></pre></td></tr></table></figure>
解压内核<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (hdr-&gt;ih_os) &#123;</span><br><span class="line"> <span class="keyword">default</span>:	<span class="comment">/* handled by (original) Linux case */</span></span><br><span class="line"> <span class="keyword">case</span> IH_OS_LINUX:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SILENT_CONSOLE</span></span><br><span class="line">     fixup_silent_linux();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     do_bootm_linux (cmdtp, <span class="built_in">flag</span>, argc, argv,</span><br><span class="line">        addr, len_ptr, verify);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>do_bootm_linux</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">image_header_t</span> *hdr = &amp;header;</span><br><span class="line"> <span class="keyword">bd_t</span> *bd = gd-&gt;bd;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMDLINE_TAG</span></span><br><span class="line"> <span class="keyword">char</span> *commandline = getenv (<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> theKernel = (<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>, uint))ntohl(hdr-&gt;ih_ep);</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if defined (CONFIG_SETUP_MEMORY_TAGS) || \</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span><span class="title">ined</span> <span class="params">(CONFIG_CMDLINE_TAG)</span></span> <span class="params">||</span> \</span><br><span class="line">    <span class="function"><span class="keyword">def</span><span class="title">ined</span> <span class="params">(CONFIG_INITRD_TAG)</span></span> <span class="params">||</span> \</span><br><span class="line">    <span class="function"><span class="keyword">def</span><span class="title">ined</span> <span class="params">(CONFIG_SERIAL_TAG)</span></span> <span class="params">||</span> \</span><br><span class="line">    <span class="function"><span class="keyword">def</span><span class="title">ined</span> <span class="params">(CONFIG_REVISION_TAG)</span></span> <span class="params">||</span> \</span><br><span class="line">    <span class="function"><span class="keyword">def</span><span class="title">ined</span> <span class="params">(CONFIG_LCD)</span></span> <span class="params">||</span> \</span><br><span class="line">    <span class="function"><span class="keyword">def</span><span class="title">ined</span> <span class="params">(CONFIG_VFD)</span></span></span><br><span class="line"> setup_start_tag (bd);</span><br><span class="line"><span class="comment">#ifdef CONFIG_SERIAL_TAG</span></span><br><span class="line"> setup_serial_tag (&amp;params);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_REVISION_TAG</span></span><br><span class="line"> setup_revision_tag (&amp;params);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SETUP_MEMORY_TAGS</span></span><br><span class="line"> setup_memory_tags (bd);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_CMDLINE_TAG</span></span><br><span class="line"> setup_commandline_tag (bd, commandline);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_INITRD_TAG</span></span><br><span class="line"> <span class="keyword">if</span> (initrd_start &amp;&amp; initrd_end)</span><br><span class="line">  setup_initrd_tag (bd, initrd_start, initrd_end);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined (CONFIG_VFD) || defined (CONFIG_LCD)</span></span><br><span class="line"> setup_videolfb_tag ((gd_t *) gd);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"> setup_end_tag (bd);</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>设置tag，u-boot传递给内核的参数</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">theKernel</span> (0, bd-&gt;</span><span class="function"><span class="title">bi_arch_number</span>, bd-&gt;</span>bi_boot_params);</span><br></pre></td></tr></table></figure>
<p>进入内核入口函数bi_arch_number，板子号，内核会对比看是否支持该板子<br>bi_boot_params板子启动参数0x30000100内核链接地址</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>u-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-1.1.6-startStage</title>
    <url>/2018/09/06/u-boot-1-1-6-startStage/</url>
    <content><![CDATA[<h2 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:	b reset</span><br><span class="line"> ldr	pc, _undefined_instruction</span><br><span class="line"> ldr	pc, _software_interrupt</span><br><span class="line"> ldr	pc, _prefetch_abort</span><br><span class="line"> ldr	pc, _data_abort</span><br><span class="line"> ldr	pc, _not_used</span><br><span class="line"> ldr	pc, _irq</span><br><span class="line"> ldr	pc, _fiq</span><br><span class="line"></span><br><span class="line">_undefined_instruction:	.word undefined_instruction</span><br><span class="line">_software_interrupt:	.word software_interrupt</span><br><span class="line">_prefetch_abort:	.word prefetch_abort</span><br><span class="line">_data_abort:	.word data_abort</span><br><span class="line">_not_used:	.word not_used</span><br><span class="line">_irq:	.word irq</span><br><span class="line">_fiq:	.word fiq</span><br><span class="line"></span><br><span class="line"> .balignl 16,0xdeadbeef</span><br></pre></td></tr></table></figure>
<p>_start开始跳转到reset</p>
<ul>
<li>设置cpu为SVC32模式<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * <span class="built_in">set</span> the cpu to SVC32 mode</span><br><span class="line"> */</span><br><span class="line">mrs	r0,cpsr</span><br><span class="line">bic	r0,r0,<span class="comment">#0x1f</span></span><br><span class="line">orr	r0,r0,<span class="comment">#0xd3</span></span><br><span class="line">msr	cpsr,r0</span><br></pre></td></tr></table></figure></li>
<li>关看门狗<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* turn off the watchdog */</span><br><span class="line"><span class="comment">#if defined(CONFIG_S3C2400)</span></span><br><span class="line"><span class="comment"># define pWTCON	0x15300000</span></span><br><span class="line"><span class="comment"># define INTMSK	0x14400008	/* Interupt-Controller base addresses */</span></span><br><span class="line"><span class="comment"># define CLKDIVN	0x14800014	/* clock divisor register */</span></span><br><span class="line"><span class="comment">#elif defined(CONFIG_S3C2410)</span></span><br><span class="line"><span class="comment"># define pWTCON	0x53000000</span></span><br><span class="line"><span class="comment"># define INTMOD 0X4A000004</span></span><br><span class="line"><span class="comment"># define INTMSK	0x4A000008	/* Interupt-Controller base addresses */</span></span><br><span class="line"><span class="comment"># define INTSUBMSK	0x4A00001C</span></span><br><span class="line"><span class="comment"># define CLKDIVN	0x4C000014	/* clock divisor register */</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410)</span></span><br><span class="line"> ldr r0, =pWTCON</span><br><span class="line"> mov r1, <span class="comment">#0x0</span></span><br><span class="line"> str r1, [r0]</span><br></pre></td></tr></table></figure></li>
<li> 屏蔽中断<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> /*</span><br><span class="line">  * mask all IRQs by setting all bits <span class="keyword">in</span> the INTMR - default</span><br><span class="line">  */</span><br><span class="line"> mov	r1, <span class="comment">#0xffffffff</span></span><br><span class="line"> ldr	r0, =INTMSK</span><br><span class="line"> str	r1, [r0]</span><br><span class="line"><span class="comment"># if defined(CONFIG_S3C2410)</span></span><br><span class="line"> ldr	r1, =0x3ff</span><br><span class="line"> ldr	r0, =INTSUBMSK</span><br><span class="line"> str	r1, [r0]</span><br><span class="line"><span class="comment"># endif</span></span><br></pre></td></tr></table></figure></li>
<li>初始化时钟<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define S3C2440_MPLL_400MHZ ((0x5c&lt;&lt;12)|(0x01&lt;&lt;4)|(0x01))</span></span><br><span class="line"><span class="comment">#define S3C2440_UPLL_48MHZ ((0x38&lt;&lt;12)|(0x02&lt;&lt;4)|(0x02))</span></span><br><span class="line"><span class="comment">#define S3C2440_CLKDIV (0x05) // | (1&lt;&lt;3)) /* FCLK:HCLK:PCLK = 1:4:8, UCLK = UPLL/2 */</span></span><br><span class="line"></span><br><span class="line"> ldr r1, =CLKDIVN</span><br><span class="line"> mov r2, <span class="comment">#S3C2440_CLKDIV</span></span><br><span class="line"> str r2, [r1]</span><br><span class="line"></span><br><span class="line"> mrc p15, 0, r1, c1, c0, 0	// <span class="built_in">read</span> ctrl register </span><br><span class="line"> orr r1, r1, <span class="comment">#0xc0000000 // Asynchronous </span></span><br><span class="line"> mcr p15, 0, r1, c1, c0, 0	// write ctrl register</span><br><span class="line"></span><br><span class="line">    ldr r0,=LOCKTIME</span><br><span class="line">    ldr r1,=0xffffff</span><br><span class="line">    str r1,[r0]</span><br><span class="line">    // delay</span><br><span class="line">    mov r0, <span class="comment">#0x200</span></span><br><span class="line">1: subs r0, r0, <span class="comment">#1</span></span><br><span class="line">    bne 1b</span><br><span class="line"></span><br><span class="line">    // Configure MPLL</span><br><span class="line">    ldr r0,=MPLLCON          </span><br><span class="line">    ldr r1,=S3C2440_MPLL_400MHZ</span><br><span class="line">    str r1,[r0]</span><br><span class="line">    // delay</span><br><span class="line">    mov r0, <span class="comment">#0x200</span></span><br><span class="line">1: subs r0, r0, <span class="comment">#1</span></span><br><span class="line">    bne 1b</span><br><span class="line"></span><br><span class="line">    //Configure UPLL</span><br><span class="line">    ldr r0, =UPLLCON          </span><br><span class="line">    ldr r1, =S3C2440_UPLL_48MHZ</span><br><span class="line">    str r1, [r0]</span><br><span class="line">    // delay</span><br><span class="line">    mov r0, <span class="comment">#0x200</span></span><br><span class="line">1: subs r0, r0, <span class="comment">#1</span></span><br><span class="line">    bne 1b</span><br></pre></td></tr></table></figure></li>
<li> 初始化sdram<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span></span><br><span class="line"> adr	r0, _start	/* r0 &lt;- current position of code */</span><br><span class="line"> ldr	r1, _TEXT_BASE	/* <span class="built_in">test</span> <span class="keyword">if</span> we run from flash or RAM */</span><br><span class="line"> cmp r0, r1 /* don<span class="string">&#x27;t reloc during debug */</span></span><br><span class="line"><span class="string"> blne	cpu_init_crit</span></span><br></pre></td></tr></table></figure>
如果_start和_TEXT_BASE不等代表代码在片内sram中运行_start为0，_TEXT_BASE为程序链接地址0x33f80000，执行cpu_init_crit<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span></span><br><span class="line">cpu_init_crit:</span><br><span class="line"> /*</span><br><span class="line">  * flush v4 I/D caches</span><br><span class="line">  */</span><br><span class="line"> mov	r0, <span class="comment">#0</span></span><br><span class="line"> mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */</span><br><span class="line"> mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * <span class="built_in">disable</span> MMU stuff and caches</span><br><span class="line">  */</span><br><span class="line"> mrc	p15, 0, r0, c1, c0, 0</span><br><span class="line"> bic	r0, r0, <span class="comment">#0x00002300	@ clear bits 13, 9:8 (--V- --RS)</span></span><br><span class="line"> bic	r0, r0, <span class="comment">#0x00000087	@ clear bits 7, 2:0 (B--- -CAM)</span></span><br><span class="line"> orr	r0, r0, <span class="comment">#0x00000002	@ set bit 2 (A) Align</span></span><br><span class="line"> orr	r0, r0, <span class="comment">#0x00001000	@ set bit 12 (I) I-Cache</span></span><br><span class="line"> mcr	p15, 0, r0, c1, c0, 0</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * before relocating, we have to setup RAM timing</span><br><span class="line">  * because memory timing is board-dependend, you will</span><br><span class="line">  * find a lowlevel_init.S <span class="keyword">in</span> your board directory.</span><br><span class="line">  */</span><br><span class="line"> mov	ip, lr</span><br><span class="line"> bl	lowlevel_init</span><br><span class="line"> mov	lr, ip</span><br><span class="line"> mov	pc, lr</span><br><span class="line"><span class="comment">#endif /* CONFIG_SKIP_LOWLEVEL_INIT */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_TEXT_BASE:</span><br><span class="line"> .word	TEXT_BASE</span><br><span class="line"></span><br><span class="line">.globl lowlevel_init</span><br><span class="line">lowlevel_init:</span><br><span class="line"> /* memory control configuration */</span><br><span class="line"> /* make r0 relative the current location so that it */</span><br><span class="line"> /* reads SMRDATA out of FLASH rather than memory ! */</span><br><span class="line"> ldr r0, =SMRDATA</span><br><span class="line"> ldr	r1, _TEXT_BASE</span><br><span class="line"> sub	r0, r0, r1</span><br><span class="line"> ldr	r1, =BWSCON	/* Bus Width Status Controller */</span><br><span class="line"> add r2, r0, <span class="comment">#13*4</span></span><br><span class="line">0:</span><br><span class="line"> ldr r3, [r0], <span class="comment">#4</span></span><br><span class="line"> str r3, [r1], <span class="comment">#4</span></span><br><span class="line"> cmp r2, r0</span><br><span class="line"> bne 0b</span><br><span class="line"></span><br><span class="line"> /* everything is fine now */</span><br><span class="line"> mov	pc, lr</span><br><span class="line"></span><br><span class="line"> .ltorg</span><br><span class="line">/* the literal pools origin */</span><br><span class="line"></span><br><span class="line">SMRDATA:</span><br><span class="line">    .word (0+(B1_BWSCON&lt;&lt;<span class="string">4)+(B2_BWSCON&lt;&lt;8)+(B3_BWSCON&lt;&lt;12)+(B4_BWSCON&lt;&lt;16)+(B5_BWSCON&lt;&lt;20)+(B6_BWSCON&lt;&lt;24)+(B7_BWSCON&lt;&lt;28)) </span></span><br><span class="line"><span class="string">    .word ((B0_Tacs&lt;&lt;13)+(B0_Tcos&lt;&lt;11)+(B0_Tacc&lt;&lt;8)+(B0_Tcoh&lt;&lt;6)+(B0_Tah&lt;&lt;4</span>)+(B0_Tacp&lt;&lt;<span class="string">2)+(B0_PMC))</span></span><br><span class="line"><span class="string">    .word ((B1_Tacs&lt;&lt;13)+(B1_Tcos&lt;&lt;11)+(B1_Tacc&lt;&lt;8)+(B1_Tcoh&lt;&lt;6)+(B1_Tah&lt;&lt;4)+(B1_Tacp&lt;&lt;2</span>)+(B1_PMC))</span><br><span class="line">    .word ((B2_Tacs&lt;&lt;<span class="string">13)+(B2_Tcos&lt;&lt;11)+(B2_Tacc&lt;&lt;8)+(B2_Tcoh&lt;&lt;6)+(B2_Tah&lt;&lt;4)+(B2_Tacp&lt;&lt;2)+(B2_PMC))</span></span><br><span class="line"><span class="string">    .word ((B3_Tacs&lt;&lt;13</span>)+(B3_Tcos&lt;&lt;<span class="string">11)+(B3_Tacc&lt;&lt;8)+(B3_Tcoh&lt;&lt;6)+(B3_Tah&lt;&lt;4)+(B3_Tacp&lt;&lt;2)+(B3_PMC))</span></span><br><span class="line"><span class="string">    .word ((B4_Tacs&lt;&lt;13)+(B4_Tcos&lt;&lt;11</span>)+(B4_Tacc&lt;&lt;<span class="string">8)+(B4_Tcoh&lt;&lt;6)+(B4_Tah&lt;&lt;4)+(B4_Tacp&lt;&lt;2)+(B4_PMC))</span></span><br><span class="line"><span class="string">    .word ((B5_Tacs&lt;&lt;13)+(B5_Tcos&lt;&lt;11)+(B5_Tacc&lt;&lt;8</span>)+(B5_Tcoh&lt;&lt;<span class="string">6)+(B5_Tah&lt;&lt;4)+(B5_Tacp&lt;&lt;2)+(B5_PMC))</span></span><br><span class="line"><span class="string">    .word ((B6_MT&lt;&lt;15)+(B6_Trcd&lt;&lt;2)+(B6_SCAN))</span></span><br><span class="line"><span class="string">    .word ((B7_MT&lt;&lt;15)+(B7_Trcd&lt;&lt;2)+(B7_SCAN))</span></span><br><span class="line"><span class="string">    .word ((REFEN&lt;&lt;23)+(TREFMD&lt;&lt;22)+(Trp&lt;&lt;20)+(Trc&lt;&lt;18)+(Tchr&lt;&lt;16)+REFCNT)</span></span><br><span class="line"><span class="string">    .word 0xb1</span></span><br><span class="line"><span class="string">    .word 0x30</span></span><br><span class="line"><span class="string">    .word 0x30</span></span><br></pre></td></tr></table></figure></li>
<li> 设置栈<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> /* Set up the stack	*/</span><br><span class="line">stack_setup:</span><br><span class="line"> ldr	r0, _TEXT_BASE	/* upper 128 KiB: relocated uboot */</span><br><span class="line"> sub	r0, r0, <span class="comment">#CFG_MALLOC_LEN	/* malloc area */</span></span><br><span class="line"> sub	r0, r0, <span class="comment">#CFG_GBL_DATA_SIZE /* bdinfo */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_USE_IRQ</span></span><br><span class="line"> sub	r0, r0, <span class="comment">#(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"> sub	sp, r0, <span class="comment">#12	/* leave 3 words for abort-stack */</span></span><br></pre></td></tr></table></figure></li>
<li>代码重定位flash到ram<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ldr	r2, _armboot_start</span><br><span class="line"> ldr	r3, _bss_start</span><br><span class="line"> sub	r2, r3, r2	/* r2 &lt;- size of armboot */</span><br><span class="line"><span class="comment">#if 1</span></span><br><span class="line"> bl CopyCode2Ram	/* r0: <span class="built_in">source</span>, r1: dest, r2: size */</span><br><span class="line"><span class="comment">#else</span></span><br></pre></td></tr></table></figure>
通过ro,r1,r2向c语言传递参数</li>
<li> 清bss段<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clear_bss:</span><br><span class="line"> ldr	r0, _bss_start	/* find start of bss segment */</span><br><span class="line"> ldr	r1, _bss_end	/* stop here */</span><br><span class="line"> mov r2, <span class="comment">#0x00000000	/* clear  </span></span><br></pre></td></tr></table></figure></li>
<li> 调用_start_armboot，进入c语言环境uboot的第二阶段</li>
</ul>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>start stage</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-Makefile</title>
    <url>/2018/08/24/u-boot-Makefile/</url>
    <content><![CDATA[<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VERSION = 2019      //主版本号</span><br><span class="line">PATCHLEVEL = 10     //补丁版本号</span><br><span class="line">SUBLEVEL =          //次版本号</span><br><span class="line">EXTRAVERSION = -rc2 //附加版本信息</span><br><span class="line">NAME =</span><br></pre></td></tr></table></figure>
<h3 id="MAKEFLAGS"><a href="#MAKEFLAGS" class="headerlink" title="MAKEFLAGS"></a>MAKEFLAGS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MAKEFLAGS += -rR --include-dir=$(CURDIR)   // -rR 禁止使用内置的隐含规则和变量定义，--include-dir指明搜索路径</span><br><span class="line">$(MAKE) -C subdir                          //编译子目录下代码</span><br></pre></td></tr></table></figure>
<h3 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifeq (<span class="string">&quot;<span class="subst">$(origin V)</span>&quot;</span>, <span class="string">&quot;command line&quot;</span>) //判断V是否来自命令行</span><br><span class="line">  KBUILD_VERBOSE = $(V)</span><br><span class="line">endif</span><br><span class="line">ifndef KBUILD_VERBOSE</span><br><span class="line">  KBUILD_VERBOSE = 0</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(KBUILD_VERBOSE),1)</span><br><span class="line">  quiet =</span><br><span class="line">  Q =</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  quiet=quiet_</span><br><span class="line">  Q = @</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>Makefile中使用$(Q)$(MAKE)$(build)=tools如果V=1定义的话Q为空否则为@在命令前加上@就不会在终端输出日志了，同样quiet_开头的命令和不带quiet_开头的命令差别在于带quiet_的命令输出日志少</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ifneq ($(filter 4.%,$(MAKE_VERSION)),)  <span class="comment"># make-4</span></span><br><span class="line">ifneq ($(filter %s ,$(firstword x$(MAKEFLAGS))),)</span><br><span class="line">  quiet=silent_</span><br><span class="line">endif</span><br><span class="line"><span class="keyword">else</span>          <span class="comment"># make-3.8x</span></span><br><span class="line">ifneq ($(filter s% -s%,$(MAKEFLAGS)),) //使用-s选项quiet=silent_则不输出日志</span><br><span class="line">  quiet=silent_</span><br><span class="line">endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<h3 id="编译结果输出目录"><a href="#编译结果输出目录" class="headerlink" title="编译结果输出目录"></a>编译结果输出目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ifeq (<span class="string">&quot;<span class="subst">$(origin O)</span>&quot;</span>, <span class="string">&quot;command line&quot;</span>) //使用-o指定</span><br><span class="line">  KBUILD_OUTPUT := $(O)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<h3 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use make M=dir to specify directory of external module to build</span></span><br><span class="line"><span class="comment"># Old syntax make ... SUBDIRS=$PWD is still supported</span></span><br><span class="line"><span class="comment"># Setting the environment variable KBUILD_EXTMOD take precedence</span></span><br><span class="line">ifdef SUBDIRS</span><br><span class="line">  KBUILD_EXTMOD ?= $(SUBDIRS)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq (<span class="string">&quot;<span class="subst">$(origin M)</span>&quot;</span>, <span class="string">&quot;command line&quot;</span>)</span><br><span class="line">  KBUILD_EXTMOD := $(M)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># If building an external module we do not care about the all: rule</span></span><br><span class="line"><span class="comment"># but instead _all depend on modules</span></span><br><span class="line">PHONY += all</span><br><span class="line">ifeq ($(KBUILD_EXTMOD),)</span><br><span class="line">_all: all</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">_all: modules</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(KBUILD_SRC),)</span><br><span class="line">        <span class="comment"># building in the source tree</span></span><br><span class="line">        srctree := .</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR)))</span><br><span class="line">                <span class="comment"># building in a subdirectory of the source tree</span></span><br><span class="line">                srctree := ..</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                srctree := $(KBUILD_SRC)</span><br><span class="line">        endif</span><br><span class="line">endif</span><br><span class="line">objtree   := .</span><br><span class="line">src   := $(srctree)</span><br><span class="line">obj   := $(objtree)</span><br><span class="line"></span><br><span class="line">VPATH   := $(srctree)$(<span class="keyword">if</span> $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> srctree objtree VPATH</span><br></pre></td></tr></table></figure>
<h3 id="获取主机架构"><a href="#获取主机架构" class="headerlink" title="获取主机架构"></a>获取主机架构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOSTARCH := $(shell uname -m | \</span><br><span class="line">  sed -e s/i.86/x86/ \</span><br><span class="line">      -e s/sun4u/sparc64/ \</span><br><span class="line">      -e s/arm.*/arm/ \</span><br><span class="line">      -e s/sa110/arm/ \</span><br><span class="line">      -e s/ppc64/powerpc/ \</span><br><span class="line">      -e s/ppc/powerpc/ \</span><br><span class="line">      -e s/macppc/powerpc/\</span><br><span class="line">      -e s/sh.*/sh/)</span><br><span class="line"></span><br><span class="line">HOSTOS := $(shell uname -s | tr <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span> | \</span><br><span class="line">      sed -e <span class="string">&#x27;s/\(cygwin\).*/cygwin/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="设置编译工具"><a href="#设置编译工具" class="headerlink" title="设置编译工具"></a>设置编译工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set default to nothing for native builds</span></span><br><span class="line">ifeq ($(HOSTARCH),$(ARCH)) //主机架构和命令行指定架构是否相同，这里不同使用命令行的CROSS_COMPILE</span><br><span class="line">CROSS_COMPILE ?=</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">KCONFIG_CONFIG  ?= .config  //配置文件</span><br><span class="line"><span class="built_in">export</span> KCONFIG_CONFIG</span><br></pre></td></tr></table></figure>
<h3 id="调用scripts-Kbuild-include"><a href="#调用scripts-Kbuild-include" class="headerlink" title="调用scripts/Kbuild.include"></a>调用scripts/Kbuild.include</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We need some generic definitions (do not try to remake the file).</span></span><br><span class="line">scripts/Kbuild.include: ;</span><br><span class="line">include scripts/Kbuild.include</span><br></pre></td></tr></table></figure>
<h3 id="交叉编译工具变量设置"><a href="#交叉编译工具变量设置" class="headerlink" title="交叉编译工具变量设置"></a>交叉编译工具变量设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Make variables (CC, etc...)</span></span><br><span class="line"></span><br><span class="line">AS    = $(CROSS_COMPILE)as</span><br><span class="line"><span class="comment"># Always use GNU ld</span></span><br><span class="line">ifneq ($(shell $(CROSS_COMPILE)ld.bfd -v 2&gt; /dev/null),)</span><br><span class="line">LD    = $(CROSS_COMPILE)ld.bfd</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LD    = $(CROSS_COMPILE)ld</span><br><span class="line">endif</span><br><span class="line">CC    = $(CROSS_COMPILE)gcc</span><br><span class="line">CPP   = $(CC) -E</span><br><span class="line">AR    = $(CROSS_COMPILE)ar</span><br><span class="line">NM    = $(CROSS_COMPILE)nm</span><br><span class="line">LDR   = $(CROSS_COMPILE)ldr</span><br><span class="line">STRIP   = $(CROSS_COMPILE)strip</span><br><span class="line">OBJCOPY   = $(CROSS_COMPILE)objcopy</span><br><span class="line">OBJDUMP   = $(CROSS_COMPILE)objdump</span><br><span class="line">LEX   = flex</span><br><span class="line">YACC    = bison</span><br><span class="line">AWK   = awk</span><br><span class="line">PERL    = perl</span><br><span class="line">PYTHON    ?= python</span><br><span class="line">PYTHON2   = python2</span><br><span class="line">PYTHON3   = python3</span><br><span class="line">DTC   ?= $(objtree)/scripts/dtc/dtc</span><br><span class="line">CHECK   = sparse</span><br><span class="line"></span><br><span class="line">CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \</span><br><span class="line">      -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)</span><br><span class="line"></span><br><span class="line">KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__</span><br><span class="line"></span><br><span class="line">KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \</span><br><span class="line">       -Wno-format-security \</span><br><span class="line">       -fno-builtin -ffreestanding $(CSTD_FLAG)</span><br><span class="line">KBUILD_CFLAGS += -fshort-wchar -fno-strict-aliasing</span><br><span class="line">KBUILD_AFLAGS   := -D__ASSEMBLY__</span><br><span class="line"></span><br><span class="line"><span class="comment"># Don&#x27;t generate position independent code</span></span><br><span class="line">KBUILD_CFLAGS += $(call cc-option,-fno-PIE)</span><br><span class="line">KBUILD_AFLAGS += $(call cc-option,-fno-PIE)</span><br></pre></td></tr></table></figure>
<h3 id="导出其他变量"><a href="#导出其他变量" class="headerlink" title="导出其他变量"></a>导出其他变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION</span><br><span class="line"><span class="built_in">export</span> ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR</span><br><span class="line"><span class="built_in">export</span> CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC</span><br><span class="line"><span class="built_in">export</span> CPP AR NM LDR STRIP OBJCOPY OBJDUMP</span><br><span class="line"><span class="built_in">export</span> MAKE LEX YACC AWK PERL PYTHON PYTHON2 PYTHON3</span><br><span class="line"><span class="built_in">export</span> HOSTCXX HOSTCXXFLAGS CHECK CHECKFLAGS DTC DTC_FLAGS</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS</span><br><span class="line"><span class="built_in">export</span> KBUILD_CFLAGS KBUILD_AFLAGS</span><br></pre></td></tr></table></figure>
<p>其中ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR这几个变量定义在config.mk文件中，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PLATFORM_RELFLAGS :=</span><br><span class="line">PLATFORM_CPPFLAGS :=</span><br><span class="line">PLATFORM_LDFLAGS :=</span><br><span class="line">LDFLAGS :=</span><br><span class="line">LDFLAGS_FINAL :=</span><br><span class="line">LDFLAGS_STANDALONE :=</span><br><span class="line">OBJCOPYFLAGS :=</span><br><span class="line"><span class="comment"># clear VENDOR for tcsh</span></span><br><span class="line">VENDOR :=</span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"></span><br><span class="line">ARCH := $(CONFIG_SYS_ARCH:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">CPU := $(CONFIG_SYS_CPU:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">ifdef CONFIG_SPL_BUILD</span><br><span class="line">ifdef CONFIG_TEGRA</span><br><span class="line">CPU := arm720t</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">BOARD := $(CONFIG_SYS_BOARD:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">ifneq ($(CONFIG_SYS_VENDOR),)</span><br><span class="line">VENDOR := $(CONFIG_SYS_VENDOR:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(CONFIG_SYS_SOC),)</span><br><span class="line">SOC := $(CONFIG_SYS_SOC:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<h3 id="make-pine-h64-defconfig"><a href="#make-pine-h64-defconfig" class="headerlink" title="make pine_h64_defconfig"></a>make pine_h64_defconfig</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># To make sure we do not include .config for any of the *config targets</span></span><br><span class="line"><span class="comment"># catch them early, and hand them over to scripts/kconfig/Makefile</span></span><br><span class="line"><span class="comment"># It is allowed to specify more targets when calling make, including</span></span><br><span class="line"><span class="comment"># mixing *config targets and build targets.</span></span><br><span class="line"><span class="comment"># For example &#x27;make oldconfig all&#x27;.</span></span><br><span class="line"><span class="comment"># Detect when mixed targets is specified, and make a second invocation</span></span><br><span class="line"><span class="comment"># of make so .config is not included in this case either (for *config).</span></span><br><span class="line"></span><br><span class="line">version_h := include/generated/version_autogenerated.h   //定义version.h</span><br><span class="line">timestamp_h := include/generated/timestamp_autogenerated.h</span><br><span class="line">defaultenv_h := include/generated/defaultenv_autogenerated.h</span><br><span class="line"></span><br><span class="line">no-dot-config-targets := clean clobber mrproper distclean \</span><br><span class="line">       <span class="built_in">help</span> %docs check% coccicheck \</span><br><span class="line">       ubootversion backup tests check qcheck</span><br><span class="line"></span><br><span class="line">config-targets := 0</span><br><span class="line">mixed-targets  := 0</span><br><span class="line">dot-config     := 1</span><br><span class="line"></span><br><span class="line">ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)</span><br><span class="line">  ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)</span><br><span class="line">    dot-config := 0</span><br><span class="line">  endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(KBUILD_EXTMOD),)</span><br><span class="line">        ifneq ($(filter config %config,$(MAKECMDGOALS)),)</span><br><span class="line">                config-targets := 1</span><br><span class="line">                ifneq ($(words $(MAKECMDGOALS)),1)</span><br><span class="line">                        mixed-targets := 1</span><br><span class="line">                endif</span><br><span class="line">        endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(mixed-targets),1)</span><br><span class="line"><span class="comment"># ===========================================================================</span></span><br><span class="line"><span class="comment"># We&#x27;re called with mixed targets (*config and build targets).</span></span><br><span class="line"><span class="comment"># Handle them one by one.</span></span><br><span class="line"></span><br><span class="line">PHONY += $(MAKECMDGOALS) __build_one_by_one</span><br><span class="line"></span><br><span class="line">$(filter-out __build_one_by_one, $(MAKECMDGOALS)): __build_one_by_one</span><br><span class="line">  @:</span><br><span class="line"></span><br><span class="line">__build_one_by_one:</span><br><span class="line">  $(Q)<span class="built_in">set</span> -e; \</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(MAKECMDGOALS); <span class="keyword">do</span> \</span><br><span class="line">    $(MAKE) -f $(srctree)/Makefile $<span class="variable">$i</span>; \</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ifeq ($(config-targets),1)</span><br><span class="line"><span class="comment"># ===========================================================================</span></span><br><span class="line"><span class="comment"># *config targets only - make sure prerequisites are updated, and descend</span></span><br><span class="line"><span class="comment"># in scripts/kconfig to make the *config target</span></span><br><span class="line"></span><br><span class="line">KBUILD_DEFCONFIG := sandbox_defconfig</span><br><span class="line"><span class="built_in">export</span> KBUILD_DEFCONFIG KBUILD_KCONFIG</span><br><span class="line"></span><br><span class="line">config: scripts_basic outputmakefile FORCE</span><br><span class="line">  $(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%config: scripts_basic outputmakefile FORCE //匹配到这里，依赖scripts_basic outputmakefile</span><br><span class="line">  $(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># ===========================================================================</span></span><br><span class="line"><span class="comment"># Build targets only - this includes vmlinux, arch specific targets, clean</span></span><br><span class="line"><span class="comment"># targets and others. In general all targets except *config targets.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Additional helpers built in scripts/</span></span><br><span class="line"><span class="comment"># Carefully list dependencies so we do not try to build scripts twice</span></span><br><span class="line"><span class="comment"># in parallel</span></span><br><span class="line">PHONY += scripts</span><br><span class="line">scripts: scripts_basic include/config/auto.conf</span><br><span class="line">  $(Q)$(MAKE) $(build)=$(@)</span><br><span class="line"></span><br><span class="line">ifeq ($(dot-config),1)</span><br><span class="line"><span class="comment"># Read in config</span></span><br><span class="line">-include include/config/auto.conf</span><br></pre></td></tr></table></figure>
<p>重点看这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%config: scripts_basic outputmakefile FORCE //匹配到这里，依赖scripts_basic outputmakefile</span><br><span class="line">  $(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Basic helpers built in scripts/</span></span><br><span class="line">PHONY += scripts_basic</span><br><span class="line">scripts_basic:</span><br><span class="line">  $(Q)$(MAKE) $(build)=scripts/basic //变量build定义在scripts/Kbuild.include文件中,展开如下</span><br><span class="line">  //build := -f $(srctree)/scripts/Makefile.build obj=scripts/basic其中srctree为“.”</span><br><span class="line">  $(Q)rm -f .tmp_quiet_recordmcount</span><br><span class="line"></span><br><span class="line"><span class="comment"># To avoid any implicit rule to kick in, define an empty command.</span></span><br><span class="line">scripts/basic/%: scripts_basic ;</span><br><span class="line"></span><br><span class="line">PHONY += outputmakefile</span><br><span class="line"><span class="comment"># outputmakefile generates a Makefile in the output directory, if using a</span></span><br><span class="line"><span class="comment"># separate output directory. This allows convenient use of make in the</span></span><br><span class="line"><span class="comment"># output directory.</span></span><br><span class="line">outputmakefile:</span><br><span class="line">ifneq ($(KBUILD_SRC),) //KBUILD_SRC为空，不执行</span><br><span class="line">  $(Q)ln -fsn $(srctree) <span class="built_in">source</span></span><br><span class="line">  $(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \</span><br><span class="line">      $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>将命令展开为如下两条命令<br>make scripts/Makefile.build obj=scripts/basic //编译scripts/basic/fixdep文件<br>make scripts/Makefile.build obj=scripts/kconfig pine_h64_defconfig //生成.config文件<br><img src="/picture/uboot-makefile-1.png" alt="流程"></p>
<p>执行make pine_h64_defconfig V=1，得到如下输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=scripts/basic</span><br><span class="line">  cc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer  -std=gnu11     -o scripts/basic/fixdep scripts/basic/fixdep.c  </span><br><span class="line">rm -f .tmp_quiet_recordmcount</span><br><span class="line">make -f ./scripts/Makefile.build obj=scripts/kconfig pine_h64_defconfig</span><br><span class="line">  cc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer  -std=gnu11   -D_GNU_SOURCE -D_DEFAULT_SOURCE  -DCURSES_LOC=<span class="string">&quot;&lt;ncurses.h&gt;&quot;</span> -DNCURSES_WIDECHAR=1 -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c</span><br><span class="line">  bison -oscripts/kconfig/zconf.tab.c -t -l scripts/kconfig/zconf.y</span><br><span class="line">  flex -oscripts/kconfig/zconf.lex.c -L scripts/kconfig/zconf.l</span><br><span class="line">  cc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer  -std=gnu11   -D_GNU_SOURCE -D_DEFAULT_SOURCE  -DCURSES_LOC=<span class="string">&quot;&lt;ncurses.h&gt;&quot;</span> -DNCURSES_WIDECHAR=1 -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c</span><br><span class="line">  cc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o  </span><br><span class="line">scripts/kconfig/conf  --defconfig=arch/../configs/pine_h64_defconfig Kconfig</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># configuration written to .config</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>根据这个来分析在makefile中的行为。scripts/Makefile.build这个在makefile中搜索不到scripts/basic可以在makefile中找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Basic helpers built in scripts/</span></span><br><span class="line">PHONY += scripts_basic</span><br><span class="line">scripts_basic:</span><br><span class="line">	$(Q)$(MAKE) $(build)=scripts/basic</span><br><span class="line">	$(Q)rm -f .tmp_quiet_recordmcount</span><br></pre></td></tr></table></figure>
<p>根据这个继续查找</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KBUILD_DEFCONFIG := sandbox_defconfig</span><br><span class="line"><span class="built_in">export</span> KBUILD_DEFCONFIG KBUILD_KCONFIG</span><br><span class="line"></span><br><span class="line">config: scripts_basic outputmakefile FORCE</span><br><span class="line">	$(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%config: scripts_basic outputmakefile FORCE</span><br><span class="line">	$(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>可以看到应该是匹配的%的这个语句，Q值根据make是否传入V=1来决定是空还是@</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifeq (<span class="string">&quot;<span class="subst">$(origin V)</span>&quot;</span>, <span class="string">&quot;command line&quot;</span>)</span><br><span class="line">  KBUILD_VERBOSE = $(V)</span><br><span class="line">endif</span><br><span class="line">ifndef KBUILD_VERBOSE</span><br><span class="line">  KBUILD_VERBOSE = 0</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(KBUILD_VERBOSE),1)</span><br><span class="line">  quiet =</span><br><span class="line">  Q =</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  quiet=quiet_</span><br><span class="line">  Q = @</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>作用是是否显示编译过程详细信息加上V=1表示输出详细信息。MAKE就是make，Makefile定义的变量而build通过查找可以发现在script/Kbuild.include文件里如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">build := -f $(srctree)/scripts/Makefile.build obj</span><br></pre></td></tr></table></figure>
<ol>
<li><p> 先看第一个依赖scripts_basic展开就是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f $(srctree)/scripts/Makefile.build obj=scripts/basic </span><br><span class="line">rm -f .tmp_quiet_recordmcount</span><br></pre></td></tr></table></figure>
<p>现在进入Makefile.build文件，编译__build</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__build: $(<span class="keyword">if</span> $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \</span><br><span class="line">	 $(<span class="keyword">if</span> $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \</span><br><span class="line">	 $(subdir-ym) $(always)</span><br><span class="line">	@:</span><br></pre></td></tr></table></figure>
<p>KBUILD_BUILTIN和KBUILD_MODULES可以在顶层Makefile中找到如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KBUILD_MODULES :=</span><br><span class="line">KBUILD_BUILTIN := 1</span><br></pre></td></tr></table></figure>
<p>对其展开得到</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">__build: <span class="constructor">$(<span class="params">builtin</span>-<span class="params">target</span>)</span> <span class="constructor">$(<span class="params">lib</span>-<span class="params">target</span>)</span> <span class="constructor">$(<span class="params">extra</span>-<span class="params">y</span>)</span> <span class="constructor">$(<span class="params">subdir</span>-<span class="params">ym</span>)</span> <span class="constructor">$(<span class="params">always</span>)</span></span><br><span class="line">        @：</span><br></pre></td></tr></table></figure>
<p>先看$(builtin-target)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifneq ($(strip $(obj-y) $(obj-m) $(obj-) $(subdir-m) $(lib-target)),)</span><br><span class="line">builtin-target := $(obj)/built-in.o</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>strip是去掉参数的空格，查找obj-y、obj-m、obj-、subdir-m、lib-target的定义为空如下且其他文件中没有定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obj-y :=</span><br><span class="line">obj-m :=</span><br><span class="line">lib-y :=</span><br><span class="line">lib-m :=</span><br><span class="line">always :=</span><br><span class="line">targets :=</span><br><span class="line">subdir-y :=</span><br><span class="line">subdir-m :=</span><br><span class="line">EXTRA_AFLAGS   :=</span><br><span class="line">EXTRA_CFLAGS   :=</span><br><span class="line">EXTRA_CPPFLAGS :=</span><br><span class="line">EXTRA_LDFLAGS  :=</span><br><span class="line">asflags-y  :=</span><br><span class="line">ccflags-y  :=</span><br><span class="line">cppflags-y :=</span><br><span class="line">ldflags-y  :=</span><br><span class="line">...</span><br><span class="line">ifneq ($(strip $(lib-y) $(lib-m) $(lib-)),)</span><br><span class="line">lib-target := $(obj)/lib.a</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>依次看下去$(builtin-target) $(lib-target) $(extra-y)都为空最后得到</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">__build: <span class="constructor">$(<span class="params">subdir</span>-<span class="params">ym</span>)</span> <span class="constructor">$(<span class="params">always</span>)</span></span><br><span class="line">        @：</span><br></pre></td></tr></table></figure>
<p>下面根据include的文件查找always和subdir-ym</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include scripts/Makefile.uncmd_spl</span><br><span class="line"></span><br><span class="line">include scripts/Kbuild.include</span><br><span class="line"></span><br><span class="line">kbuild-dir := $(<span class="keyword">if</span> $(filter /%,$(src)),$(src),$(srctree)/$(src))</span><br><span class="line">kbuild-file := $(<span class="keyword">if</span> $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)</span><br><span class="line">include $(kbuild-file)</span><br><span class="line">...</span><br><span class="line">include scripts/Makefile.lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not include host rules unless needed</span></span><br><span class="line">ifneq ($(hostprogs-y)$(hostprogs-m),)</span><br><span class="line">include scripts/Makefile.host</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>subdir-ym没在包含的文件内，always的定义在script/base/Makefile如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostprogs-y	:= fixdep</span><br><span class="line">always		:= $(hostprogs-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixdep is needed to compile other host programs</span></span><br><span class="line">$(addprefix $(obj)/,$(filter-out fixdep,$(always))): $(obj)/fixdep</span><br></pre></td></tr></table></figure>
<p>编译主机使用的文件规则在Makefile.host文件里，最后编译了fixdep.c这个文件生成fixdep文件.</p>
</li>
<li><p>生成第二个依赖outputmakefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY += outputmakefile</span><br><span class="line"><span class="comment"># outputmakefile generates a Makefile in the output directory, if using a</span></span><br><span class="line"><span class="comment"># separate output directory. This allows convenient use of make in the</span></span><br><span class="line"><span class="comment"># output directory.</span></span><br><span class="line"><span class="section">outputmakefile:</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KBUILD_SRC)</span>,)</span><br><span class="line">	<span class="variable">$(Q)</span>ln -fsn <span class="variable">$(srctree)</span> source</span><br><span class="line">	<span class="variable">$(Q)</span><span class="variable">$(CONFIG_SHELL)</span> <span class="variable">$(srctree)</span>/scripts/mkmakefile \</span><br><span class="line">	    <span class="variable">$(srctree)</span> <span class="variable">$(objtree)</span> <span class="variable">$(VERSION)</span> <span class="variable">$(PATCHLEVEL)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>KBUILD_SRC未定义，什么也不做。FORCE伪目标，什么也不做，FORCE做依赖时，目标认为依赖总是最新的</p>
</li>
<li><p>$(Q)$(MAKE) $(build)=scripts/kconfig $@<br>make -f $(srctree)/scripts/Makefile.build obj=scripts/kconfig pine_h64_defconfig<br>向Makefile.build传递obj=scripts/kconfig并构建pine_h64_defconfig<br>进入script/Kconfig/Makefile匹配如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%_defconfig: $(obj)/conf</span><br><span class="line">  $(Q)$&lt; $(silent) --defconfig=arch/$(SRCARCH)/configs/<span class="variable">$@</span> $(Kconfig)</span><br></pre></td></tr></table></figure>
<p>silent定义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SRCARCH := ..</span><br><span class="line"></span><br><span class="line">ifdef KBUILD_KCONFIG</span><br><span class="line">Kconfig := $(KBUILD_KCONFIG)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Kconfig := Kconfig</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(quiet),silent_)</span><br><span class="line">silent := -s</span><br><span class="line">endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Kconfig := Kconfig<br>因此展开得到<br>pine_h64_defconfig scripts/kconfig/conf<br>   scripts/kconfig/conf  –defconfig=arch/../configs/pine_h64_defconfig Kconfig</p>
</li>
</ol>
<p>先看scripts/kconfig/conf这个依赖项，conf这个在如下相关信息中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conf-objs := conf.o  zconf.tab.o</span><br><span class="line">hostprogs-y := conf nconf mconf kxgettext qconf gconf</span><br></pre></td></tr></table></figure>
<p>在Makefile.host文件里有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__hostprogs := $(sort $(hostprogs-y) $(hostprogs-m))</span><br></pre></td></tr></table></figure>
<p>这个文件中会分析相关依赖，对conf.c,zconf.tab.c,zconf.tab.c文件进行编译。<br>最后调用scripts/kconfig/conf  –defconfig=arch/../configs/pine_h64_defconfig Kconfig，该命令将执行上一步生成的conf文件，该文件读取pine_h64_defconfig文件并生成新的文件放入.config文件中，完成配置过程。</p>
<h3 id="make过程"><a href="#make过程" class="headerlink" title="make过程"></a>make过程</h3><p>执行make按照默认目标all生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">all:    $(ALL-y)</span><br><span class="line">ifeq ($(CONFIG_DEPRECATED),y)</span><br><span class="line">  $(warning <span class="string">&quot;You have deprecated configuration options enabled in your .config! Please check your configuration.&quot;</span>)</span><br><span class="line">ifeq ($(CONFIG_SPI),y)</span><br><span class="line">ifneq ($(CONFIG_DM_SPI)$(CONFIG_OF_CONTROL),yy)</span><br><span class="line">  $(warning <span class="string">&quot;The relevant config item with associated code will remove in v2019.07 release.&quot;</span>)</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">ifeq ($(CONFIG_MMC),y)</span><br><span class="line">ifneq ($(CONFIG_DM_MMC)$(CONFIG_OF_CONTROL)$(CONFIG_BLK),yyy)</span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;===================== WARNING ======================&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;This board does not use CONFIG_DM_MMC. Please update&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;the board to use CONFIG_DM_MMC before the v2019.04 release.&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;Failure to update by the deadline may result in board removal.&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;See doc/driver-model/MIGRATION.txt for more info.&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;====================================================&quot;</span></span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">ifeq ($(CONFIG_USB),y)</span><br><span class="line">ifneq ($(CONFIG_DM_USB)$(CONFIG_OF_CONTROL)$(CONFIG_BLK),yyy)</span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;===================== WARNING ======================&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;This board does not use CONFIG_DM_USB. Please update&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;the board to use CONFIG_DM_USB before the v2019.07 release.&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;Failure to update by the deadline may result in board removal.&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;See doc/driver-model/MIGRATION.txt for more info.&quot;</span></span><br><span class="line">  @<span class="built_in">echo</span> &gt;&amp;2 <span class="string">&quot;====================================================&quot;</span></span><br><span class="line">endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>其中ALL-y内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Always append ALL so that arch config.mk&#x27;s can add custom ones</span></span><br><span class="line">ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check</span><br><span class="line"></span><br><span class="line">ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin</span><br><span class="line">ifeq ($(CONFIG_SPL_FSL_PBL),y)</span><br><span class="line">ALL-$(CONFIG_RAMBOOT_PBL) += u-boot-with-spl-pbl.bin</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ifneq ($(CONFIG_SECURE_BOOT), y)</span><br><span class="line"><span class="comment"># For Secure Boot The Image needs to be signed and Header must also</span></span><br><span class="line"><span class="comment"># be included. So The image has to be built explicitly</span></span><br><span class="line">ALL-$(CONFIG_RAMBOOT_PBL) += u-boot.pbl</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">ALL-$(CONFIG_SPL) += spl/u-boot-spl.bin</span><br><span class="line">ifeq ($(CONFIG_MX6)$(CONFIG_SECURE_BOOT), yy)</span><br><span class="line">ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot-ivt.img</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ifeq ($(CONFIG_MX7)$(CONFIG_SECURE_BOOT), yy)</span><br><span class="line">ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot-ivt.img</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot.img</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">ALL-$(CONFIG_TPL) += tpl/u-boot-tpl.bin</span><br><span class="line">ALL-$(CONFIG_OF_SEPARATE) += u-boot.dtb</span><br><span class="line">ifeq ($(CONFIG_SPL_FRAMEWORK),y)</span><br><span class="line">ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb.img</span><br><span class="line">endif</span><br><span class="line">ALL-$(CONFIG_OF_HOSTFILE) += u-boot.dtb</span><br><span class="line">ifneq ($(CONFIG_SPL_TARGET),)</span><br><span class="line">ALL-$(CONFIG_SPL) += $(CONFIG_SPL_TARGET:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">endif</span><br><span class="line">ALL-$(CONFIG_REMAKE_ELF) += u-boot.elf</span><br><span class="line">ALL-$(CONFIG_EFI_APP) += u-boot-app.efi</span><br><span class="line">ALL-$(CONFIG_EFI_STUB) += u-boot-payload.efi</span><br><span class="line"></span><br><span class="line">ifneq ($(BUILD_ROM)$(CONFIG_BUILD_ROM),)</span><br><span class="line">ALL-$(CONFIG_X86_RESET_VECTOR) += u-boot.rom</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a combined spl + u-boot image for sunxi</span></span><br><span class="line">ifeq ($(CONFIG_ARCH_SUNXI)$(CONFIG_SPL),yy)</span><br><span class="line">ALL-y += u-boot-sunxi-with-spl.bin</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable combined SPL/u-boot/dtb rules for tegra</span></span><br><span class="line">ifeq ($(CONFIG_TEGRA)$(CONFIG_SPL),yy)</span><br><span class="line">ALL-y += u-boot-tegra.bin u-boot-nodtb-tegra.bin</span><br><span class="line">ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb-tegra.bin</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ALL-$(CONFIG_ARCH_MEDIATEK) += u-boot-mtk.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add optional build target if defined in board/cpu/soc headers</span></span><br><span class="line">ifneq ($(CONFIG_BUILD_TARGET),)</span><br><span class="line">ALL-y += $(CONFIG_BUILD_TARGET:<span class="string">&quot;%&quot;</span>=%)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifdef CONFIG_INIT_SP_RELATIVE</span><br><span class="line">ALL-y += init_sp_bss_offset_check</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(CONFIG_MPC85xx)$(CONFIG_OF_SEPARATE),yy)</span><br><span class="line">ALL-y += u-boot-with-dtb.bin</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>其中u-boot.bin依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifneq ($(EXT_DTB),)</span><br><span class="line">u-boot-fit-dtb.bin: u-boot-nodtb.bin $(EXT_DTB)</span><br><span class="line">    $(call if_changed,cat)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">u-boot-fit-dtb.bin: u-boot-nodtb.bin $(FINAL_DTB_CONTAINER)</span><br><span class="line">  $(call if_changed,cat)</span><br><span class="line">endif</span><br><span class="line">...</span><br><span class="line">u-boot-nodtb.bin: u-boot FORCE</span><br><span class="line">  $(call if_changed,objcopy)</span><br><span class="line">  $(call DO_STATIC_RELA,$&lt;,<span class="variable">$@</span>,$(CONFIG_SYS_TEXT_BASE))</span><br><span class="line">  $(BOARD_SIZE_CHECK)</span><br><span class="line">...</span><br><span class="line">u-boot: $(u-boot-init) $(u-boot-main) u-boot.lds FORCE</span><br><span class="line">  +$(call if_changed,u-boot__)</span><br><span class="line">ifeq ($(CONFIG_KALLSYMS),y)</span><br><span class="line">  $(call cmd,smap)</span><br><span class="line">  $(call cmd,u-boot__) common/system_map.o</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(CONFIG_RISCV),y)</span><br><span class="line">  @tools/prelink-riscv <span class="variable">$@</span> 0</span><br><span class="line">endif</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">u-boot-init := $(head-y)</span><br><span class="line">u-boot-main := $(libs-y)</span><br><span class="line">...</span><br><span class="line">u-boot.bin: u-boot-fit-dtb.bin FORCE</span><br><span class="line">  $(call if_changed,copy)</span><br></pre></td></tr></table></figure>
<p>总体流程如下：<br><img src="/picture/uboot-make.png" alt="make"></p>
<p>声明：本文参考<a href="https://blog.csdn.net/yanggx0929/article/details/87883886%E5%92%8C%E5%8E%9F%E5%AD%90%E6%96%87%E6%A1%A3">https://blog.csdn.net/yanggx0929/article/details/87883886和原子文档</a></p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-atf</title>
    <url>/2018/08/27/u-boot-atf/</url>
    <content><![CDATA[<h3 id="bl31-main"><a href="#bl31-main" class="headerlink" title="bl31_main"></a>bl31_main</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void bl31_main(void)</span><br><span class="line">&#123;</span><br><span class="line">	NOTICE(<span class="string">&quot;BL31: %s\n&quot;</span>, version_string); //u-boot启动过程中打印的信息</span><br><span class="line">	NOTICE(<span class="string">&quot;BL31: %s\n&quot;</span>, build_message);</span><br><span class="line"></span><br><span class="line">	/* Perform platform setup <span class="keyword">in</span> BL31 */</span><br><span class="line">	bl31_platform_setup();</span><br><span class="line"></span><br><span class="line">	/* Initialise helper libraries */</span><br><span class="line">	bl31_lib_init(); //什么也没做</span><br><span class="line"></span><br><span class="line"><span class="comment">#if EL3_EXCEPTION_HANDLING</span></span><br><span class="line">	INFO(<span class="string">&quot;BL31: Initialising Exception Handling Framework\n&quot;</span>);</span><br><span class="line">	ehf_init();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* Initialize the runtime services e.g. psci. */</span><br><span class="line">	INFO(<span class="string">&quot;BL31: Initializing runtime services\n&quot;</span>);</span><br><span class="line">	runtime_svc_init();</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * All the cold boot actions on the primary cpu are <span class="keyword">done</span>. We now need to</span><br><span class="line">	 * decide <span class="built_in">which</span> is the next image (BL32 or BL33) and how to execute it.</span><br><span class="line">	 * If the SPD runtime service is present, it would want to pass control</span><br><span class="line">	 * to BL32 first <span class="keyword">in</span> S-EL1. In that <span class="keyword">case</span>, SPD would have registered a</span><br><span class="line">	 * <span class="keyword">function</span> to intialize bl32 <span class="built_in">where</span> it takes responsibility of entering</span><br><span class="line">	 * S-EL1 and returning control back to bl31_main. Once this is <span class="keyword">done</span> we</span><br><span class="line">	 * can prepare entry into BL33 as normal.</span><br><span class="line">	 */</span><br><span class="line">	 // 冷启动部分已经完成</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If SPD had registerd an init hook, invoke it.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (bl32_init != NULL) &#123;</span><br><span class="line">		INFO(<span class="string">&quot;BL31: Initializing BL32\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		int32_t rc = (*bl32_init)();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rc != 0) &#123;</span><br><span class="line">			ERROR(<span class="string">&quot;BL31: BL32 initialization failed (rc = %d)&quot;</span>, rc);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * We are ready to enter the next EL. Prepare entry into the image</span><br><span class="line">	 * corresponding to the desired security state after the next ERET.</span><br><span class="line">	 */</span><br><span class="line">	bl31_prepare_next_image_entry();</span><br><span class="line"></span><br><span class="line">	console_flush();</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Perform any platform specific runtime setup prior to cold boot <span class="built_in">exit</span></span><br><span class="line">	 * from BL31</span><br><span class="line">	 */</span><br><span class="line">	bl31_plat_runtime_setup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>bl31_platform_setup<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const char *soc_name;</span><br><span class="line">	uint16_t soc_id = sunxi_read_soc_id(); //读取芯片ID</span><br><span class="line"></span><br><span class="line">	switch (soc_id) &#123;</span><br><span class="line">	<span class="keyword">case</span> 0x1689:</span><br><span class="line">		soc_name = <span class="string">&quot;A64/H64/R18&quot;</span>;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 0x1718:</span><br><span class="line">		soc_name = <span class="string">&quot;H5&quot;</span>;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 0x1728:</span><br><span class="line">		soc_name = <span class="string">&quot;H6&quot;</span>;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	default:</span><br><span class="line">		soc_name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	NOTICE(<span class="string">&quot;BL31: Detected Allwinner %s SoC (%04x)\n&quot;</span>, soc_name, soc_id);</span><br><span class="line"></span><br><span class="line">	generic_delay_timer_init();</span><br><span class="line"></span><br><span class="line">	/* 配置中断控制器 */</span><br><span class="line">	/* Configure the interrupt controller */</span><br><span class="line">	gicv2_driver_init(&amp;sunxi_gic_data);</span><br><span class="line">	gicv2_distif_init();</span><br><span class="line">	gicv2_pcpu_distif_init();</span><br><span class="line">	gicv2_cpuif_enable();</span><br><span class="line"></span><br><span class="line">	/* 设置安全启动 允许在非安全世界访问外设 */</span><br><span class="line">	sunxi_security_setup();</span><br><span class="line"></span><br><span class="line">	/* 启动PMIC电源管理，这里是AXP805通过i2c协议控制 */</span><br><span class="line">	sunxi_pmic_setup();</span><br><span class="line"></span><br><span class="line">	INFO(<span class="string">&quot;BL31: Platform setup done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>runtime_svc_init<br>/* Initialize the runtime services e.g. psci. */<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int rc = 0;</span><br><span class="line">	unsigned int index, start_idx, end_idx;</span><br><span class="line">	rt_svc_desc_t *rt_svc_descs;</span><br><span class="line"></span><br><span class="line">	/* Assert the number of descriptors detected are less than maximum indices */</span><br><span class="line">	assert((RT_SVC_DESCS_END &gt;= RT_SVC_DESCS_START) &amp;&amp;</span><br><span class="line">			(RT_SVC_DECS_NUM &lt; MAX_RT_SVCS));</span><br><span class="line"></span><br><span class="line">	/* If no runtime services are implemented <span class="keyword">then</span> simply bail out */</span><br><span class="line">	<span class="keyword">if</span> (RT_SVC_DECS_NUM == 0U)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	/* Initialise internal variables to invalid state */</span><br><span class="line">	memset(rt_svc_descs_indices, -1, sizeof(rt_svc_descs_indices));</span><br><span class="line"></span><br><span class="line">	rt_svc_descs = (rt_svc_desc_t *) RT_SVC_DESCS_START; //获取服务列表地址</span><br><span class="line">	<span class="keyword">for</span> (index = 0; index &lt; RT_SVC_DECS_NUM; index++) &#123;</span><br><span class="line">		rt_svc_desc_t *service = &amp;rt_svc_descs[index];</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * An invalid descriptor is an error condition since it is</span><br><span class="line">		 * difficult to predict the system behaviour <span class="keyword">in</span> the absence</span><br><span class="line">		 * of this service.</span><br><span class="line">		 */</span><br><span class="line">		rc = validate_rt_svc_desc(service); //验证服务描述符</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			ERROR(<span class="string">&quot;Invalid runtime service descriptor %p\n&quot;</span>,</span><br><span class="line">				(void *) service);</span><br><span class="line">			panic();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * The runtime service may have separate rt_svc_desc_t</span><br><span class="line">		 * <span class="keyword">for</span> its fast smc and yielding smc. Since the service itself</span><br><span class="line">		 * need to be initialized only once, only one of them will have</span><br><span class="line">		 * an initialisation routine defined. Call the initialisation</span><br><span class="line">		 * routine <span class="keyword">for</span> this runtime service, <span class="keyword">if</span> it is defined.</span><br><span class="line">		 */</span><br><span class="line">		<span class="keyword">if</span> (service-&gt;init) &#123;     //服务初始化</span><br><span class="line">			rc = service-&gt;init();</span><br><span class="line">			<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">				ERROR(<span class="string">&quot;Error initializing runtime service %s\n&quot;</span>,</span><br><span class="line">						service-&gt;name);</span><br><span class="line">				<span class="built_in">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Fill the indices corresponding to the start and end</span><br><span class="line">		 * owning entity numbers with the index of the</span><br><span class="line">		 * descriptor <span class="built_in">which</span> will handle the SMCs <span class="keyword">for</span> this owning</span><br><span class="line">		 * entity range.</span><br><span class="line">		 */</span><br><span class="line"><span class="comment">#if SMCCC_MAJOR_VERSION == 1</span></span><br><span class="line">		start_idx = get_unique_oen(service-&gt;start_oen,</span><br><span class="line">					   service-&gt;call_type);</span><br><span class="line">		end_idx = get_unique_oen(service-&gt;end_oen,</span><br><span class="line">					 service-&gt;call_type);</span><br><span class="line"><span class="comment">#elif SMCCC_MAJOR_VERSION == 2</span></span><br><span class="line">		start_idx = get_rt_desc_idx(service-&gt;start_oen,</span><br><span class="line">					    service-&gt;is_vendor);</span><br><span class="line">		end_idx = get_rt_desc_idx(service-&gt;end_oen,</span><br><span class="line">					  service-&gt;is_vendor);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		assert(start_idx &lt;= end_idx);</span><br><span class="line">		assert(end_idx &lt; MAX_RT_SVCS);</span><br><span class="line">		<span class="keyword">for</span> (; start_idx &lt;= end_idx; start_idx++)</span><br><span class="line">			rt_svc_descs_indices[start_idx] = index;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>bl31_prepare_next_image_entry<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">entry_point_info_t *next_image_info;</span><br><span class="line">	uint32_t image_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if CTX_INCLUDE_AARCH32_REGS  //不执行</span></span><br><span class="line">	/*</span><br><span class="line">	 * Ensure that the build flag to save AArch32 system registers <span class="keyword">in</span> CPU</span><br><span class="line">	 * context is not <span class="built_in">set</span> <span class="keyword">for</span> AArch64-only platforms.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (EL_IMPLEMENTED(1) == EL_IMPL_A64ONLY) &#123;</span><br><span class="line">		ERROR(<span class="string">&quot;EL1 supports AArch64-only. Please set build flag &quot;</span></span><br><span class="line">				<span class="string">&quot;CTX_INCLUDE_AARCH32_REGS = 0&quot;</span>);</span><br><span class="line">		panic();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* Determine <span class="built_in">which</span> image to execute next */</span><br><span class="line">	image_type = bl31_get_next_image_type();</span><br><span class="line"></span><br><span class="line">	/* Program EL3 registers to <span class="built_in">enable</span> entry into the next EL */</span><br><span class="line">	next_image_info = bl31_plat_get_next_image_ep_info(image_type);</span><br><span class="line">	assert(next_image_info != NULL);</span><br><span class="line">	assert(image_type == GET_SECURITY_STATE(next_image_info-&gt;h.attr));</span><br><span class="line"></span><br><span class="line">	INFO(<span class="string">&quot;BL31: Preparing for EL3 exit to %s world\n&quot;</span>,</span><br><span class="line">		(image_type == SECURE) ? <span class="string">&quot;secure&quot;</span> : <span class="string">&quot;normal&quot;</span>);</span><br><span class="line">	print_entry_point_info(next_image_info);</span><br><span class="line">	cm_init_my_context(next_image_info); //初始化cpu context sets the initial entrypoint state as specified by the * entry_point_info structure.</span><br><span class="line">	cm_prepare_el3_exit(image_type);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在将控制权传递给引导加载程序或操作系统之前，BL31负责为主CPU设置运行时服务。这个函数调用runtime_svc_init（），它初始化所有注册的运行时服务。运行时服务将为核心设置足够的上下文切换到下一个异常级别。当这个函数返回时，核心将通过切换到编程异常级别。ATF执行完回到u-boot的board_init_f，board_init_r等函数，中间过程不太了解。<br>ARM Trusted firmware还不是很清楚，里面可能有错误，欢迎指正交流。</li>
</ol>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>atf</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-board_init_f</title>
    <url>/2018/08/27/u-boot-board-init-f/</url>
    <content><![CDATA[<h3 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void board_init_f(ulong boot_flags)</span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;flags = boot_flags;</span><br><span class="line">	gd-&gt;have_console = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_f))// 调用init_sequence_f里面的函数</span><br><span class="line">		hang();</span><br><span class="line"></span><br><span class="line"><span class="comment">#if !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line">		!defined(CONFIG_EFI_APP) &amp;&amp; !CONFIG_IS_ENABLED(X86_64) &amp;&amp; \</span><br><span class="line">		!defined(CONFIG_ARC)</span><br><span class="line">	/* NOTREACHED - jump_to_copy() does not <span class="built_in">return</span> */</span><br><span class="line">	hang();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="initcall-run-list"><a href="#initcall-run-list" class="headerlink" title="initcall_run_list"></a>initcall_run_list</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef int (*init_fnc_t)(void);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * To <span class="built_in">enable</span> debugging. add <span class="comment">#define DEBUG at the top of the including file.</span></span><br><span class="line"> *</span><br><span class="line"> * To find a symbol, use grep on u-boot.map</span><br><span class="line"> */</span><br><span class="line">static inline int initcall_run_list(const init_fnc_t init_sequence[])</span><br><span class="line">&#123;</span><br><span class="line">	const init_fnc_t *init_fnc_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line">		unsigned long reloc_ofs = 0;</span><br><span class="line">		int ret;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Sandbox is relocated by the OS, so symbols always appear at</span><br><span class="line">		 * the relocated address.</span><br><span class="line">		 */</span><br><span class="line">		<span class="keyword">if</span> (IS_ENABLED(CONFIG_SANDBOX) || (gd-&gt;flags &amp; GD_FLG_RELOC))</span><br><span class="line">			reloc_ofs = gd-&gt;reloc_off;</span><br><span class="line"><span class="comment">#ifdef CONFIG_EFI_APP</span></span><br><span class="line">		reloc_ofs = (unsigned long)image_base;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		debug(<span class="string">&quot;initcall: %p&quot;</span>, (char *)*init_fnc_ptr - reloc_ofs);</span><br><span class="line">		<span class="keyword">if</span> (reloc_ofs)</span><br><span class="line">			debug(<span class="string">&quot; (relocated to %p)\n&quot;</span>, (char *)*init_fnc_ptr);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			debug(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		ret = (*init_fnc_ptr)(); //执行函数</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;initcall sequence %p failed at call %p (err=%d)\n&quot;</span>,</span><br><span class="line">			       init_sequence,</span><br><span class="line">			       (char *)*init_fnc_ptr - reloc_ofs, ret);</span><br><span class="line">			<span class="built_in">return</span> -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="init-sequence-f"><a href="#init-sequence-f" class="headerlink" title="init_sequence_f"></a>init_sequence_f</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static const init_fnc_t init_sequence_f[] = &#123;</span><br><span class="line">	setup_mon_len,</span><br><span class="line"><span class="comment">#ifdef CONFIG_OF_CONTROL</span></span><br><span class="line">	fdtdec_setup,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_TRACE_EARLY</span></span><br><span class="line">	trace_early_init,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	initf_malloc,</span><br><span class="line">	log_init,</span><br><span class="line">	initf_bootstage,	/* uses its own timer, so does not need DM */</span><br><span class="line"><span class="comment">#ifdef CONFIG_BLOBLIST</span></span><br><span class="line">	bloblist_init,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	setup_spl_handoff,</span><br><span class="line">	initf_console_record,</span><br><span class="line"><span class="comment">#if defined(CONFIG_HAVE_FSP)</span></span><br><span class="line">	arch_fsp_init,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	arch_cpu_init,		/* basic arch cpu dependent setup */</span><br><span class="line">	mach_cpu_init,		/* SoC/machine dependent CPU setup */</span><br><span class="line">	initf_dm,</span><br><span class="line">	arch_cpu_init_dm,</span><br><span class="line"><span class="comment">#if defined(CONFIG_BOARD_EARLY_INIT_F)</span></span><br><span class="line">	board_early_init_f,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_PPC) || defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)</span></span><br><span class="line">	/* get CPU and bus clocks according to the environment variable */</span><br><span class="line">	get_clocks,		/* get CPU and bus clocks (etc.) */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if !defined(CONFIG_M68K)</span></span><br><span class="line">	timer_init,		/* initialize timer */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_BOARD_POSTCLK_INIT)</span></span><br><span class="line">	board_postclk_init,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	env_init,		/* initialize environment */</span><br><span class="line">	init_baud_rate,		/* initialze baudrate settings */</span><br><span class="line">	serial_init,		/* serial communications setup */</span><br><span class="line">	console_init_f,		/* stage 1 init of console */</span><br><span class="line">	display_options,	/* say that we are here */</span><br><span class="line">	display_text_info,	/* show debugging info <span class="keyword">if</span> required */</span><br><span class="line"><span class="comment">#if defined(CONFIG_PPC) || defined(CONFIG_SH) || defined(CONFIG_X86)</span></span><br><span class="line">	checkcpu,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_SYSRESET)</span></span><br><span class="line">	print_resetinfo,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_DISPLAY_CPUINFO)</span></span><br><span class="line">	print_cpuinfo,		/* display cpu info (and speed) */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_DTB_RESELECT)</span></span><br><span class="line">	embedded_dtb_select,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_DISPLAY_BOARDINFO)</span></span><br><span class="line">	show_board_info,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_INIT</span><br><span class="line"><span class="comment">#if defined(CONFIG_MISC_INIT_F)</span></span><br><span class="line">	misc_init_f,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line"><span class="comment">#if defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	init_func_i2c,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_VID) &amp;&amp; !defined(CONFIG_SPL)</span></span><br><span class="line">	init_func_vid,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	announce_dram_init,</span><br><span class="line">	dram_init,		/* configure available RAM banks */</span><br><span class="line"><span class="comment">#ifdef CONFIG_POST</span></span><br><span class="line">	post_init_f,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line"><span class="comment">#if defined(CONFIG_SYS_DRAM_TEST)</span></span><br><span class="line">	testdram,</span><br><span class="line"><span class="comment">#endif /* CONFIG_SYS_DRAM_TEST */</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_POST</span></span><br><span class="line">	init_post,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	/*</span><br><span class="line">	 * Now that we have DRAM mapped and working, we can</span><br><span class="line">	 * relocate the code and <span class="built_in">continue</span> running from DRAM.</span><br><span class="line">	 *</span><br><span class="line">	 * Reserve memory at end of RAM <span class="keyword">for</span> (top down <span class="keyword">in</span> that order):</span><br><span class="line">	 *  - area that won<span class="string">&#x27;t get touched by U-Boot and Linux (optional)</span></span><br><span class="line"><span class="string">	 *  - kernel log buffer</span></span><br><span class="line"><span class="string">	 *  - protected RAM</span></span><br><span class="line"><span class="string">	 *  - LCD framebuffer</span></span><br><span class="line"><span class="string">	 *  - monitor code</span></span><br><span class="line"><span class="string">	 *  - board info struct</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	setup_dest_addr,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_PRAM</span></span><br><span class="line"><span class="string">	reserve_pram,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	reserve_round_4k,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_ARM</span></span><br><span class="line"><span class="string">	reserve_mmu,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	reserve_video,</span></span><br><span class="line"><span class="string">	reserve_trace,</span></span><br><span class="line"><span class="string">	reserve_uboot,</span></span><br><span class="line"><span class="string">	reserve_malloc,</span></span><br><span class="line"><span class="string">	reserve_board,</span></span><br><span class="line"><span class="string">	setup_machine,</span></span><br><span class="line"><span class="string">	reserve_global_data,</span></span><br><span class="line"><span class="string">	reserve_fdt,</span></span><br><span class="line"><span class="string">	reserve_bootstage,</span></span><br><span class="line"><span class="string">	reserve_bloblist,</span></span><br><span class="line"><span class="string">	reserve_arch,</span></span><br><span class="line"><span class="string">	reserve_stacks,</span></span><br><span class="line"><span class="string">	dram_init_banksize,</span></span><br><span class="line"><span class="string">	show_dram_config,</span></span><br><span class="line"><span class="string">#if defined(CONFIG_M68K) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \</span></span><br><span class="line"><span class="string">	defined(CONFIG_SH)</span></span><br><span class="line"><span class="string">	setup_board_part1,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_PPC) || defined(CONFIG_M68K)</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	setup_board_part2,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	display_new_sp,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_OF_BOARD_FIXUP</span></span><br><span class="line"><span class="string">	fix_fdt,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	reloc_fdt,</span></span><br><span class="line"><span class="string">	reloc_bootstage,</span></span><br><span class="line"><span class="string">	reloc_bloblist,</span></span><br><span class="line"><span class="string">	setup_reloc,</span></span><br><span class="line"><span class="string">#if defined(CONFIG_X86) || defined(CONFIG_ARC)</span></span><br><span class="line"><span class="string">	copy_uboot_to_ram,</span></span><br><span class="line"><span class="string">	do_elf_reloc_fixups,</span></span><br><span class="line"><span class="string">	clear_bss,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_XTENSA)</span></span><br><span class="line"><span class="string">	clear_bss,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line"><span class="string">		!CONFIG_IS_ENABLED(X86_64)</span></span><br><span class="line"><span class="string">	jump_to_copy,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	NULL,</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>将一系列初始化函数名放入一个数组里，然后遍历数组去执行里面的函数。</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>board_init_f</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-board_init_r_in_spl</title>
    <url>/2018/08/27/u-boot-board-init-r-in-spl/</url>
    <content><![CDATA[<h3 id="函数主体"><a href="#函数主体" class="headerlink" title="函数主体"></a>函数主体</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void board_init_r(gd_t *dummy1, ulong dummy2)</span><br><span class="line">&#123;</span><br><span class="line">	u32 spl_boot_list[] = &#123;</span><br><span class="line">		BOOT_DEVICE_NONE,</span><br><span class="line">		BOOT_DEVICE_NONE,</span><br><span class="line">		BOOT_DEVICE_NONE,</span><br><span class="line">		BOOT_DEVICE_NONE,</span><br><span class="line">		BOOT_DEVICE_NONE,</span><br><span class="line">	&#125;;</span><br><span class="line">	struct spl_image_info spl_image;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;&gt;&gt;&quot;</span> SPL_TPL_PROMPT <span class="string">&quot;board_init_r()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	spl_set_bd(); //给gd-&gt;bd赋值为&amp;bdata</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_SYS_SPL_MALLOC_START) //未定义</span></span><br><span class="line">	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,</span><br><span class="line">			CONFIG_SYS_SPL_MALLOC_SIZE);</span><br><span class="line">	gd-&gt;flags |= GD_FLG_FULL_MALLOC_INIT;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="keyword">if</span> (!(gd-&gt;flags &amp; GD_FLG_SPL_INIT)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (spl_init())</span><br><span class="line">			hang();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#if !defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_ARCH_MX6)</span></span><br><span class="line">	/*</span><br><span class="line">	 * timer_init() does not exist on PPC systems. The timer is initialized</span><br><span class="line">	 * and enabled (decrementer) <span class="keyword">in</span> interrupt_init() here.</span><br><span class="line">	 */</span><br><span class="line">	timer_init();  //初始化定时器</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(BOARD_INIT) //未使能</span></span><br><span class="line">	spl_board_init();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_SPL_WATCHDOG_SUPPORT) &amp;&amp; CONFIG_IS_ENABLED(WDT) //未定义</span></span><br><span class="line">	initr_watchdog();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SPL_OS_BOOT) || CONFIG_IS_ENABLED(HANDOFF))</span><br><span class="line">		dram_init_banksize();</span><br><span class="line"></span><br><span class="line">	bootcount_inc();</span><br><span class="line"></span><br><span class="line">	memset(&amp;spl_image, <span class="string">&#x27;\0&#x27;</span>, sizeof(spl_image));</span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_SPL_ARGS_ADDR</span></span><br><span class="line">	spl_image.arg = (void *)CONFIG_SYS_SPL_ARGS_ADDR;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	spl_image.boot_device = BOOT_DEVICE_NONE;</span><br><span class="line">	board_boot_order(spl_boot_list); //spl_boot_list[0] = BOOT_DEVICE_MMC1</span><br><span class="line"></span><br><span class="line">	/* 在.u_boot_list_2_spl_image_loader_1段中查找spl_image_loader结构体，调用其load_image函数给entrp赋值*/</span><br><span class="line">	<span class="keyword">if</span> (boot_from_devices(&amp;spl_image, spl_boot_list,</span><br><span class="line">			      ARRAY_SIZE(spl_boot_list))) &#123;</span><br><span class="line">		puts(SPL_TPL_PROMPT <span class="string">&quot;failed to boot from all boot devices\n&quot;</span>);</span><br><span class="line">		hang();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spl_perform_fixups(&amp;spl_image);</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(HANDOFF)) &#123;</span><br><span class="line">		ret = write_spl_handoff();</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="built_in">printf</span>(SPL_TPL_PROMPT</span><br><span class="line">			       <span class="string">&quot;SPL hand-off write failed (err=%d)\n&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(BLOBLIST)) &#123;</span><br><span class="line">		ret = bloblist_finish();</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Warning: Failed to finish bloblist (ret=%d)\n&quot;</span>,</span><br><span class="line">			       ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_CPU_V7M</span></span><br><span class="line">	spl_image.entry_point |= 0x1;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	switch (spl_image.os) &#123;</span><br><span class="line">	<span class="keyword">case</span> IH_OS_U_BOOT:  //执行这里</span><br><span class="line">		debug(<span class="string">&quot;Jumping to U-Boot\n&quot;</span>);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(ATF)</span></span><br><span class="line">	<span class="keyword">case</span> IH_OS_ARM_TRUSTED_FIRMWARE:</span><br><span class="line">		debug(<span class="string">&quot;Jumping to U-Boot via ARM Trusted Firmware\n&quot;</span>);</span><br><span class="line">		spl_invoke_atf(&amp;spl_image);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(OPTEE)</span></span><br><span class="line">	<span class="keyword">case</span> IH_OS_TEE:</span><br><span class="line">		debug(<span class="string">&quot;Jumping to U-Boot via OP-TEE\n&quot;</span>);</span><br><span class="line">		spl_optee_entry(NULL, NULL, spl_image.fdt_addr,</span><br><span class="line">				(void *)spl_image.entry_point);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SPL_OS_BOOT</span></span><br><span class="line">	<span class="keyword">case</span> IH_OS_LINUX:</span><br><span class="line">		debug(<span class="string">&quot;Jumping to Linux\n&quot;</span>);</span><br><span class="line">		spl_fixup_fdt();</span><br><span class="line">		spl_board_prepare_for_linux();</span><br><span class="line">		jump_to_image_linux(&amp;spl_image);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	default:</span><br><span class="line">		debug(<span class="string">&quot;Unsupported OS image.. Jumping nevertheless..\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#if CONFIG_VAL(SYS_MALLOC_F_LEN) &amp;&amp; !defined(CONFIG_SYS_SPL_MALLOC_SIZE)</span></span><br><span class="line">	debug(<span class="string">&quot;SPL malloc() used 0x%lx bytes (%ld KB)\n&quot;</span>, gd-&gt;malloc_ptr,</span><br><span class="line">	      gd-&gt;malloc_ptr / 1024);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOTSTAGE_STASH</span></span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_END_SPL, <span class="string">&quot;end_spl&quot;</span>);</span><br><span class="line">	ret = bootstage_stash((void *)CONFIG_BOOTSTAGE_STASH_ADDR,</span><br><span class="line">			      CONFIG_BOOTSTAGE_STASH_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		debug(<span class="string">&quot;Failed to stash bootstage: err=%d\n&quot;</span>, ret);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;loaded - jumping to U-Boot...\n&quot;</span>);</span><br><span class="line">	spl_board_prepare_for_boot(); //什么也没做</span><br><span class="line">	jump_to_image_no_args(&amp;spl_image); //跳转到spl_image-&gt;entry_point即ATF的bl31_main</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spl_image_loader的定义在spl_mmc.c文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int spl_mmc_load_image(struct spl_image_info *spl_image,</span><br><span class="line">		       struct spl_boot_device *bootdev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> spl_mmc_load(spl_image, bootdev,</span><br><span class="line"><span class="comment">#ifdef CONFIG_SPL_FS_LOAD_PAYLOAD_NAME</span></span><br><span class="line">			    CONFIG_SPL_FS_LOAD_PAYLOAD_NAME,</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">			    NULL,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION</span></span><br><span class="line">			    spl_boot_partition(bootdev-&gt;boot_device),</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">			    0,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR</span></span><br><span class="line">			    CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">			    0);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">SPL_LOAD_IMAGE_METHOD(<span class="string">&quot;MMC1&quot;</span>, 0, BOOT_DEVICE_MMC1, spl_mmc_load_image);</span><br><span class="line">SPL_LOAD_IMAGE_METHOD(<span class="string">&quot;MMC2&quot;</span>, 0, BOOT_DEVICE_MMC2, spl_mmc_load_image);</span><br><span class="line">SPL_LOAD_IMAGE_METHOD(<span class="string">&quot;MMC2_2&quot;</span>, 0, BOOT_DEVICE_MMC2_2, spl_mmc_load_image);</span><br><span class="line">...</span><br><span class="line">/*</span><br><span class="line"> * _priority is the priority of this method, 0 meaning it will be the top</span><br><span class="line"> * choice <span class="keyword">for</span> this device, 9 meaning it is the bottom choice.</span><br><span class="line"> * _boot_device is the BOOT_DEVICE_... value</span><br><span class="line"> * _method is the load_image <span class="keyword">function</span> to call</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#ifdef CONFIG_SPL_LIBCOMMON_SUPPORT</span></span><br><span class="line"><span class="comment">#define SPL_LOAD_IMAGE_METHOD(_name, _priority, _boot_device, _method) \</span></span><br><span class="line">	SPL_LOAD_IMAGE(_method <span class="comment">## _priority ## _boot_device) = &#123; \</span></span><br><span class="line">		.name = _name, \</span><br><span class="line">		.boot_device = _boot_device, \</span><br><span class="line">		.load_image = _method, \</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#define SPL_LOAD_IMAGE_METHOD(_name, _priority, _boot_device, _method) \</span></span><br><span class="line">	SPL_LOAD_IMAGE(_method <span class="comment">## _priority ## _boot_device) = &#123; \</span></span><br><span class="line">		.boot_device = _boot_device, \</span><br><span class="line">		.load_image = _method, \</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">...</span><br><span class="line">/* Declare an SPL image loader */</span><br><span class="line"><span class="comment">#define SPL_LOAD_IMAGE(__name)					\</span></span><br><span class="line">	ll_entry_declare(struct spl_image_loader, __name, spl_image_loader)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">#define ll_entry_declare(_type, _name, _list)				\</span></span><br><span class="line">	_type _u_boot_list_2_<span class="comment">##_list##_2_##_name __aligned(4)		\</span></span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_&quot;</span><span class="comment">#_list&quot;_2_&quot;#_name)))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里定义里该结构体，通过该drv从mmc读取image并且对结构体赋值。该部分代码最终调用ATF中的bl31_main函数，ATF部分负责安全启动相关内容，前面u-boot的spl阶段没有对电源部分进行初始化和设置，在ATF中会通过PMIC框架进行电源管理，这里不展开叙述，后面文章再继续分析。</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>board_init_r</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-board_init_r</title>
    <url>/2018/08/27/u-boot-board-init-r/</url>
    <content><![CDATA[<h3 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	/*</span><br><span class="line">	 * Set up the new global data pointer. So far only x86 does this</span><br><span class="line">	 * here.</span><br><span class="line">	 * TODO(sjg@chromium.org): Consider doing this <span class="keyword">for</span> all archs, or</span><br><span class="line">	 * dropping the new_gd parameter.</span><br><span class="line">	 */</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(X86_64)</span></span><br><span class="line">	arch_setup_gd(new_gd);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	int i;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if !defined(CONFIG_X86) &amp;&amp; !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_ARM64)</span></span><br><span class="line">	gd = new_gd;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	gd-&gt;flags &amp;= ~GD_FLG_LOG_READY;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(init_sequence_r); i++)</span><br><span class="line">		init_sequence_r[i] += gd-&gt;reloc_off;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_r))</span><br><span class="line">		hang();</span><br><span class="line"></span><br><span class="line">	/* NOTREACHED - run_main_loop() does not <span class="built_in">return</span> */</span><br><span class="line">	hang();</span><br></pre></td></tr></table></figure>
<h3 id="init-sequence-r"><a href="#init-sequence-r" class="headerlink" title="init_sequence_r"></a>init_sequence_r</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * We hope to remove most of the driver-related init and <span class="keyword">do</span> it <span class="keyword">if</span>/when</span><br><span class="line"> * the driver is later used.</span><br><span class="line"> *</span><br><span class="line"> * TODO: perhaps reset the watchdog <span class="keyword">in</span> the initcall <span class="keyword">function</span> after each call?</span><br><span class="line"> */</span><br><span class="line">static init_fnc_t init_sequence_r[] = &#123;</span><br><span class="line">	initr_trace,</span><br><span class="line">	initr_reloc,</span><br><span class="line">	/* TODO: could x86/PPC have this also perhaps? */</span><br><span class="line"><span class="comment">#ifdef CONFIG_ARM</span></span><br><span class="line">	initr_caches,</span><br><span class="line">	/* Note: For Freescale LS2 SoCs, new MMU table is created <span class="keyword">in</span> DDR.</span><br><span class="line">	 *	 A temporary mapping of IFC high region is since removed,</span><br><span class="line">	 *	 so environmental variables <span class="keyword">in</span> NOR flash is not available</span><br><span class="line">	 *	 until board_init() is called below to remap IFC to high</span><br><span class="line">	 *	 region.</span><br><span class="line">	 */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	initr_reloc_global_data,</span><br><span class="line"><span class="comment">#if defined(CONFIG_SYS_INIT_RAM_LOCK) &amp;&amp; defined(CONFIG_E500)</span></span><br><span class="line">	initr_unlock_ram_in_cache,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	initr_barrier,</span><br><span class="line">	initr_malloc,</span><br><span class="line">	log_init,</span><br><span class="line">	initr_bootstage,	/* Needs malloc() but has its own timer */</span><br><span class="line">	initr_console_record,</span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_NONCACHED_MEMORY</span></span><br><span class="line">	initr_noncached,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	bootstage_relocate,</span><br><span class="line"><span class="comment">#ifdef CONFIG_OF_LIVE</span></span><br><span class="line">	initr_of_live,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_DM</span></span><br><span class="line">	initr_dm,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_ARM) || defined(CONFIG_NDS32) || defined(CONFIG_RISCV) || \</span></span><br><span class="line">	defined(CONFIG_SANDBOX)</span><br><span class="line">	board_init,	/* Setup chipselects */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	/*</span><br><span class="line">	 * TODO: printing of the clock inforamtion of the board is now</span><br><span class="line">	 * implemented as part of bdinfo <span class="built_in">command</span>. Currently only support <span class="keyword">for</span></span><br><span class="line">	 * davinci SOC<span class="string">&#x27;s is added. Remove this check once all the board</span></span><br><span class="line"><span class="string">	 * implement this.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CLOCKS</span></span><br><span class="line"><span class="string">	set_cpu_clk_info, /* Setup clock information */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_EFI_LOADER</span></span><br><span class="line"><span class="string">	efi_memory_init,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	stdio_init_tables,</span></span><br><span class="line"><span class="string">	initr_serial,</span></span><br><span class="line"><span class="string">	initr_announce,</span></span><br><span class="line"><span class="string">#if CONFIG_IS_ENABLED(WDT)</span></span><br><span class="line"><span class="string">	initr_watchdog,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">#ifdef CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line"><span class="string">	initr_manual_reloc_cmdtable,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_MIPS)</span></span><br><span class="line"><span class="string">	initr_trap,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_ADDR_MAP</span></span><br><span class="line"><span class="string">	initr_addr_map,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_BOARD_EARLY_INIT_R)</span></span><br><span class="line"><span class="string">	board_early_init_r,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">#ifdef CONFIG_POST</span></span><br><span class="line"><span class="string">	initr_post_backlog,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">#if defined(CONFIG_PCI) &amp;&amp; defined(CONFIG_SYS_EARLY_PCI_INIT)</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Do early PCI configuration _before_ the flash gets initialised,</span></span><br><span class="line"><span class="string">	 * because PCU resources are crucial for flash access on some boards.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	initr_pci,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_ARCH_EARLY_INIT_R</span></span><br><span class="line"><span class="string">	arch_early_init_r,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	power_init_board,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_MTD_NOR_FLASH</span></span><br><span class="line"><span class="string">	initr_flash,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86)</span></span><br><span class="line"><span class="string">	/* initialize higher level parts of CPU like time base and timers */</span></span><br><span class="line"><span class="string">	cpu_init_r,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CMD_NAND</span></span><br><span class="line"><span class="string">	initr_nand,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CMD_ONENAND</span></span><br><span class="line"><span class="string">	initr_onenand,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_MMC</span></span><br><span class="line"><span class="string">	initr_mmc,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	initr_env,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_SYS_BOOTPARAMS_LEN</span></span><br><span class="line"><span class="string">	initr_malloc_bootparams,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	initr_secondary_cpu,</span></span><br><span class="line"><span class="string">#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)</span></span><br><span class="line"><span class="string">	mac_read_from_eeprom,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">#if defined(CONFIG_PCI) &amp;&amp; !defined(CONFIG_SYS_EARLY_PCI_INIT)</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Do pci configuration</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	initr_pci,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	stdio_add_devices,</span></span><br><span class="line"><span class="string">	initr_jumptable,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_API</span></span><br><span class="line"><span class="string">	initr_api,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	console_init_r,		/* fully init console as a device */</span></span><br><span class="line"><span class="string">#ifdef CONFIG_DISPLAY_BOARDINFO_LATE</span></span><br><span class="line"><span class="string">	console_announce_r,</span></span><br><span class="line"><span class="string">	show_board_info,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_ARCH_MISC_INIT</span></span><br><span class="line"><span class="string">	arch_misc_init,		/* miscellaneous arch-dependent init */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_MISC_INIT_R</span></span><br><span class="line"><span class="string">	misc_init_r,		/* miscellaneous platform-dependent init */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CMD_KGDB</span></span><br><span class="line"><span class="string">	initr_kgdb,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	interrupt_init,</span></span><br><span class="line"><span class="string">#ifdef CONFIG_ARM</span></span><br><span class="line"><span class="string">	initr_enable_interrupts,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_MICROBLAZE) || defined(CONFIG_M68K)</span></span><br><span class="line"><span class="string">	timer_init,		/* initialize timer */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_LED_STATUS)</span></span><br><span class="line"><span class="string">	initr_status_led,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	/* PPC has a udelay(20) here dating from 2002. Why? */</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CMD_NET</span></span><br><span class="line"><span class="string">	initr_ethaddr,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_GPIO_HOG)</span></span><br><span class="line"><span class="string">	gpio_hog_probe_all,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_BOARD_LATE_INIT</span></span><br><span class="line"><span class="string">	board_late_init,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_SCSI) &amp;&amp; !defined(CONFIG_DM_SCSI)</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	initr_scsi,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_BITBANGMII</span></span><br><span class="line"><span class="string">	initr_bbmii,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CMD_NET</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	initr_net,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_POST</span></span><br><span class="line"><span class="string">	initr_post,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_IDE) &amp;&amp; !defined(CONFIG_BLK)</span></span><br><span class="line"><span class="string">	initr_ide,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_LAST_STAGE_INIT</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Some parts can be only initialized if all others (like</span></span><br><span class="line"><span class="string">	 * Interrupts) are up and running (i.e. the PC-style ISA</span></span><br><span class="line"><span class="string">	 * keyboard).</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	last_stage_init,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#ifdef CONFIG_CMD_BEDBUG</span></span><br><span class="line"><span class="string">	INIT_FUNC_WATCHDOG_RESET</span></span><br><span class="line"><span class="string">	initr_bedbug,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#if defined(CONFIG_PRAM)</span></span><br><span class="line"><span class="string">	initr_mem,</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	run_main_loop,</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>与board_init_f类似都是遍历数组实现函数调用，最后调用run_main_loop，即u-boot的最后死循环，引导linux或执行u-boot命令。</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>board_init_r</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-board_init_f_in_spl</title>
    <url>/2018/08/26/u-boot-board_init_f_in_spl/</url>
    <content><![CDATA[<h2 id="board-init-f主体"><a href="#board-init-f主体" class="headerlink" title="board_init_f主体"></a>board_init_f主体</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void board_init_f(ulong dummy)</span><br><span class="line">&#123;</span><br><span class="line">	spl_init();</span><br><span class="line">	preloader_console_init(); // 初始化串口</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_SPL_I2C_SUPPORT</span></span><br><span class="line">	/* Needed early by sunxi_board_init <span class="keyword">if</span> PMU is enabled */</span><br><span class="line">	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	sunxi_board_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spl-init"><a href="#spl-init" class="headerlink" title="spl_init"></a>spl_init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int spl_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	bool setup_malloc = !(IS_ENABLED(CONFIG_SPL_STACK_R) &amp;&amp;</span><br><span class="line">			IS_ENABLED(CONFIG_SPL_SYS_MALLOC_SIMPLE));</span><br><span class="line"></span><br><span class="line">	// setup_malloc=0</span><br><span class="line">	debug(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(gd-&gt;flags &amp; GD_FLG_SPL_EARLY_INIT)) &#123;</span><br><span class="line">		ret = spl_common_init(setup_malloc);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	gd-&gt;flags |= GD_FLG_SPL_INIT;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看IS_ENABLED这个宏定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define config_enabled(cfg) _config_enabled(cfg)</span></span><br><span class="line"><span class="comment">#define _config_enabled(value) __config_enabled(__ARG_PLACEHOLDER_##value)</span></span><br><span class="line"><span class="comment">#define __config_enabled(arg1_or_junk) ___config_enabled(arg1_or_junk 1, 0)</span></span><br><span class="line"><span class="comment">#define ___config_enabled(__ignored, val, ...) val</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">#define IS_ENABLED(option) \</span></span><br><span class="line">	(config_enabled(option) || config_enabled(option<span class="comment">##_MODULE))</span></span><br></pre></td></tr></table></figure>
<p>将第一个展开得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IS_ENABLED(CONFIG_SPL_STACK_R)</span><br><span class="line">(config_enabled(CONFIG_SPL_STACK_R) || config_enabled(CONFIG_SPL_STACK_R<span class="comment">##_MODULE))</span></span><br><span class="line">___config_enabled(__ARG_PLACEHOLDER_CONFIG_SPL_STACK_R 1,0) || \</span><br><span class="line">___config_enabled(CONFIG_SPL_STACK_R__ARG_PLACEHOLDER_CONFIG_SPL_STACK_R 1,0)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果有option则结果为1,如果没有option结果为0，执行spl_common_init传入参数为0,内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int spl_common_init(bool setup_malloc)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">	<span class="keyword">if</span> (setup_malloc) &#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_MALLOC_F_ADDR</span></span><br><span class="line">		gd-&gt;malloc_base = CONFIG_MALLOC_F_ADDR;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		gd-&gt;malloc_limit = CONFIG_VAL(SYS_MALLOC_F_LEN);</span><br><span class="line">		gd-&gt;malloc_ptr = 0;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	ret = bootstage_init(<span class="literal">true</span>);</span><br><span class="line">			struct bootstage_data *data;</span><br><span class="line">			int size = sizeof(struct bootstage_data);</span><br><span class="line"></span><br><span class="line">			gd-&gt;bootstage = (struct bootstage_data *)malloc(size); //为gd-&gt;bootstage分配空间</span><br><span class="line">			<span class="keyword">if</span> (!gd-&gt;bootstage)</span><br><span class="line">				<span class="built_in">return</span> -ENOMEM;</span><br><span class="line">			data = gd-&gt;bootstage;</span><br><span class="line">			memset(data, <span class="string">&#x27;\0&#x27;</span>, size); //将结构体清空</span><br><span class="line">			<span class="keyword">if</span> (first) &#123;</span><br><span class="line">				data-&gt;next_id = BOOTSTAGE_ID_USER; // gd-&gt;bootstage-&gt;next_id = BOOTSTAGE_ID_USER</span><br><span class="line">				bootstage_add_record(BOOTSTAGE_ID_AWAKE, <span class="string">&quot;reset&quot;</span>, 0, 0);</span><br><span class="line">						struct bootstage_data *data = gd-&gt;bootstage;</span><br><span class="line">						struct bootstage_record *rec;</span><br><span class="line"></span><br><span class="line">						/*</span><br><span class="line">						 * initf_bootstage() is called very early during boot but since hang()</span><br><span class="line">						 * calls bootstage_error() we can be called before bootstage is <span class="built_in">set</span> up.</span><br><span class="line">						 * Add a check to avoid this.</span><br><span class="line">						 */</span><br><span class="line">						<span class="keyword">if</span> (!data)</span><br><span class="line">							<span class="built_in">return</span> mark;</span><br><span class="line">						<span class="keyword">if</span> (flags &amp; BOOTSTAGEF_ALLOC) //flag=0 不执行</span><br><span class="line">							id = data-&gt;next_id++;</span><br><span class="line"></span><br><span class="line">						/* Only record the first event <span class="keyword">for</span> each */</span><br><span class="line">						rec = find_id(data, id); //gd-&gt;bootstage被清空返回null</span><br><span class="line">						<span class="keyword">if</span> (!rec &amp;&amp; data-&gt;rec_count &lt; RECORD_COUNT) &#123;</span><br><span class="line">							rec = &amp;data-&gt;record[data-&gt;rec_count++]; // 初始化rec指向&amp;data-&gt;record[0]，并且data-&gt;rec_count=1</span><br><span class="line">							rec-&gt;time_us = mark;  //初始化rec-&gt;time_us为0</span><br><span class="line">							rec-&gt;name = name;    //初始化rec-&gt;name 为reset</span><br><span class="line">							rec-&gt;flags = flags;  //初始化rec-&gt;flags 为0</span><br><span class="line">							rec-&gt;id = id;   		//初始化rec-&gt;id为BOOTSTAGE_ID_AWAKE</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						/* Tell the board about this progress */</span><br><span class="line">						show_boot_progress(flags &amp; BOOTSTAGEF_ERROR ? -id : id);</span><br><span class="line"></span><br><span class="line">						<span class="built_in">return</span> mark;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		debug(<span class="string">&quot;%s: Failed to set up bootstage: ret=%d\n&quot;</span>, __func__,</span><br><span class="line">		      ret);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_START_SPL, <span class="string">&quot;spl&quot;</span>);</span><br><span class="line">			int flags = 0;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (id == BOOTSTAGE_ID_ALLOC) //不执行</span><br><span class="line">				flags = BOOTSTAGEF_ALLOC;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">return</span> bootstage_add_record(id, name, flags, timer_get_boot_us());// 初始化gd-&gt;bootstage-&gt;record[1] 为spl</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(LOG)</span></span><br><span class="line">	ret = log_init();</span><br><span class="line">		//定义log_driver结构体并放入u_boot_list_2_log_driver_1段中</span><br><span class="line">		struct log_driver *drv = ll_entry_start(struct log_driver, log_driver);</span><br><span class="line">			<span class="comment">#define ll_entry_start(_type, _list)					\</span></span><br><span class="line">			(&#123;									\</span><br><span class="line">				static char start[0] __aligned(4) __attribute__((unused,	\</span><br><span class="line">					section(<span class="string">&quot;.u_boot_list_2_&quot;</span><span class="comment">#_list&quot;_1&quot;)));			\</span></span><br><span class="line">				(_type *)&amp;start;						\</span><br><span class="line">			&#125;)</span><br><span class="line">		//count为u_boot_list_2_log_driver_3与u_boot_list_2_log_driver_1之间有多少个log_driver结构体</span><br><span class="line">		const int count = ll_entry_count(struct log_driver, log_driver);</span><br><span class="line">			<span class="comment">#define ll_entry_count(_type, _list)					\</span></span><br><span class="line">				(&#123;								\</span><br><span class="line">					_type *start = ll_entry_start(_type, _list);		\</span><br><span class="line">					_type *end = ll_entry_end(_type, _list);		\</span><br><span class="line">					unsigned int _ll_result = end - start;			\</span><br><span class="line">					_ll_result;						\</span><br><span class="line">				&#125;)</span><br><span class="line"></span><br><span class="line">		struct log_driver *end = drv + count;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * We cannot add runtime data to the driver since it is likely stored</span><br><span class="line">		 * <span class="keyword">in</span> rodata. Instead, <span class="built_in">set</span> up a <span class="string">&#x27;device&#x27;</span> corresponding to each driver.</span><br><span class="line">		 * We only support having a single device.</span><br><span class="line">		 */</span><br><span class="line">		INIT_LIST_HEAD((struct list_head *)&amp;gd-&gt;log_head); //初始化gd-&gt;log_head为链表头</span><br><span class="line">		<span class="keyword">while</span> (drv &lt; end) &#123;</span><br><span class="line">			struct log_device *ldev;</span><br><span class="line"></span><br><span class="line">			ldev = calloc(1, sizeof(*ldev)); //分配空间</span><br><span class="line">			<span class="keyword">if</span> (!ldev) &#123;</span><br><span class="line">				debug(<span class="string">&quot;%s: Cannot allocate memory\n&quot;</span>, __func__);</span><br><span class="line">				<span class="built_in">return</span> -ENOMEM;</span><br><span class="line">			&#125;</span><br><span class="line">			INIT_LIST_HEAD(&amp;ldev-&gt;filter_head); //将ldev-&gt;filter_head成员初始化为链表 </span><br><span class="line">			ldev-&gt;drv = drv;							//将ldev-&gt;drv成员指向当前的log_driver</span><br><span class="line">			list_add_tail(&amp;ldev-&gt;sibling_node,</span><br><span class="line">				      (struct list_head *)&amp;gd-&gt;log_head);// //把ldev-&gt;sibling_node成员加入到gd-&gt;log_head的链表中</span><br><span class="line">			drv++;</span><br><span class="line">		&#125;</span><br><span class="line">		//通过该循环，将.u_boot_list_2_log_driver_3和.u_boot_list_2_log_driver_1之间的所有struct \</span><br><span class="line">		log_driver结构体都加入到了gd-&gt;log_head的链表中</span><br><span class="line">		//之前gd-&gt;flags=0,此时设置gd-&gt;flags为GD_FLG_LOG_READY，即gd-&gt;flags=0x08000</span><br><span class="line">		gd-&gt;flags |= GD_FLG_LOG_READY;</span><br><span class="line">		<span class="keyword">if</span> (!gd-&gt;default_log_level)</span><br><span class="line">			gd-&gt;default_log_level = CONFIG_LOG_DEFAULT_LEVEL;   //设置gd-&gt;default_log_level为CONFIG_LOG_DEFAULT_LEVEL</span><br><span class="line">		gd-&gt;log_fmt = LOGF_DEFAULT; //设置gd-&gt;log_fmt为LOGF_DEFAULT</span><br><span class="line"></span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		debug(<span class="string">&quot;%s: Failed to set up logging\n&quot;</span>, __func__);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(BLOBLIST)) &#123; //未定义不执行</span><br><span class="line">		ret = bloblist_init();</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			debug(<span class="string">&quot;%s: Failed to set up bloblist: ret=%d\n&quot;</span>,</span><br><span class="line">			      __func__, ret);</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(HANDOFF)) &#123; //未定义不执行</span><br><span class="line">		int ret;</span><br><span class="line"></span><br><span class="line">		ret = setup_spl_handoff();</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			puts(SPL_TPL_PROMPT <span class="string">&quot;Cannot set up SPL handoff\n&quot;</span>);</span><br><span class="line">			hang();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//OF_CONTROL定义了OF_PLATDATA未定义执行下面代码段</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_CONTROL) &amp;&amp; !CONFIG_IS_ENABLED(OF_PLATDATA)) &#123;</span><br><span class="line">		ret = fdtdec_setup(); //后面单独分析</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			debug(<span class="string">&quot;fdtdec_setup() returned error %d\n&quot;</span>, ret);</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(DM)) &#123;</span><br><span class="line">		bootstage_start(BOOTSTATE_ID_ACCUM_DM_SPL, <span class="string">&quot;dm_spl&quot;</span>);</span><br><span class="line">		/* With CONFIG_SPL_OF_PLATDATA, bring <span class="keyword">in</span> all devices */</span><br><span class="line">		ret = dm_init_and_scan(!CONFIG_IS_ENABLED(OF_PLATDATA));</span><br><span class="line">		bootstage_accum(BOOTSTATE_ID_ACCUM_DM_SPL);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			debug(<span class="string">&quot;dm_init_and_scan() returned error %d\n&quot;</span>, ret);</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="preloader-console-init"><a href="#preloader-console-init" class="headerlink" title="preloader_console_init"></a>preloader_console_init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This requires UART clocks to be enabled.  In order <span class="keyword">for</span> this to work the</span><br><span class="line"> * <span class="built_in">caller</span> must ensure that the gd pointer is valid.</span><br><span class="line"> */</span><br><span class="line">void preloader_console_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	gd-&gt;baudrate = CONFIG_BAUDRATE;</span><br><span class="line"></span><br><span class="line">	serial_init();		/* serial communications setup */</span><br><span class="line"></span><br><span class="line">	gd-&gt;have_console = 1;</span><br><span class="line"></span><br><span class="line">	/* 这就是串口输出的第一条消息</span><br><span class="line">	 * U-Boot SPL 2019.10-rc2-00058-g1e60ccd943-dirty (Aug 26 2019 - 17:12:25 +0800)</span><br><span class="line">	 */</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(BANNER_PRINT)</span></span><br><span class="line">	puts(<span class="string">&quot;\nU-Boot &quot;</span> SPL_TPL_NAME <span class="string">&quot; &quot;</span> PLAIN_VERSION <span class="string">&quot; (&quot;</span> U_BOOT_DATE <span class="string">&quot; - &quot;</span></span><br><span class="line">	     U_BOOT_TIME <span class="string">&quot; &quot;</span> U_BOOT_TZ <span class="string">&quot;)\n&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SPL_DISPLAY_PRINT</span></span><br><span class="line">	spl_display_print();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<h3 id="sunxi-board-init"><a href="#sunxi-board-init" class="headerlink" title="sunxi_board_init"></a>sunxi_board_init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void sunxi_board_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int power_failed = 0;</span><br><span class="line"></span><br><span class="line">	/* 这些宏未定义不执行 */</span><br><span class="line"><span class="comment">#ifdef CONFIG_SY8106A_POWER</span></span><br><span class="line">	power_failed = sy8106a_set_vout1(CONFIG_SY8106A_VOUT1_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined CONFIG_AXP152_POWER || defined CONFIG_AXP209_POWER || \</span></span><br><span class="line">	defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \</span><br><span class="line">	defined CONFIG_AXP818_POWER</span><br><span class="line">	power_failed = axp_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \</span></span><br><span class="line">	defined CONFIG_AXP818_POWER</span><br><span class="line">	power_failed |= axp_set_dcdc1(CONFIG_AXP_DCDC1_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	power_failed |= axp_set_dcdc2(CONFIG_AXP_DCDC2_VOLT);</span><br><span class="line">	power_failed |= axp_set_dcdc3(CONFIG_AXP_DCDC3_VOLT);</span><br><span class="line"><span class="comment">#if !defined(CONFIG_AXP209_POWER) &amp;&amp; !defined(CONFIG_AXP818_POWER)</span></span><br><span class="line">	power_failed |= axp_set_dcdc4(CONFIG_AXP_DCDC4_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \</span></span><br><span class="line">	defined CONFIG_AXP818_POWER</span><br><span class="line">	power_failed |= axp_set_dcdc5(CONFIG_AXP_DCDC5_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \</span></span><br><span class="line">	defined CONFIG_AXP818_POWER</span><br><span class="line">	power_failed |= axp_set_aldo1(CONFIG_AXP_ALDO1_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	power_failed |= axp_set_aldo2(CONFIG_AXP_ALDO2_VOLT);</span><br><span class="line"><span class="comment">#if !defined(CONFIG_AXP152_POWER)</span></span><br><span class="line">	power_failed |= axp_set_aldo3(CONFIG_AXP_ALDO3_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_AXP209_POWER</span></span><br><span class="line">	power_failed |= axp_set_aldo4(CONFIG_AXP_ALDO4_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_AXP221_POWER) || defined(CONFIG_AXP809_POWER) || \</span></span><br><span class="line">	defined(CONFIG_AXP818_POWER)</span><br><span class="line">	power_failed |= axp_set_dldo(1, CONFIG_AXP_DLDO1_VOLT);</span><br><span class="line">	power_failed |= axp_set_dldo(2, CONFIG_AXP_DLDO2_VOLT);</span><br><span class="line"><span class="comment">#if !defined CONFIG_AXP809_POWER</span></span><br><span class="line">	power_failed |= axp_set_dldo(3, CONFIG_AXP_DLDO3_VOLT);</span><br><span class="line">	power_failed |= axp_set_dldo(4, CONFIG_AXP_DLDO4_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	power_failed |= axp_set_eldo(1, CONFIG_AXP_ELDO1_VOLT);</span><br><span class="line">	power_failed |= axp_set_eldo(2, CONFIG_AXP_ELDO2_VOLT);</span><br><span class="line">	power_failed |= axp_set_eldo(3, CONFIG_AXP_ELDO3_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_AXP818_POWER</span></span><br><span class="line">	power_failed |= axp_set_fldo(1, CONFIG_AXP_FLDO1_VOLT);</span><br><span class="line">	power_failed |= axp_set_fldo(2, CONFIG_AXP_FLDO2_VOLT);</span><br><span class="line">	power_failed |= axp_set_fldo(3, CONFIG_AXP_FLDO3_VOLT);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER</span></span><br><span class="line">	power_failed |= axp_set_sw(IS_ENABLED(CONFIG_AXP_SW_ON));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;DRAM:&quot;</span>);</span><br><span class="line">	gd-&gt;ram_size = sunxi_dram_init(); //初始化DRAM</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; %d MiB\n&quot;</span>, (int)(gd-&gt;ram_size &gt;&gt; 20)); //串口输出第二句</span><br><span class="line">	<span class="keyword">if</span> (!gd-&gt;ram_size)</span><br><span class="line">		hang();</span><br><span class="line"></span><br><span class="line">	sunxi_spl_store_dram_size(gd-&gt;ram_size);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Only clock up the CPU to full speed <span class="keyword">if</span> we are reasonably</span><br><span class="line">	 * assured it<span class="string">&#x27;s being powered with suitable core voltage</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (!power_failed)</span></span><br><span class="line"><span class="string">		clock_set_pll1(CONFIG_SYS_CLK_FREQ); //初始化时钟</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;Failed to set core voltage! Can&#x27;</span>t <span class="built_in">set</span> CPU frequency\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br></pre></td></tr></table></figure>
<p>board_init_f主要完成了spl初始化具体就是gd-&gt;bootstage结构体初始化和赋值，log初始化，fdtdec_setup函数，串口初始化，DRAM初始化，时钟初始化等</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>board_init_f spl</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-build</title>
    <url>/2018/04/14/u-boot-build/</url>
    <content><![CDATA[<h3 id="uboot编译"><a href="#uboot编译" class="headerlink" title="uboot编译"></a>uboot编译</h3><ol>
<li>clone code<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yyliushuai/u-boot</span><br></pre></td></tr></table></figure></li>
<li>安装交叉编译工具链<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S aarch64-linux-gnu-gcc</span><br></pre></td></tr></table></figure></li>
<li>导出环境变量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br></pre></td></tr></table></figure></li>
<li>生成.config<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make pine_h64_defconfig</span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="arm-trusted-firmware编译"><a href="#arm-trusted-firmware编译" class="headerlink" title="arm-trusted-firmware编译"></a>arm-trusted-firmware编译</h3></li>
<li>clone code<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yyliushuai/arm-trusted-firmware </span><br></pre></td></tr></table></figure></li>
<li>导出环境变量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make PLAT=sun50i_h6</span><br></pre></td></tr></table></figure></li>
<li>拷贝build/sun50i_h6/release/bl31.bin 到uboot编译目录重新编译uboot</li>
</ol>
<h3 id="制作SD启动卡Bootable-SD-card"><a href="#制作SD启动卡Bootable-SD-card" class="headerlink" title="制作SD启动卡Bootable SD card"></a>制作SD启动卡<a href="http://linux-sunxi.org/Bootable_SD_card#Bootloader">Bootable SD card</a></h3><p>具体操作：</p>
<ul>
<li>If the SD card is connected via USB and is sdX (replace X for a correct letter)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> card=/dev/sdX</span><br><span class="line"><span class="built_in">export</span> p=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
or<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> card=/dev/mmcblk0</span><br><span class="line"><span class="built_in">export</span> p=p</span><br></pre></td></tr></table></figure></li>
<li>cleaning<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$&#123;card&#125;</span> bs=1M count=1</span><br></pre></td></tr></table></figure>
如果要保持原分区则<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$&#123;card&#125;</span> bs=1M count=1</span><br></pre></td></tr></table></figure></li>
<li>写如SD卡<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin of=<span class="variable">$&#123;card&#125;</span> bs=1024 seek=8</span><br></pre></td></tr></table></figure>
如果使用的是u-boot v2013.07版本之前的使用如下命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=spl/sunxi-spl.bin of=<span class="variable">$&#123;card&#125;</span> bs=1024 seek=8</span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot.bin of=<span class="variable">$&#123;card&#125;</span> bs=1024 seek=32</span><br></pre></td></tr></table></figure>
通过uboot的tftp命令更新uboot<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mw.b 0x48000000 0x00 0x100000                 <span class="comment"># Zero buffer</span></span><br><span class="line">tftp 0x48000000 u-boot-sunxi-with-spl.bin     <span class="comment"># Or use load to read from MMC or SCSI etc</span></span><br><span class="line">mmc erase 0x10 0x400                          <span class="comment"># Erase the MMC region containing u-boot, do not reset at this point!</span></span><br><span class="line">mmc write 0x48000000 0x10 0x400               <span class="comment"># Write updated u-boot</span></span><br></pre></td></tr></table></figure>
至此uboot写入就完成了，下面对sd卡分区<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo blockdev --rereadpt <span class="variable">$&#123;card&#125;</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOT | sudo sfdisk $&#123;card&#125;</span></span><br><span class="line"><span class="string">1M,16M,c</span></span><br><span class="line"><span class="string">,,L</span></span><br><span class="line"><span class="string">EOT</span></span><br></pre></td></tr></table></figure>
创建文件系统<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.vfat <span class="variable">$&#123;card&#125;</span><span class="variable">$&#123;p&#125;</span>1</span><br><span class="line">mkfs.ext4 <span class="variable">$&#123;card&#125;</span><span class="variable">$&#123;p&#125;</span>2</span><br></pre></td></tr></table></figure>
sd卡GPT分区表如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start	size	usage</span><br><span class="line">0	0.5KB	Protective MBR</span><br><span class="line">1	0.5KB	GPT header</span><br><span class="line">2	7KB	Unused</span><br><span class="line">8	32KB	Initial SPL loader</span><br><span class="line">40	504KB	U-Boot</span><br><span class="line">544	128KB	environment</span><br><span class="line">672	128KB	Falcon mode boot params</span><br><span class="line">800	-	Falcon mode kernel start</span><br><span class="line">1024	16KB	Partition table</span><br><span class="line">1056	-	Free <span class="keyword">for</span> partitions</span><br></pre></td></tr></table></figure>
<h3 id="sunxi-tools的安装"><a href="#sunxi-tools的安装" class="headerlink" title="sunxi-tools的安装"></a>sunxi-tools的安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b h6 https://github.com/yyliushuai/sunxi-tools</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br><span class="line">sudo apt-get install libusb-1.0</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>H6 uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-cmd</title>
    <url>/2018/08/27/u-boot-cmd/</url>
    <content><![CDATA[<h3 id="u-boot命令"><a href="#u-boot命令" class="headerlink" title="u-boot命令"></a>u-boot命令</h3><p>以version为例查看u-boot是如何实现命令执行的以及如何自定义一个命令。<br>先看一个宏U_BOOT_CMD</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	version,	1,		1,	do_version,</span><br><span class="line">	<span class="string">&quot;print monitor, compiler and linker version&quot;</span>,</span><br><span class="line">	<span class="string">&quot;&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其定义如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)		\</span></span><br><span class="line">	U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \</span></span><br><span class="line">	ll_entry_declare(cmd_tbl_t, _name, cmd) =			\</span><br><span class="line">		U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,	\</span><br><span class="line">						_usage, _help, _comp);</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define ll_entry_declare(_type, _name, _list)				\</span></span><br><span class="line">	_type _u_boot_list_2_<span class="comment">##_list##_2_##_name __aligned(4)		\</span></span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_&quot;</span><span class="comment">#_list&quot;_2_&quot;#_name)))</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\</span></span><br><span class="line">				_usage, _help, _comp)			\</span><br><span class="line">		&#123; <span class="comment">#_name, _maxargs,					\</span></span><br><span class="line">		 _rep ? cmd_always_repeatable : cmd_never_repeatable,	\</span><br><span class="line">		 _cmd, _usage, _CMD_HELP(_help) _CMD_COMPLETE(_comp) &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">#ifdef CONFIG_AUTO_COMPLETE</span></span><br><span class="line"><span class="comment"># define _CMD_COMPLETE(x) x,</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment"># define _CMD_COMPLETE(x)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_LONGHELP</span></span><br><span class="line"><span class="comment"># define _CMD_HELP(x) x,</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment"># define _CMD_HELP(x)</span></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>展开如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD_COMPLETE(version, 1, 1, do_version, <span class="string">&quot;print monitor, compiler and linker version&quot;</span>, “”, null)</span><br><span class="line">ll_entry_declare(cmd_tbl_t, version, cmd) = U_BOOT_CMD_MKENT_COMPLETE(version, 1, 1, do_version,	\</span><br><span class="line">						<span class="string">&quot;print monitor, compiler and linker version&quot;</span>, <span class="string">&quot;&quot;</span>, null);</span><br><span class="line"></span><br><span class="line">cmd_tbl_t _u_boot_list_2_cmd_2_version __aligned(4)__attribute__((unused,				\</span><br><span class="line">		section(<span class="string">&quot;.u_boot_list_2_cmd_2_version&quot;</span>))) = </span><br><span class="line">		&#123; <span class="string">&quot;version&quot;</span>, 1,					\</span><br><span class="line">		  1 ? cmd_always_repeatable : cmd_never_repeatable,	\</span><br><span class="line">		  do_version, <span class="string">&quot;print monitor, compiler and linker version&quot;</span>, <span class="string">&quot;&quot;</span> ,null &#125;</span><br></pre></td></tr></table></figure>
<p>下面看下 这个结构体的定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct cmd_tbl_s	cmd_tbl_t;</span><br><span class="line">struct cmd_tbl_s &#123;</span><br><span class="line">	char		*name;		/* Command Name	*/ //命令名</span><br><span class="line">	int		maxargs;	/* maximum number of arguments */ //最多参数个数</span><br><span class="line">					/*</span><br><span class="line">					 * Same as -&gt;cmd() except the <span class="built_in">command</span></span><br><span class="line">					 * tells us <span class="keyword">if</span> it can be repeated.</span><br><span class="line">					 * Replaces the old -&gt;repeatable field</span><br><span class="line">					 * <span class="built_in">which</span> was not able to make</span><br><span class="line">					 * repeatable property different <span class="keyword">for</span></span><br><span class="line">					 * the main <span class="built_in">command</span> and sub-commands.</span><br><span class="line">					 */</span><br><span class="line">	int		(*cmd_rep)(struct cmd_tbl_s *cmd, int flags, int argc,</span><br><span class="line">				   char * const argv[], int *repeatable); //命令是否可以重复</span><br><span class="line">					/* Implementation <span class="keyword">function</span>	*/</span><br><span class="line">	int		(*cmd)(struct cmd_tbl_s *, int, int, char * const []); //函数指针，指向实际执行命令的函数</span><br><span class="line">	char		*usage;		/* Usage message	(short)	*/ //简短的帮助信息</span><br><span class="line"><span class="comment">#ifdef	CONFIG_SYS_LONGHELP</span></span><br><span class="line">	char		*<span class="built_in">help</span>;		/* Help  message	(long)	*/ //长的帮助信息</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_AUTO_COMPLETE</span></span><br><span class="line">	/* <span class="keyword">do</span> auto completion on the arguments */</span><br><span class="line">	int		(*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到自定义一个命令很简单直接调用U_BOOT_CMD这个宏就可以，而这个宏定义实际上是定义一个cmd_tbl_s结构体并初始化他，将其放在.u_boot_list_2_cmd_2_version段中。</p>
<h3 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h3><p>这部分代码还未分析，日后有时间再回来补上…</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-driver</title>
    <url>/2018/08/27/u-boot-driver/</url>
    <content><![CDATA[<h3 id="几个宏定义"><a href="#几个宏定义" class="headerlink" title="几个宏定义"></a>几个宏定义</h3><p><strong>U_BOOT_DEVICE(demo0)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define U_BOOT_DEVICE(__name)						\</span></span><br><span class="line">	ll_entry_declare(struct driver_info, __name, driver_info)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define ll_entry_declare(_type, _name, _list)				\</span></span><br><span class="line">	_type _u_boot_list_2_<span class="comment">##_list##_2_##_name __aligned(4)		\</span></span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_&quot;</span><span class="comment">#_list&quot;_2_&quot;#_name)))</span></span><br></pre></td></tr></table></figure>
<p>展开得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll_entry_declare(struct driver_info, demo0, driver_info)</span><br><span class="line">struct driver_info _u_boot_list_2_driver_info_2_demo0 __aligned(4)	__attribute__((unused,		\</span><br><span class="line">	section(<span class="string">&quot;.u_boot_list_2_driver_info_2_demo0&quot;</span>)))  = &#123;</span><br><span class="line">	.name = <span class="string">&quot;demo_simple_drv&quot;</span>,</span><br><span class="line">	.platdata = &amp;red_square,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个driver_info结构体放入u_boot_list_2_driver_info_2_demo0段中，注册一个device一般使用dts设备树，这种方式使用较少。</p>
<p><strong>U_BOOT_DRIVER</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Declare a new U-Boot driver */</span><br><span class="line"><span class="comment">#define U_BOOT_DRIVER(__name)						\</span></span><br><span class="line">	ll_entry_declare(struct driver, __name, driver)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define ll_entry_declare(_type, _name, _list)				\</span></span><br><span class="line">	_type _u_boot_list_2_<span class="comment">##_list##_2_##_name __aligned(4)		\</span></span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_&quot;</span><span class="comment">#_list&quot;_2_&quot;#_name)))</span></span><br></pre></td></tr></table></figure>
<p>U_BOOT_DRIVER(demo_shape_drv)展开得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct driver _u_boot_list_2_driver_2_demo_shape_drv __aligned(4)		\</span><br><span class="line">			__attribute__((unused,				\</span><br><span class="line">			section(<span class="string">&quot;.u_boot_list_2_driver_2_demo_shape_drv&quot;</span>))) = &#123;</span><br><span class="line">				.name	= <span class="string">&quot;demo_shape_drv&quot;</span>,</span><br><span class="line">				.of_match = demo_shape_id,</span><br><span class="line">				.id	= UCLASS_DEMO,</span><br><span class="line">				.ofdata_to_platdata = shape_ofdata_to_platdata,</span><br><span class="line">				.ops	= &amp;shape_ops,</span><br><span class="line">				.probe = dm_shape_probe,</span><br><span class="line">				.remove = dm_shape_remove,</span><br><span class="line">				.priv_auto_alloc_size = sizeof(struct shape_data),</span><br><span class="line">				.platdata_auto_alloc_size = sizeof(struct dm_demo_pdata),</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义一个driver结构体放入u_boot_list_2_driver_2_demo_shape_drv段中。</p>
<p><strong>UCLASS_DRIVER(demo)</strong><br>与之前的宏定义类似只是struct不同，这里是uclass_driver成员如下</p>
<p>###几个数据结构</p>
<p><strong>udevice</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">driver</span> *<span class="title">driver</span>;</span> <span class="comment">// 该udevice对应的driver</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 设备名</span></span><br><span class="line">    <span class="keyword">void</span> *platdata; <span class="comment">// 该udevice的平台数据</span></span><br><span class="line">    <span class="keyword">void</span> *parent_platdata; <span class="comment">// 提供给父设备使用的平台数据</span></span><br><span class="line">    <span class="keyword">void</span> *uclass_platdata; <span class="comment">// 提供给所属uclass使用的平台数据</span></span><br><span class="line">    <span class="keyword">int</span> of_offset; <span class="comment">// 该udevice的dtb节点偏移，代表了dtb里面的这个节点node</span></span><br><span class="line">    ulong driver_data; <span class="comment">// 驱动数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">parent</span>;</span> <span class="comment">// 父设备</span></span><br><span class="line">    <span class="keyword">void</span> *priv; <span class="comment">// 私有数据的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uclass</span> *<span class="title">uclass</span>;</span> <span class="comment">// 所属uclass</span></span><br><span class="line">    <span class="keyword">void</span> *uclass_priv; <span class="comment">// 提供给所属uclass使用的私有数据指针</span></span><br><span class="line">    <span class="keyword">void</span> *parent_priv; <span class="comment">// 提供给其父设备使用的私有数据指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">uclass_node</span>;</span> <span class="comment">// 用于连接到其所属uclass的链表上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">child_head</span>;</span> <span class="comment">// 链表头，连接其子设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling_node</span>;</span> <span class="comment">// 用于连接到其父设备的链表上</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">// 标识</span></span><br><span class="line">    <span class="keyword">int</span> req_seq;</span><br><span class="line">    <span class="keyword">int</span> seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEVRES</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devres_head</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>udevice一般由u-boot解析dtb后生成，或则通过U_BOOT_DEVICE宏定义一个udevice结构体，获得该结构体的API如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int uclass_get_device(enum uclass_id id, int index, struct udevice **devp); </span><br><span class="line">int uclass_get_device_by_name(enum uclass_id id, const char *name,  struct udevice **devp);</span><br><span class="line">int uclass_get_device_by_seq(enum uclass_id id, int seq, struct udevice **devp);</span><br><span class="line">int uclass_get_device_by_of_offset(enum uclass_id id, int node,struct udevice **devp);</span><br><span class="line">int uclass_get_device_by_phandle(enum uclass_id id, struct udevice *parent, const char *name, struct udevice **devp);</span><br><span class="line">int uclass_first_device(enum uclass_id id, struct udevice **devp);</span><br><span class="line">int uclass_first_device_err(enum uclass_id id, struct udevice **devp);</span><br><span class="line">int uclass_next_device(struct udevice **devp);</span><br><span class="line">int uclass_resolve_seq(struct udevice *dev);</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define uclass_foreach_dev(pos, uc) \</span></span><br><span class="line">    list_for_each_entry(pos, &amp;uc-&gt;dev_head, uclass_node)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define uclass_foreach_dev_safe(pos, next, uc)  \</span></span><br><span class="line">    list_for_each_entry_safe(pos, next, &amp;uc-&gt;dev_head, uclass_node)</span><br></pre></td></tr></table></figure>
<p><strong>driver</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct udevice &#123;</span><br><span class="line">struct driver &#123;</span><br><span class="line">    char *name;    // 驱动名</span><br><span class="line">    enum uclass_id id;  // 对应的uclass id</span><br><span class="line">    const struct udevice_id *of_match;    // compatible字符串的匹配表，用于和device tree里面的设备节点匹配</span><br><span class="line">    int (*<span class="built_in">bind</span>)(struct udevice *dev);   // 用于绑定目标设备到该driver中</span><br><span class="line">    int (*probe)(struct udevice *dev);   // 用于probe目标设备,激活</span><br><span class="line">    int (*remove)(struct udevice *dev); // 用于remove目标设备。禁用</span><br><span class="line">    int (*unbind)(struct udevice *dev); // 用于解绑目标设备到该driver中</span><br><span class="line">    int (*ofdata_to_platdata)(struct udevice *dev); // 在probe之前，解析对应udevice的dts节点，转化成udevice的平台数据</span><br><span class="line">    int (*child_post_bind)(struct udevice *dev); // 如果目标设备的一个子设备被绑定之后，调用</span><br><span class="line">    int (*child_pre_probe)(struct udevice *dev); // 在目标设备的一个子设备被probe之前，调用</span><br><span class="line">    int (*child_post_remove)(struct udevice *dev); // 在目标设备的一个子设备被remove之后，调用</span><br><span class="line">    int priv_auto_alloc_size; //需要分配多少空间作为其udevice的私有数据</span><br><span class="line">    int platdata_auto_alloc_size; //需要分配多少空间作为其udevice的平台数据</span><br><span class="line">    int per_child_auto_alloc_size;  // 对于目标设备的每个子设备需要分配多少空间作为父设备的私有数据</span><br><span class="line">    int per_child_platdata_auto_alloc_size; // 对于目标设备的每个子设备需要分配多少空间作为父设备的平台数据</span><br><span class="line">    const void *ops;    /* driver-specific operations */ // 操作集合的指针，提供给uclass使用，没有规定操作集的格式，由具体uclass决定</span><br><span class="line">    uint32_t flags; // 一些标志位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过U_BOOT_DRIVER这个宏定义该结构体，通过如下获取该结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    struct driver *drv =</span><br><span class="line">        ll_entry_start(struct driver, driver);</span><br><span class="line">// 会根据.u_boot_list_2_driver_1的段地址来得到uclass_driver table的地址</span><br><span class="line"></span><br><span class="line">    const int n_ents = ll_entry_count(struct driver, driver);</span><br><span class="line">// 获得driver table的长度</span><br></pre></td></tr></table></figure>
<p>通过如下遍历该结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct driver *lists_driver_lookup_name(const char *name)</span><br><span class="line">// 从driver table中获取名字为name的driver。</span><br></pre></td></tr></table></figure>
<p><strong>uclass</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct uclass &#123;</span><br><span class="line">    void *priv;  // uclass的私有数据指针</span><br><span class="line">    struct uclass_driver *uc_drv; // 对应的uclass driver</span><br><span class="line">    struct list_head dev_head; // 链表头，连接所属的所有udevice</span><br><span class="line">    struct list_head sibling_node; // 链表节点，用于把uclass连接到uclass_root链表上</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>uclass是uboot自动生成。并且不是所有uclass都会生成，有对应uclass driver并且有被udevice匹配到的uclass才会生成。<br>获得该结构体API如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int uclass_get(enum uclass_id key, struct uclass **ucp);</span><br><span class="line">// 从gd-&gt;uclass_root链表获取对应的uclass</span><br></pre></td></tr></table></figure>
<p><strong>uclass_driver</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct uclass_driver &#123;</span><br><span class="line">    const char *name; // 该uclass_driver的名字</span><br><span class="line">    enum uclass_id id; // 对应的uclass id</span><br><span class="line">/* 以下函数指针主要是调用时机的区别 */</span><br><span class="line">    int (*post_bind)(struct udevice *dev); // 在udevice被绑定到该uclass之后调用</span><br><span class="line">    int (*pre_unbind)(struct udevice *dev); // 在udevice被解绑出该uclass之前调用</span><br><span class="line">    int (*pre_probe)(struct udevice *dev); // 在该uclass的一个udevice进行probe之前调用</span><br><span class="line">    int (*post_probe)(struct udevice *dev); // 在该uclass的一个udevice进行probe之后调用</span><br><span class="line">    int (*pre_remove)(struct udevice *dev);// 在该uclass的一个udevice进行remove之前调用</span><br><span class="line">    int (*child_post_bind)(struct udevice *dev); // 在该uclass的一个udevice的一个子设备被绑定到该udevice之后调用</span><br><span class="line">    int (*child_pre_probe)(struct udevice *dev); // 在该uclass的一个udevice的一个子设备进行probe之前调用</span><br><span class="line">    int (*init)(struct uclass *class); // 安装该uclass的时候调用</span><br><span class="line">    int (*destroy)(struct uclass *class); // 销毁该uclass的时候调用</span><br><span class="line">    int priv_auto_alloc_size; // 需要为对应的uclass分配多少私有数据</span><br><span class="line">    int per_device_auto_alloc_size; //</span><br><span class="line">    int per_device_platdata_auto_alloc_size; //</span><br><span class="line">    int per_child_auto_alloc_size; //</span><br><span class="line">    int per_child_platdata_auto_alloc_size;  //</span><br><span class="line">    const void *ops; //操作集合</span><br><span class="line">    uint32_t flags;   // 标识为</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过UCLASS_DRIVER来定义uclass_driver.<br>对应API如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   struct uclass_driver *uclass =</span><br><span class="line">        ll_entry_start(struct uclass_driver, uclass); </span><br><span class="line">// 会根据.u_boot_list_2_uclass_1的段地址来得到uclass_driver table的地址</span><br><span class="line"></span><br><span class="line">    const int n_ents = ll_entry_count(struct uclass_driver, uclass);</span><br><span class="line">// 获得uclass_driver table的长度</span><br><span class="line"></span><br><span class="line">struct uclass_driver *lists_uclass_lookup(enum uclass_id id)</span><br><span class="line">// 从uclass_driver table中获取uclass id为id的uclass_driver。</span><br></pre></td></tr></table></figure>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>上层接口都是和uclass的接口直接通讯。</li>
<li>uclass可以理解为一些具有相同属性的udevice对外操作的接口，uclass的驱动是uclass_driver，主要为上层提供接口。</li>
<li>udevice的是指具体设备的抽象，对应驱动是driver，driver主要负责和硬件通信，为uclass提供实际的操作集。</li>
<li>udevice找到对应的uclass的方式主要是通过：udevice对应的driver的id和uclass对应的uclass_driver的id是否匹配。</li>
<li>udevice会和uclass绑定。driver会和udevice绑定。uclass_driver会和uclass绑定。<br>uclass和udevice都是动态生成的。在解析fdt中的设备的时候，会动态生成udevice。然后找到udevice对应的driver，通过driver中的uclass id得到uclass_driver id。从uclass链表中查找对应的uclass是否已经生成，没有生成的话则动态生成uclass。</li>
</ul>
<h3 id="dm初始化"><a href="#dm初始化" class="headerlink" title="dm初始化"></a>dm初始化</h3><p><strong>board_init_f</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if defined(CONFIG_DM) &amp;&amp; CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	bootstage_start(BOOTSTATE_ID_ACCUM_DM_F, <span class="string">&quot;dm_f&quot;</span>);</span><br><span class="line">	ret = dm_init_and_scan(<span class="literal">true</span>);</span><br><span class="line">			int ret;</span><br><span class="line"></span><br><span class="line">			ret = dm_init(IS_ENABLED(CONFIG_OF_LIVE));    // DM的初始化</span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				debug(<span class="string">&quot;dm_init() failed: %d\n&quot;</span>, ret);</span><br><span class="line">				<span class="built_in">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line">			ret = dm_scan_platdata(pre_reloc_only);  //  从平台设备中解析udevice和uclass</span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				debug(<span class="string">&quot;dm_scan_platdata() failed: %d\n&quot;</span>, ret);</span><br><span class="line">				<span class="built_in">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_CONTROL) &amp;&amp; !CONFIG_IS_ENABLED(OF_PLATDATA)) &#123;</span><br><span class="line">				ret = dm_extended_scan_fdt(gd-&gt;fdt_blob, pre_reloc_only);   // 从dtb中解析udevice和uclass</span><br><span class="line">				<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">					debug(<span class="string">&quot;dm_extended_scan_dt() failed: %d\n&quot;</span>, ret);</span><br><span class="line">					<span class="built_in">return</span> ret;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ret = dm_scan_other(pre_reloc_only);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">	bootstage_accum(BOOTSTATE_ID_ACCUM_DM_F);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_TIMER_EARLY</span></span><br><span class="line">	ret = dm_timer_init();</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br></pre></td></tr></table></figure>
<p><strong>dm_init</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;dm_root) &#123;</span><br><span class="line">		dm_warn(<span class="string">&quot;Virtual root driver already exists!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * <span class="comment">#define DM_UCLASS_ROOT_NON_CONST	(((gd_t *)gd)-&gt;uclass_root)</span></span><br><span class="line">	 * 初始化gd-&gt;uclass_root</span><br><span class="line">	 */</span><br><span class="line">	INIT_LIST_HEAD(&amp;DM_UCLASS_ROOT_NON_CONST);</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_NEEDS_MANUAL_RELOC)</span></span><br><span class="line">	fix_drivers();</span><br><span class="line">	fix_uclass();</span><br><span class="line">	fix_devices();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	    // DM_ROOT_NON_CONST是指根设备udevice，root_info是表示根设备的设备信息</span><br><span class="line">        // device_bind_by_name会查找和设备信息匹配的driver，然后创建对应的udevice和uclass并进行绑定，最后放在DM_ROOT_NON_CONST中。</span><br><span class="line">        // device_bind_by_name后续我们会进行说明，这里我们暂时只需要了解root根设备的udevice以及对应的uclass都已经创建完成。</span><br><span class="line"></span><br><span class="line">	ret = device_bind_by_name(NULL, <span class="literal">false</span>, &amp;root_info, &amp;DM_ROOT_NON_CONST);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(OF_CONTROL)</span></span><br><span class="line"><span class="comment"># if CONFIG_IS_ENABLED(OF_LIVE)</span></span><br><span class="line">	<span class="keyword">if</span> (of_live)</span><br><span class="line">		DM_ROOT_NON_CONST-&gt;node = np_to_ofnode(gd-&gt;of_root);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		DM_ROOT_NON_CONST-&gt;node = offset_to_ofnode(0);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	ret = device_probe(DM_ROOT_NON_CONST);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br></pre></td></tr></table></figure>
<p>（1）创建根设备root的udevice，存放在gd-&gt;dm_root中。<br>（2）初始化uclass链表gd-&gt;uclass_root</p>
<p><strong>dm_scan_fdt</strong><br>从dtb中解析udevice和uclass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int dm_scan_fdt(const void *blob, bool pre_reloc_only)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(OF_LIVE)</span></span><br><span class="line">	<span class="keyword">if</span> (of_live_active())</span><br><span class="line">		<span class="built_in">return</span> dm_scan_fdt_live(gd-&gt;dm_root, gd-&gt;of_root,</span><br><span class="line">					pre_reloc_only);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="built_in">return</span> dm_scan_fdt_node(gd-&gt;dm_root, blob, 0, pre_reloc_only);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int dm_scan_fdt_node(struct udevice *parent, const void *blob,</span><br><span class="line">			    int offset, bool pre_reloc_only)</span><br><span class="line">&#123;</span><br><span class="line">	// 此时传进来的参数</span><br><span class="line">	// parent=gd-&gt;dm_root，表示以root设备作为父设备开始解析</span><br><span class="line">	// blob=gd-&gt;fdt_blob，指定了对应的dtb</span><br><span class="line">	// offset=0，从偏移0的节点开始扫描</span><br><span class="line">	// pre_reloc_only=0，不只是解析relotion之前的设备</span><br><span class="line"></span><br><span class="line">	int ret = 0, err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = fdt_first_subnode(blob, offset); // 获得blob设备树的offset偏移下的节点的第一个子节点</span><br><span class="line">	     offset &gt; 0;</span><br><span class="line">	     offset = fdt_next_subnode(blob, offset)) &#123;   // 循环查找下一个子节点</span><br><span class="line">		const char *node_name = fdt_get_name(blob, offset, NULL);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * The <span class="string">&quot;chosen&quot;</span> and <span class="string">&quot;firmware&quot;</span> nodes aren<span class="string">&#x27;t devices</span></span><br><span class="line"><span class="string">		 * themselves but may contain some:</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		if (!strcmp(node_name, &quot;chosen&quot;) ||</span></span><br><span class="line"><span class="string">		    !strcmp(node_name, &quot;firmware&quot;)) &#123;</span></span><br><span class="line"><span class="string">			pr_debug(&quot;parsing subnodes of \&quot;%s\&quot;\n&quot;, node_name);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			err = dm_scan_fdt_node(parent, blob, offset,</span></span><br><span class="line"><span class="string">					       pre_reloc_only);</span></span><br><span class="line"><span class="string">			if (err &amp;&amp; !ret)</span></span><br><span class="line"><span class="string">				ret = err;</span></span><br><span class="line"><span class="string">			continue;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if (!fdtdec_get_is_enabled(blob, offset)) &#123;   // 判断节点状态是否是disable，如果是的话直接忽略</span></span><br><span class="line"><span class="string">			pr_debug(&quot;   - ignoring disabled device\n&quot;);</span></span><br><span class="line"><span class="string">			continue;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		err = lists_bind_fdt(parent, offset_to_ofnode(offset), NULL,</span></span><br><span class="line"><span class="string">				     pre_reloc_only);   // 解析绑定这个节点，dm_scan_fdt的核心，下面具体分析</span></span><br><span class="line"><span class="string">		if (err &amp;&amp; !ret) &#123;</span></span><br><span class="line"><span class="string">			ret = err;</span></span><br><span class="line"><span class="string">			debug(&quot;%s: ret=%d\n&quot;, node_name, ret);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (ret)</span></span><br><span class="line"><span class="string">		dm_warn(&quot;Some drivers failed to bind\n&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>lists_bind_fdt</strong><br>从dtb中解析udevice和uclass的核心</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,</span><br><span class="line">		   bool pre_reloc_only)</span><br><span class="line">&#123;</span><br><span class="line">	struct driver *driver = ll_entry_start(struct driver, driver); // 获取driver table地址</span><br><span class="line">	const int n_ents = ll_entry_count(struct driver, driver); // 获取driver table长度</span><br><span class="line">	const struct udevice_id *id;</span><br><span class="line">	struct driver *entry;</span><br><span class="line">	struct udevice *dev;</span><br><span class="line">	bool found = <span class="literal">false</span>;</span><br><span class="line">	const char *name, *compat_list, *compat;</span><br><span class="line">	int compat_length, i;</span><br><span class="line">	int result = 0;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (devp)</span><br><span class="line">		*devp = NULL;</span><br><span class="line">	name = ofnode_get_name(node);</span><br><span class="line">	pr_debug(<span class="string">&quot;bind node %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	compat_list = ofnode_get_property(node, <span class="string">&quot;compatible&quot;</span>, &amp;compat_length);</span><br><span class="line">	<span class="keyword">if</span> (!compat_list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compat_length == -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;Device &#x27;%s&#x27; has no compatible string\n&quot;</span>,</span><br><span class="line">				 name);</span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dm_warn(<span class="string">&quot;Device tree error at node &#x27;%s&#x27;\n&quot;</span>, name);</span><br><span class="line">		<span class="built_in">return</span> compat_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Walk through the compatible string list, attempting to match each</span><br><span class="line">	 * compatible string <span class="keyword">in</span> order such that we match <span class="keyword">in</span> order of priority</span><br><span class="line">	 * from the first string to the last.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; compat_length; i += strlen(compat) + 1) &#123;</span><br><span class="line">		compat = compat_list + i;</span><br><span class="line">		pr_debug(<span class="string">&quot;   - attempt to match compatible string &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">			 compat);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (entry = driver; entry != driver + n_ents; entry++) &#123;  // 遍历driver table中的所有driver</span><br><span class="line">			ret = driver_check_compatible(entry-&gt;of_match, &amp;id,</span><br><span class="line">						      compat);  // 判断driver中的compatibile字段和dts节点是否匹配</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (entry == driver + n_ents)</span><br><span class="line">			<span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pre_reloc_only) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!dm_ofnode_pre_reloc(node) &amp;&amp;</span><br><span class="line">			    !(entry-&gt;flags &amp; DM_FLAG_PRE_RELOC))</span><br><span class="line">				<span class="built_in">return</span> 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pr_debug(<span class="string">&quot;   - found match at &#x27;%s&#x27;\n&quot;</span>, entry-&gt;name);</span><br><span class="line">		ret = device_bind_with_driver_data(parent, entry, name,</span><br><span class="line">						   id-&gt;data, node, &amp;dev); // 找到对应的driver，调用device_bind进行绑定，会在这个函数中创建对应udevice和uclass并切进行绑定</span><br><span class="line">		<span class="keyword">if</span> (ret == -ENODEV) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;Driver &#x27;%s&#x27; refuses to bind\n&quot;</span>, entry-&gt;name);</span><br><span class="line">			<span class="built_in">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dm_warn(<span class="string">&quot;Error binding driver &#x27;%s&#x27;: %d\n&quot;</span>, entry-&gt;name,</span><br><span class="line">				ret);</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			found = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (devp)</span><br><span class="line">				*devp = dev;  // 将udevice设置到devp指向的地方中，进行返回</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!found &amp;&amp; !result &amp;&amp; ret != -ENODEV)</span><br><span class="line">		pr_debug(<span class="string">&quot;No match for node &#x27;%s&#x27;\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p><strong>device_bind_common</strong><br>device_bind_with_driver_data直接调用device_bind_common</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int device_bind_common(struct udevice *parent, const struct driver *drv,</span><br><span class="line">			      const char *name, void *platdata,</span><br><span class="line">			      ulong driver_data, ofnode node,</span><br><span class="line">			      uint of_platdata_size, struct udevice **devp)</span><br><span class="line">&#123;</span><br><span class="line">	// parent:父设备</span><br><span class="line">	// drv：设备对应的driver</span><br><span class="line">	// name：设备名称</span><br><span class="line">	// platdata：设备的平台数据指针</span><br><span class="line">	// of_offset：在dtb中的偏移，即代表了其dts节点</span><br><span class="line">	// devp：所创建的udevice的指针，用于返回</span><br><span class="line">	struct udevice *dev;</span><br><span class="line">	struct uclass *uc;</span><br><span class="line">	int size, ret = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (devp)</span><br><span class="line">		*devp = NULL;</span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	ret = uclass_get(drv-&gt;id, &amp;uc);   // 获取driver id对应的uclass，如果uclass原先并不存在，那么会在这里创建uclass并其uclass_driver进行绑定</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		debug(<span class="string">&quot;Missing uclass for driver %s\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = calloc(1, sizeof(struct udevice));    // 分配一个udevice</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;sibling_node);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;child_head);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;uclass_node);</span><br><span class="line"><span class="comment">#ifdef CONFIG_DEVRES</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	dev-&gt;platdata = platdata;   // 设置udevice的平台数据指针</span><br><span class="line">	dev-&gt;driver_data = driver_data;  //设置driver的name</span><br><span class="line">	dev-&gt;name = name;  // 设置udevice的name</span><br><span class="line">	dev-&gt;node = node; // 设置udevice的dts节点偏移</span><br><span class="line">	dev-&gt;parent = parent;  // 设置udevice的父设备</span><br><span class="line">	dev-&gt;driver = drv;  // 设置udevice的对应的driver，相当于driver和udevice的绑定</span><br><span class="line">	dev-&gt;uclass = uc;   // 设置udevice的所属uclass</span><br><span class="line"></span><br><span class="line">	dev-&gt;seq = -1;</span><br><span class="line">	dev-&gt;req_seq = -1;</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(DM_SEQ_ALIAS) &amp;&amp;</span><br><span class="line">	    (uc-&gt;uc_drv-&gt;flags &amp; DM_UC_FLAG_SEQ_ALIAS)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Some devices, such as a SPI bus, I2C bus and serial ports</span><br><span class="line">		 * are numbered using aliases.</span><br><span class="line">		 *</span><br><span class="line">		 * This is just a <span class="string">&#x27;requested&#x27;</span> sequence, and will be</span><br><span class="line">		 * resolved (and -&gt;seq updated) when the device is probed.</span><br><span class="line">		 */</span><br><span class="line">		<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_CONTROL) &amp;&amp; !CONFIG_IS_ENABLED(OF_PLATDATA)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (uc-&gt;uc_drv-&gt;name &amp;&amp; ofnode_valid(node))</span><br><span class="line">				dev_read_alias_seq(dev, &amp;dev-&gt;req_seq);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dev-&gt;req_seq = uclass_find_next_free_req_seq(drv-&gt;id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;platdata_auto_alloc_size) &#123;</span><br><span class="line">		bool alloc = !platdata;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_PLATDATA)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (of_platdata_size) &#123;</span><br><span class="line">				dev-&gt;flags |= DM_FLAG_OF_PLATDATA;</span><br><span class="line">				<span class="keyword">if</span> (of_platdata_size &lt;</span><br><span class="line">						drv-&gt;platdata_auto_alloc_size)</span><br><span class="line">					alloc = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (alloc) &#123;</span><br><span class="line">			dev-&gt;flags |= DM_FLAG_ALLOC_PDATA;</span><br><span class="line">			dev-&gt;platdata = calloc(1, drv-&gt;platdata_auto_alloc_size); // 为udevice分配平台数据的空间，由driver中的platdata_auto_alloc_size决定</span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;platdata) &#123;</span><br><span class="line">				ret = -ENOMEM;</span><br><span class="line">				goto fail_alloc1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_PLATDATA) &amp;&amp; platdata) &#123;</span><br><span class="line">				memcpy(dev-&gt;platdata, platdata,</span><br><span class="line">				       of_platdata_size);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size = uc-&gt;uc_drv-&gt;per_device_platdata_auto_alloc_size;</span><br><span class="line">	<span class="keyword">if</span> (size) &#123;</span><br><span class="line">		dev-&gt;flags |= DM_FLAG_ALLOC_UCLASS_PDATA;</span><br><span class="line">		dev-&gt;uclass_platdata = calloc(1, size);  // 为udevice分配给其所属uclass使用的平台数据的空间，由所属uclass的driver中的per_device_platdata_auto_alloc_size决定</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;uclass_platdata) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			goto fail_alloc2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">		size = parent-&gt;driver-&gt;per_child_platdata_auto_alloc_size;    </span><br><span class="line">		<span class="keyword">if</span> (!size) &#123;</span><br><span class="line">			size = parent-&gt;uclass-&gt;uc_drv-&gt;</span><br><span class="line">					per_child_platdata_auto_alloc_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (size) &#123;</span><br><span class="line">			dev-&gt;flags |= DM_FLAG_ALLOC_PARENT_PDATA;</span><br><span class="line">			dev-&gt;parent_platdata = calloc(1, size);</span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;parent_platdata) &#123;</span><br><span class="line">				ret = -ENOMEM;</span><br><span class="line">				goto fail_alloc3;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* put dev into parent‘s successor list */</span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		list_add_tail(&amp;dev-&gt;sibling_node, &amp;parent-&gt;child_head);  // 添加到父设备的子设备链表中</span><br><span class="line"></span><br><span class="line">	ret = uclass_bind_device(dev);  // uclass和udevice进行绑定，主要是实现了将udevice链接到uclass的设备链表中</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		goto fail_uclass_bind;</span><br><span class="line"></span><br><span class="line">	/* <span class="keyword">if</span> we fail to <span class="built_in">bind</span> we remove device from successors and free it */</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;<span class="built_in">bind</span>) &#123;</span><br><span class="line">		ret = drv-&gt;<span class="built_in">bind</span>(dev);    // 执行udevice对应driver的<span class="built_in">bind</span>函数</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail_bind;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (parent &amp;&amp; parent-&gt;driver-&gt;child_post_bind) &#123;</span><br><span class="line">		ret = parent-&gt;driver-&gt;child_post_bind(dev);   // 执行父设备的driver的child_post_bind函数</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail_child_post_bind;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (uc-&gt;uc_drv-&gt;post_bind) &#123;</span><br><span class="line">		ret = uc-&gt;uc_drv-&gt;post_bind(dev);  // 执行所属uclass的post_bind函数</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail_uclass_post_bind;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		pr_debug(<span class="string">&quot;Bound device %s to %s\n&quot;</span>, dev-&gt;name, parent-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (devp)</span><br><span class="line">		*devp = dev;    // 将udevice进行返回</span><br><span class="line"></span><br><span class="line">	dev-&gt;flags |= DM_FLAG_BOUND;         // 设置已经绑定的标志</span><br><span class="line">        // 后续可以通过dev-&gt;flags &amp; DM_FLAG_ACTIVATED或者device_active宏来判断设备是否已经被激活</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">fail_uclass_post_bind:</span><br><span class="line">	/* There is no child unbind() method, so no clean-up required */</span><br><span class="line">fail_child_post_bind:</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drv-&gt;unbind &amp;&amp; drv-&gt;unbind(dev)) &#123;</span><br><span class="line">			dm_warn(<span class="string">&quot;unbind() method failed on dev &#x27;%s&#x27; on error path\n&quot;</span>,</span><br><span class="line">				dev-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">fail_bind:</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (uclass_unbind_device(dev)) &#123;</span><br><span class="line">			dm_warn(<span class="string">&quot;Failed to unbind dev &#x27;%s&#x27; on error path\n&quot;</span>,</span><br><span class="line">				dev-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">fail_uclass_bind:</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) &#123;</span><br><span class="line">		list_del(&amp;dev-&gt;sibling_node);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;flags &amp; DM_FLAG_ALLOC_PARENT_PDATA) &#123;</span><br><span class="line">			free(dev-&gt;parent_platdata);</span><br><span class="line">			dev-&gt;parent_platdata = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">fail_alloc3:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; DM_FLAG_ALLOC_UCLASS_PDATA) &#123;</span><br><span class="line">		free(dev-&gt;uclass_platdata);</span><br><span class="line">		dev-&gt;uclass_platdata = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">fail_alloc2:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; DM_FLAG_ALLOC_PDATA) &#123;</span><br><span class="line">		free(dev-&gt;platdata);</span><br><span class="line">		dev-&gt;platdata = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">fail_alloc1:</span><br><span class="line">	devres_release_all(dev);</span><br><span class="line"></span><br><span class="line">	free(dev);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述就完成了dtb的解析，udevice和uclass的创建，以及各个组成部分的绑定关系。<br>注意，这里只是绑定，即调用了driver的bind函数，但是设备还没有真正激活，也就是还没有执行设备的probe函数。</p>
<h3 id="DM工作流程"><a href="#DM工作流程" class="headerlink" title="DM工作流程"></a>DM工作流程</h3><ol>
<li>device_probe<br>经过前面的DM初始化以及设备解析之后，我们只是建立了udevice和uclass之间的绑定关系。但是此时udevice还没有被probe，其对应设备还没有被激活。<br>激活一个设备主要是通过device_probe函数，所以在介绍DM的工作流程前，先说明device_probe函数。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int device_probe(struct udevice *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct power_domain pd;</span><br><span class="line">	const struct driver *drv;</span><br><span class="line">	int size = 0;</span><br><span class="line">	int ret;</span><br><span class="line">	int seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; DM_FLAG_ACTIVATED)  // 表示这个设备已经被激活了</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	drv = dev-&gt;driver;  // 获取这个设备对应的driver</span><br><span class="line">	assert(drv);</span><br><span class="line"></span><br><span class="line">	/* Allocate private data <span class="keyword">if</span> requested and not reentered */</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;priv_auto_alloc_size &amp;&amp; !dev-&gt;priv) &#123;</span><br><span class="line">		dev-&gt;priv = alloc_priv(drv-&gt;priv_auto_alloc_size, drv-&gt;flags);  // 为设备分配私有数据</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;priv) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			goto fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/* Allocate private data <span class="keyword">if</span> requested and not reentered */</span><br><span class="line">	size = dev-&gt;uclass-&gt;uc_drv-&gt;per_device_auto_alloc_size;  // 为设备所属uclass分配私有数据</span><br><span class="line">	<span class="keyword">if</span> (size &amp;&amp; !dev-&gt;uclass_priv) &#123;</span><br><span class="line">		dev-&gt;uclass_priv = alloc_priv(size,</span><br><span class="line">					      dev-&gt;uclass-&gt;uc_drv-&gt;flags);</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;uclass_priv) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			goto fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Ensure all parents are probed */</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent) &#123;</span><br><span class="line">		size = dev-&gt;parent-&gt;driver-&gt;per_child_auto_alloc_size;</span><br><span class="line">		<span class="keyword">if</span> (!size) &#123;</span><br><span class="line">			size = dev-&gt;parent-&gt;uclass-&gt;uc_drv-&gt;</span><br><span class="line">					per_child_auto_alloc_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (size &amp;&amp; !dev-&gt;parent_priv) &#123;</span><br><span class="line">			dev-&gt;parent_priv = alloc_priv(size, drv-&gt;flags);</span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;parent_priv) &#123;</span><br><span class="line">				ret = -ENOMEM;</span><br><span class="line">				goto fail;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = device_probe(dev-&gt;parent);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * The device might have already been probed during</span><br><span class="line">		 * the call to device_probe() on its parent device</span><br><span class="line">		 * (e.g. PCI bridge devices). Test the flags again</span><br><span class="line">		 * so that we don<span class="string">&#x27;t mess up the device.</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		if (dev-&gt;flags &amp; DM_FLAG_ACTIVATED)</span></span><br><span class="line"><span class="string">			return 0;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	seq = uclass_resolve_seq(dev);</span></span><br><span class="line"><span class="string">	if (seq &lt; 0) &#123;</span></span><br><span class="line"><span class="string">		ret = seq;</span></span><br><span class="line"><span class="string">		goto fail;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	dev-&gt;seq = seq;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	dev-&gt;flags |= DM_FLAG_ACTIVATED;  // 设置udevice的激活标志</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Process pinctrl for everything except the root device, and</span></span><br><span class="line"><span class="string">	 * continue regardless of the result of pinctrl. Don&#x27;</span>t process pinctrl</span><br><span class="line">	 * settings <span class="keyword">for</span> pinctrl devices since the device may not yet be</span><br><span class="line">	 * probed.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent &amp;&amp; device_get_uclass_id(dev) != UCLASS_PINCTRL)</span><br><span class="line">		pinctrl_select_state(dev, <span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(POWER_DOMAIN) &amp;&amp; dev-&gt;parent &amp;&amp;</span><br><span class="line">	    device_get_uclass_id(dev) != UCLASS_POWER_DOMAIN) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!power_domain_get(dev, &amp;pd))</span><br><span class="line">			power_domain_on(&amp;pd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = uclass_pre_probe_device(dev);  // uclass在probe device之前的一些函数的调用</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		goto fail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent &amp;&amp; dev-&gt;parent-&gt;driver-&gt;child_pre_probe) &#123;</span><br><span class="line">		ret = dev-&gt;parent-&gt;driver-&gt;child_pre_probe(dev);  // 调用driver中的ofdata_to_platdata将dts信息转化为设备的平台数据</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;ofdata_to_platdata &amp;&amp; dev_has_of_node(dev)) &#123;</span><br><span class="line">		ret = drv-&gt;ofdata_to_platdata(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Only handle devices that have a valid ofnode */</span><br><span class="line">	<span class="keyword">if</span> (dev_of_valid(dev)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Process <span class="string">&#x27;assigned-&#123;clocks/clock-parents/clock-rates&#125;&#x27;</span></span><br><span class="line">		 * properties</span><br><span class="line">		 */</span><br><span class="line">		ret = clk_set_defaults(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			goto fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;probe(dev);  // 调用driver的probe函数，到这里设备才真正激活了</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev-&gt;flags &amp;= ~DM_FLAG_ACTIVATED;</span><br><span class="line">			goto fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = uclass_post_probe_device(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		goto fail_uclass;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent &amp;&amp; device_get_uclass_id(dev) == UCLASS_PINCTRL)</span><br><span class="line">		pinctrl_select_state(dev, <span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">fail_uclass:</span><br><span class="line">	<span class="keyword">if</span> (device_remove(dev, DM_REMOVE_NORMAL)) &#123;</span><br><span class="line">		dm_warn(<span class="string">&quot;%s: Device &#x27;%s&#x27; failed to remove on error path\n&quot;</span>,</span><br><span class="line">			__func__, dev-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">fail:</span><br><span class="line">	dev-&gt;flags &amp;= ~DM_FLAG_ACTIVATED;</span><br><span class="line"></span><br><span class="line">	dev-&gt;seq = -1;</span><br><span class="line">	device_free(dev);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>分配设备的私有数据</li>
<li>对父设备进行probe</li>
<li>执行probe device之前uclass需要调用的一些函数</li>
<li>调用driver的ofdata_to_platdata，将dts信息转化为设备的平台数据</li>
<li>调用driver的probe函数</li>
<li>执行probe device之后uclass需要调用的一些函数</li>
</ul>
<ol start="2">
<li>通过uclass来获取一个udevice并且进行probe<br>通过uclass来获取一个udevice并且进行probe有如下接口 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int uclass_get_device(enum uclass_id id, int index, struct udevice **devp)  //通过索引从uclass的设备链表中获取udevice，并且进行probe</span><br><span class="line">int uclass_get_device_by_name(enum uclass_id id, const char *name,</span><br><span class="line">                  struct udevice **devp) //通过设备名从uclass的设备链表中获取udevice，并且进行probe</span><br><span class="line">int uclass_get_device_by_seq(enum uclass_id id, int seq, struct udevice **devp) //通过序号从uclass的设备链表中获取udevice，并且进行probe</span><br><span class="line">int uclass_get_device_by_of_offset(enum uclass_id id, int node,</span><br><span class="line">                   struct udevice **devp) //通过dts节点的偏移从uclass的设备链表中获取udevice，并且进行probe</span><br><span class="line">int uclass_get_device_by_phandle(enum uclass_id id, struct udevice *parent,</span><br><span class="line">                 const char *name, struct udevice **devp) //通过设备的“phandle”属性从uclass的设备链表中获取udevice，并且进行probe</span><br><span class="line">int uclass_first_device(enum uclass_id id, struct udevice **devp) //从uclass的设备链表中获取第一个udevice，并且进行probe</span><br><span class="line">int uclass_next_device(struct udevice **devp) //从uclass的设备链表中获取下一个udevice，并且进行probe</span><br></pre></td></tr></table></figure>
这些接口主要是获取设备的方法上有所区别，但是probe设备的方法都是一样的，都是通过调用uclass_get_device_tail-&gt;device_probe来probe设备的。<br>以uclass_get_device为例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int uclass_get_device(enum uclass_id id, int index, struct udevice **devp)</span><br><span class="line">&#123;</span><br><span class="line">    struct udevice *dev;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    *devp = NULL;</span><br><span class="line">    ret = uclass_find_device(id, index, &amp;dev); //通过索引从uclass的设备链表中获取对应的udevice</span><br><span class="line">    <span class="built_in">return</span> uclass_get_device_tail(dev, ret, devp); // 调用uclass_get_device_tail进行设备的get，最终会调用device_probe来对设备进行probe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int uclass_get_device_tail(struct udevice *dev, int ret,</span><br><span class="line">                  struct udevice **devp)</span><br><span class="line">&#123;</span><br><span class="line">    ret = device_probe(dev);</span><br><span class="line">// 调用device_probe对设备进行probe，这个函数在前面说明过了</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">    *devp = dev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
声明：本文较多参考<a href="https://blog.csdn.net/ooonebook/article/details/53234020">https://blog.csdn.net/ooonebook/article/details/53234020</a></li>
</ol>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-ledDriver</title>
    <url>/2018/08/31/u-boot-ledDriver/</url>
    <content><![CDATA[<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>gpio_led.c</strong><br>这里提供了一系列led操作的接口，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int gpio_led_gpio_value(led_id_t mask, int state);设置gpio值</span><br><span class="line">void __led_init(led_id_t mask, int state);初始化gpio</span><br><span class="line">void __led_set(led_id_t mask, int state);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>gpio_uclass.c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int gpio_to_device(unsigned int gpio, struct gpio_desc *desc);//将gpio num转化为device</span><br><span class="line">int dm_gpio_request(struct gpio_desc *desc, const char *label);//请求gpio device</span><br><span class="line">int gpio_request(unsigned gpio, const char *label);</span><br><span class="line">int gpio_free(unsigned gpio);//释放gpio device</span><br><span class="line">int gpio_direction_input(unsigned gpio);//设置gpio为输入模式</span><br><span class="line">int gpio_direction_output(unsigned gpio, int value);//设置gpio为输出模式</span><br><span class="line">int dm_gpio_get_value(const struct gpio_desc *desc);//获得gpio值</span><br><span class="line">int dm_gpio_set_value(const struct gpio_desc *desc, int value);//设置gpio值</span><br><span class="line">int dm_gpio_set_open_drain(struct gpio_desc *desc, int value);//设置开漏输出</span><br></pre></td></tr></table></figure>
<p><strong>post_probe</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);</span><br><span class="line"></span><br><span class="line">uc_priv-&gt;name = calloc(uc_priv-&gt;gpio_count, sizeof(char *));</span><br><span class="line"><span class="keyword">if</span> (!uc_priv-&gt;name)</span><br><span class="line">	<span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> gpio_renumber(NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>gpio_renumber</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* We need to renumber the GPIOs when any driver is probed/removed */</span><br><span class="line">static int gpio_renumber(struct udevice *removed_dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct gpio_dev_priv *uc_priv;</span><br><span class="line">	struct udevice *dev;</span><br><span class="line">	struct uclass *uc;</span><br><span class="line">	unsigned base;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = uclass_get(UCLASS_GPIO, &amp;uc);</span><br><span class="line">		struct uclass *uc;</span><br><span class="line">		*ucp = NULL;</span><br><span class="line">		uc = uclass_find(id);</span><br><span class="line">		<span class="keyword">if</span> (!uc) //如果没有设备则添加uclass放入链表中去,在下面会给其分配一个base地址</span><br><span class="line">			<span class="built_in">return</span> uclass_add(id, ucp);</span><br><span class="line">		*ucp = uc;</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">	/* Ensure that we have a base <span class="keyword">for</span> each bank */</span><br><span class="line">	base = 0;</span><br><span class="line">	uclass_foreach_dev(dev, uc) &#123;</span><br><span class="line">		<span class="keyword">if</span> (device_active(dev) &amp;&amp; dev != removed_dev) &#123;  //如果是removed_dev则不分配地址</span><br><span class="line">			uc_priv = dev_get_uclass_priv(dev);</span><br><span class="line">			uc_priv-&gt;gpio_base = base;</span><br><span class="line">			base += uc_priv-&gt;gpio_count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>post_probe主要完成创建uclass加入到链表中去<br><strong>gpio_post_bind</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int gpio_post_bind(struct udevice *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct udevice *child;</span><br><span class="line">	ofnode node;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_NEEDS_MANUAL_RELOC) //未定义，啥也不干</span></span><br><span class="line">	struct dm_gpio_ops *ops = (struct dm_gpio_ops *)device_get_ops(dev);</span><br><span class="line">	static int reloc_done;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!reloc_done) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;request)</span><br><span class="line">			ops-&gt;request += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;free)</span><br><span class="line">			ops-&gt;free += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;direction_input)</span><br><span class="line">			ops-&gt;direction_input += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;direction_output)</span><br><span class="line">			ops-&gt;direction_output += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;get_value)</span><br><span class="line">			ops-&gt;get_value += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;set_value)</span><br><span class="line">			ops-&gt;set_value += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;get_open_drain)</span><br><span class="line">			ops-&gt;get_open_drain += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;set_open_drain)</span><br><span class="line">			ops-&gt;set_open_drain += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;get_function)</span><br><span class="line">			ops-&gt;get_function += gd-&gt;reloc_off;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;xlate)</span><br><span class="line">			ops-&gt;xlate += gd-&gt;reloc_off;</span><br><span class="line"></span><br><span class="line">		reloc_done++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_GPIO_HOG)) &#123;</span><br><span class="line">		dev_for_each_subnode(node, dev) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ofnode_read_bool(node, <span class="string">&quot;gpio-hog&quot;</span>)) &#123;</span><br><span class="line">				const char *name = ofnode_get_name(node);</span><br><span class="line">				int ret;</span><br><span class="line"></span><br><span class="line">				ret = device_bind_driver_to_node(dev,</span><br><span class="line">								 <span class="string">&quot;gpio_hog&quot;</span>,</span><br><span class="line">								 name, node,</span><br><span class="line">								 &amp;child);</span><br><span class="line">				<span class="keyword">if</span> (ret)</span><br><span class="line">					<span class="built_in">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sunxi_gpio.c</strong><br>这个文件里是udevice的driver函数，是具体跟寄存器打交道的具体实现函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">U_BOOT_DRIVER(gpio_sunxi) = &#123;</span><br><span class="line">	.name	= <span class="string">&quot;gpio_sunxi&quot;</span>,</span><br><span class="line">	.id	= UCLASS_GPIO,</span><br><span class="line">	.ops	= &amp;gpio_sunxi_ops,</span><br><span class="line">	.of_match = sunxi_gpio_ids,</span><br><span class="line">	.<span class="built_in">bind</span>	= gpio_sunxi_bind,</span><br><span class="line">	.probe	= gpio_sunxi_probe,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">/* 具体实现接口 */</span><br><span class="line">static const struct dm_gpio_ops gpio_sunxi_ops = &#123;</span><br><span class="line">	.direction_input	= sunxi_gpio_direction_input,</span><br><span class="line">	.direction_output	= sunxi_gpio_direction_output,</span><br><span class="line">	.get_value		= sunxi_gpio_get_value,</span><br><span class="line">	.set_value		= sunxi_gpio_set_value,</span><br><span class="line">	.get_function		= sunxi_gpio_get_function,</span><br><span class="line">	.xlate			= sunxi_gpio_xlate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>bind</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int gpio_sunxi_bind(struct udevice *parent)</span><br><span class="line">&#123;</span><br><span class="line">	struct sunxi_gpio_soc_data *soc_data =</span><br><span class="line">		(struct sunxi_gpio_soc_data *)dev_get_driver_data(parent);</span><br><span class="line">	struct sunxi_gpio_platdata *plat = parent-&gt;platdata;</span><br><span class="line">	struct sunxi_gpio_reg *ctlr;</span><br><span class="line">	int bank, ret;</span><br><span class="line"></span><br><span class="line">	/* If this is a child device, there is nothing to <span class="keyword">do</span> here */</span><br><span class="line">	<span class="keyword">if</span> (plat)</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	ctlr = (struct sunxi_gpio_reg *)devfdt_get_addr(parent); //获取base地址</span><br><span class="line">	<span class="keyword">for</span> (bank = 0; bank &lt; soc_data-&gt;no_banks; bank++) &#123;</span><br><span class="line">		struct sunxi_gpio_platdata *plat;</span><br><span class="line">		struct udevice *dev;</span><br><span class="line"></span><br><span class="line">		plat = calloc(1, sizeof(*plat));</span><br><span class="line">		<span class="keyword">if</span> (!plat)</span><br><span class="line">			<span class="built_in">return</span> -ENOMEM;</span><br><span class="line">		plat-&gt;regs = &amp;ctlr-&gt;gpio_bank[bank];</span><br><span class="line">		plat-&gt;bank_name = gpio_bank_name(soc_data-&gt;start + bank);</span><br><span class="line">		plat-&gt;gpio_count = SUNXI_GPIOS_PER_BANK;</span><br><span class="line"></span><br><span class="line">		ret = device_bind(parent, parent-&gt;driver,</span><br><span class="line">					plat-&gt;bank_name, plat, -1, &amp;dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		dev_set_of_offset(dev, dev_of_offset(parent));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bind实现将udevice和uclass联系在一起。<br><strong>probe</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int gpio_sunxi_probe(struct udevice *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct sunxi_gpio_platdata *plat = dev_get_platdata(dev);</span><br><span class="line">	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);</span><br><span class="line"></span><br><span class="line">	/* Tell the uclass how many GPIOs we have */</span><br><span class="line">	<span class="keyword">if</span> (plat) &#123;</span><br><span class="line">		uc_priv-&gt;gpio_count = plat-&gt;gpio_count;</span><br><span class="line">		uc_priv-&gt;bank_name = plat-&gt;bank_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>initr_status_led</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#if defined(CONFIG_LED_STATUS)</span></span><br><span class="line">static int initr_status_led(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if defined(CONFIG_LED_STATUS_BOOT)</span></span><br><span class="line">	status_led_set(CONFIG_LED_STATUS_BOOT, CONFIG_LED_STATUS_BLINKING);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	status_led_init();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p><strong>status_led_set</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	led_id_t mask;</span><br><span class="line">	int state;</span><br><span class="line">	int period;</span><br><span class="line">	int cnt;</span><br><span class="line">&#125; led_dev_t;</span><br><span class="line"></span><br><span class="line">led_dev_t led_dev[] = &#123;</span><br><span class="line">	&#123;	CONFIG_LED_STATUS_BIT,</span><br><span class="line">		CONFIG_LED_STATUS_STATE,</span><br><span class="line">		LED_STATUS_PERIOD,</span><br><span class="line">		0,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">#if defined(CONFIG_LED_STATUS1)</span></span><br><span class="line">	&#123;	CONFIG_LED_STATUS_BIT1,</span><br><span class="line">		CONFIG_LED_STATUS_STATE1,</span><br><span class="line">		LED_STATUS_PERIOD1,</span><br><span class="line">		0,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_LED_STATUS2)</span></span><br><span class="line">	&#123;	CONFIG_LED_STATUS_BIT2,</span><br><span class="line">		CONFIG_LED_STATUS_STATE2,</span><br><span class="line">		LED_STATUS_PERIOD2,</span><br><span class="line">		0,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_LED_STATUS3)</span></span><br><span class="line">	&#123;	CONFIG_LED_STATUS_BIT3,</span><br><span class="line">		CONFIG_LED_STATUS_STATE3,</span><br><span class="line">		LED_STATUS_PERIOD3,</span><br><span class="line">		0,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_LED_STATUS4)</span></span><br><span class="line">	&#123;	CONFIG_LED_STATUS_BIT4,</span><br><span class="line">		CONFIG_LED_STATUS_STATE4,</span><br><span class="line">		LED_STATUS_PERIOD4,</span><br><span class="line">		0,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_LED_STATUS5)</span></span><br><span class="line">	&#123;	CONFIG_LED_STATUS_BIT5,</span><br><span class="line">		CONFIG_LED_STATUS_STATE5,</span><br><span class="line">		LED_STATUS_PERIOD5,</span><br><span class="line">		0,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#define MAX_LED_DEV	(sizeof(led_dev)/sizeof(led_dev_t))</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">void status_led_set (int led, int state)</span><br><span class="line">&#123;</span><br><span class="line">	led_dev_t *ld;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (led &lt; 0 || led &gt;= MAX_LED_DEV)</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!status_led_init_done)</span><br><span class="line">		status_led_init ();</span><br><span class="line"></span><br><span class="line">	ld = &amp;led_dev[led];</span><br><span class="line"></span><br><span class="line">	ld-&gt;state = state;</span><br><span class="line">	<span class="keyword">if</span> (state == CONFIG_LED_STATUS_BLINKING) &#123;</span><br><span class="line">		ld-&gt;cnt = 0;		/* always start with full period    */</span><br><span class="line">		state = CONFIG_LED_STATUS_ON;	/* always start with LED _ON_ */</span><br><span class="line">	&#125;</span><br><span class="line">	__led_set (ld-&gt;mask, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>status_led_init</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void status_led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	led_dev_t *ld;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = 0, ld = led_dev; i &lt; MAX_LED_DEV; i++, ld++)</span><br><span class="line">		__led_init (ld-&gt;mask, ld-&gt;state);</span><br><span class="line">	status_led_init_done = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__led_init</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void __led_init(led_id_t mask, int state)</span><br><span class="line">&#123;</span><br><span class="line">	int gpio_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gpio_request(mask, <span class="string">&quot;gpio_led&quot;</span>) != 0) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: failed requesting GPIO%lu!\n&quot;</span>, __func__, mask);</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_value = gpio_led_gpio_value(mask, state); //设置led value </span><br><span class="line">		int i, gpio_value = (state == CONFIG_LED_STATUS_ON);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(gpio_led_inv); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (gpio_led_inv[i] == mask)</span><br><span class="line">				gpio_value = !gpio_value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">return</span> gpio_value;</span><br><span class="line">	gpio_direction_output(mask, gpio_value); //设置gpio为输出模式且设置默认值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>gpio_request</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int gpio_request(unsigned gpio, const char *label)</span><br><span class="line">&#123;</span><br><span class="line">	struct gpio_desc desc;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = gpio_to_device(gpio, &amp;desc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> dm_gpio_request(&amp;desc, label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>gpio_to_device</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 获得gpio device PL4对应的gpio为 292 PL7对应的gpio为295 */</span><br><span class="line">static int gpio_to_device(unsigned int gpio, struct gpio_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">	struct gpio_dev_priv *uc_priv;</span><br><span class="line">	struct udevice *dev;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ret = uclass_first_device(UCLASS_GPIO, &amp;dev);</span><br><span class="line">	     dev;</span><br><span class="line">	     ret = uclass_next_device(&amp;dev)) &#123;</span><br><span class="line">		uc_priv = dev_get_uclass_priv(dev);</span><br><span class="line">		<span class="keyword">if</span> (gpio &gt;= uc_priv-&gt;gpio_base &amp;&amp;</span><br><span class="line">		    gpio &lt; uc_priv-&gt;gpio_base + uc_priv-&gt;gpio_count) &#123;</span><br><span class="line">			desc-&gt;dev = dev;</span><br><span class="line">			desc-&gt;offset = gpio - uc_priv-&gt;gpio_base;</span><br><span class="line">			desc-&gt;flags = 0;</span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* No such GPIO */</span><br><span class="line">	<span class="built_in">return</span> ret ? ret : -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dm_gpio_request</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int dm_gpio_request(struct gpio_desc *desc, const char *label)</span><br><span class="line">&#123;</span><br><span class="line">	struct udevice *dev = desc-&gt;dev;</span><br><span class="line">	struct gpio_dev_priv *uc_priv;</span><br><span class="line">	char *str;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	uc_priv = dev_get_uclass_priv(dev);</span><br><span class="line">	<span class="keyword">if</span> (uc_priv-&gt;name[desc-&gt;offset]) //设备被占用，繁忙</span><br><span class="line">		<span class="built_in">return</span> -EBUSY;</span><br><span class="line">	str = strdup(label);</span><br><span class="line">	<span class="keyword">if</span> (!str)</span><br><span class="line">		<span class="built_in">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (gpio_get_ops(dev)-&gt;request) &#123; //没定义，不执行</span><br><span class="line">		ret = gpio_get_ops(dev)-&gt;request(dev, desc-&gt;offset, label);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			free(str);</span><br><span class="line">			<span class="built_in">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	uc_priv-&gt;name[desc-&gt;offset] = str; //设置name，表示设备正在被使用</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回来看看gpio_direction_output这个函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int gpio_direction_output(unsigned gpio, int value)</span><br><span class="line">&#123;</span><br><span class="line">	struct gpio_desc desc;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = gpio_to_device(gpio, &amp;desc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	ret = check_reserved(&amp;desc, <span class="string">&quot;dir_output&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> gpio_get_ops(desc.dev)-&gt;direction_output(desc.dev,</span><br><span class="line">							desc.offset, value); //调用sunxi_gpio里的sunxi_gpio_direction_output函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>unxi_gpio_direction_output</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int sunxi_gpio_direction_output(struct udevice *dev, unsigned offset,</span><br><span class="line">				       int value)</span><br><span class="line">&#123;</span><br><span class="line">	struct sunxi_gpio_platdata *plat = dev_get_platdata(dev);</span><br><span class="line">	u32 num = GPIO_NUM(offset); //偏移，相当于PL4和PL7相对于PL0的偏移</span><br><span class="line"></span><br><span class="line">	sunxi_gpio_set_cfgbank(plat-&gt;regs, offset, SUNXI_GPIO_OUTPUT);</span><br><span class="line">		u32 index = GPIO_CFG_INDEX(bank_offset);</span><br><span class="line">		u32 offset = GPIO_CFG_OFFSET(bank_offset);</span><br><span class="line"></span><br><span class="line">		clrsetbits_le32(&amp;pio-&gt;cfg[0] + index, 0xf &lt;&lt; <span class="string">offset, val &lt;&lt; offset</span>); //设置cfg寄存器的值</span><br><span class="line">	clrsetbits_le32(&amp;plat-&gt;regs-&gt;dat, 1 &lt;&lt; <span class="string">num, value ? (1 &lt;&lt; num</span>) : 0); //设置dat寄存器的值</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而__led_set最终调用sunxi_gpio_set_value实现对dat寄存器的赋值，到此就完成了对led的初始化。</p>
<h3 id="不使用框架"><a href="#不使用框架" class="headerlink" title="不使用框架"></a>不使用框架</h3><p><strong>ASM</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldr x0,=0x07202000</span><br><span class="line"> ldr x1,[x0]</span><br><span class="line"> bic x1,x1,<span class="comment">#0x70000</span></span><br><span class="line"> orr x1,x1,<span class="comment">#0x10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ldr x0,=0x07022010</span><br><span class="line"> ldr x1,[x0]</span><br><span class="line"> orr x1,x1,0x10</span><br><span class="line"> str x1,[x0]</span><br></pre></td></tr></table></figure>
<p><strong>c</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;leds.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;common.h&gt;</span></span><br><span class="line">/*定义LED控制寄存器和数据寄存器地址*/</span><br><span class="line">unsigned int *LED_CONFIG = (unsigned int*)0x07022000;</span><br><span class="line">unsigned int *LED_DATA = (unsigned int*)0x07022010;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*LED初始化函数*/</span><br><span class="line">int Led_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*PL4,PL7寄存器配置为输出模式*/</span><br><span class="line">    *LED_CONFIG &amp;= (0x8&lt;&lt;<span class="string">16);</span></span><br><span class="line"><span class="string">    *LED_CONFIG &amp;= (0x8&lt;&lt;28);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    *LED_CONFIG |= (0x1&lt;&lt;16</span>);</span><br><span class="line">    *LED_CONFIG |= (0X1&lt;&lt;<span class="string">28);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*默认开启PER_LED*/</span></span><br><span class="line"><span class="string">    *LED_DATA |= 0X10;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>gpio led driver</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-parseuImage</title>
    <url>/2018/09/01/u-boot-parseuImage/</url>
    <content><![CDATA[<h3 id="FIT-uImage"><a href="#FIT-uImage" class="headerlink" title="FIT-uImage"></a>FIT-uImage</h3><p>flattened image tree，类似于FDT(flattened device tree)的一种实现机制。其通过一定语法和格式将一些需要使用到的镜像（例如kernel、dtb以及文件系统）组合到一起生成一个image文件。<br>而kernel镜像也是作为FIT的configure中的一个节点，其信息则是以节点中的属性来进行描述的。<br>而uboot的工作，就是要从FIT中提取相应的kernel节点，在节点中获取相应的属性，从而得到kernel的信息。其方式和FDT相当类似。 </p>
<p><strong>bootm_find_os</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,</span><br><span class="line">			 char * const argv[])</span><br><span class="line">&#123;</span><br><span class="line">	const void *os_hdr;</span><br><span class="line">	bool ep_found = <span class="literal">false</span>;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/* get kernel image header, start address and length */</span><br><span class="line">	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,</span><br><span class="line">			&amp;images, &amp;images.os.image_start, &amp;images.os.image_len);</span><br><span class="line">	<span class="keyword">if</span> (images.os.image_len == 0) &#123;</span><br><span class="line">		puts(<span class="string">&quot;ERROR: can&#x27;t get kernel image!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 通过调用boot_get_kernel，来获取itb（FIT-uImage）的头部指针，存储在os_hdr中</span><br><span class="line">    // 以images.os.image_start和images.os.image_len为其参数，在boot_get_kernel中会自动设置其值</span><br><span class="line">    // 同时，在boot_get_kernel中会设置images关于itb中kernel节点的信息fit_hdr_os、fit_uname_os和fit_noffset_os</span><br><span class="line"></span><br><span class="line">	/* get image parameters */</span><br><span class="line">	switch (genimg_get_format(os_hdr)) &#123;</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_LEGACY:</span><br><span class="line">		images.os.type = image_get_type(os_hdr);</span><br><span class="line">		images.os.comp = image_get_comp(os_hdr);</span><br><span class="line">		images.os.os = image_get_os(os_hdr);</span><br><span class="line"></span><br><span class="line">		images.os.end = image_get_image_end(os_hdr);</span><br><span class="line">		images.os.load = image_get_load(os_hdr);</span><br><span class="line">		images.os.arch = image_get_arch(os_hdr);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if IMAGE_ENABLE_FIT</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_FIT:</span><br><span class="line">		// 调用fit_image_get_type从itb的kerne节点中解析出“<span class="built_in">type</span>”属性，存储在images.os.type中。</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_type(images.fit_hdr_os,</span><br><span class="line">				       images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.type)) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Can&#x27;t get image type!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_TYPE);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 调用fit_image_get_comp从itb的kerne节点中解析出“comp”属性，存储在images.os.comp中。</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_comp(images.fit_hdr_os,</span><br><span class="line">				       images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.comp)) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Can&#x27;t get image compression!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_COMPRESSION);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"> 		// 调用fit_image_get_os从itb的kerne节点中解析出“os”属性，存储在images.os.os中。</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_os(images.fit_hdr_os, images.fit_noffset_os,</span><br><span class="line">				     &amp;images.os.os)) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Can&#x27;t get image OS!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_OS);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		 // 调用fit_image_get_arch从itb的kerne节点中解析出“arch”属性，存储在images.os.arch中。</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_arch(images.fit_hdr_os,</span><br><span class="line">				       images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.arch)) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Can&#x27;t get image ARCH!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		images.os.end = fit_get_end(images.fit_hdr_os);</span><br><span class="line"></span><br><span class="line">		 // 调用fit_image_get_load从itb的kerne节点中解析出“load”属性，存储在images.os.load中。</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_load(images.fit_hdr_os, images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.load)) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Can&#x27;t get image load address!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_LOADADDR);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_ANDROID_BOOT_IMAGE</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_ANDROID:</span><br><span class="line">		images.os.type = IH_TYPE_KERNEL;</span><br><span class="line">		images.os.comp = android_image_get_kcomp(os_hdr);</span><br><span class="line">		images.os.os = IH_OS_LINUX;</span><br><span class="line"></span><br><span class="line">		images.os.end = android_image_get_end(os_hdr);</span><br><span class="line">		images.os.load = android_image_get_kload(os_hdr);</span><br><span class="line">		images.ep = images.os.load;</span><br><span class="line">		ep_found = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	default:</span><br><span class="line">		puts(<span class="string">&quot;ERROR: unknown image format type!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* If we have a valid setup.bin, we will use that <span class="keyword">for</span> entry (x86) */</span><br><span class="line">	<span class="keyword">if</span> (images.os.arch == IH_ARCH_I386 ||</span><br><span class="line">	    images.os.arch == IH_ARCH_X86_64) &#123;</span><br><span class="line">		ulong len;</span><br><span class="line"></span><br><span class="line">		ret = boot_get_setup(&amp;images, IH_ARCH_I386, &amp;images.ep, &amp;len);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; 0 &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Could not find a valid setup.bin for x86\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Kernel entry point is the setup.bin */</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images.legacy_hdr_valid) &#123;</span><br><span class="line">		images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy);</span><br><span class="line"><span class="comment">#if IMAGE_ENABLE_FIT</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images.fit_uname_os) &#123;</span><br><span class="line">		int ret;</span><br><span class="line">		// 调用fit_image_get_entry从itb的kerne节点中解析出“ep”属性，存储在images.os.ep中。</span><br><span class="line">		ret = fit_image_get_entry(images.fit_hdr_os,</span><br><span class="line">					  images.fit_noffset_os, &amp;images.ep);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			puts(<span class="string">&quot;Can&#x27;t get entry point property!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ep_found) &#123;</span><br><span class="line">		puts(<span class="string">&quot;Could not find kernel entry point!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (images.os.type == IH_TYPE_KERNEL_NOLOAD) &#123;</span><br><span class="line">		<span class="keyword">if</span> (CONFIG_IS_ENABLED(CMD_BOOTI) &amp;&amp;</span><br><span class="line">		    images.os.arch == IH_ARCH_ARM64) &#123;</span><br><span class="line">			ulong image_addr;</span><br><span class="line">			ulong image_size;</span><br><span class="line"></span><br><span class="line">			ret = booti_setup(images.os.image_start, &amp;image_addr,</span><br><span class="line">					  &amp;image_size, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret != 0)</span><br><span class="line">				<span class="built_in">return</span> 1;</span><br><span class="line"></span><br><span class="line">			images.os.type = IH_TYPE_KERNEL;</span><br><span class="line">			images.os.load = image_addr;</span><br><span class="line">			images.ep = image_addr;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			images.os.load = images.os.image_start;</span><br><span class="line">			images.ep += images.os.image_start;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	images.os.start = map_to_sysmem(os_hdr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码就完成了bootm_headers_t images中的image_info_t os和ulong ep的成员的实现。<br>而这里的代码的核心是boot_get_kernel，会实现uImage的类型的判断、和FIT-uImage的头部节点信息的设置，并且将FIT-uImage的kernel的节点信息和bootm_headers进行关联。</p>
<p><strong>boot_get_kernel</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * boot_get_kernel - find kernel image</span><br><span class="line"> * @os_data: pointer to a ulong variable, will hold os data start address</span><br><span class="line"> * @os_len: pointer to a ulong variable, will hold os data length</span><br><span class="line"> *</span><br><span class="line"> * boot_get_kernel() tries to find a kernel image, verifies its integrity</span><br><span class="line"> * and locates kernel data.</span><br><span class="line"> *</span><br><span class="line"> * returns:</span><br><span class="line"> *     pointer to image header <span class="keyword">if</span> valid image was found, plus kernel start</span><br><span class="line"> *     address and length, otherwise NULL</span><br><span class="line"> */</span><br><span class="line">static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,</span><br><span class="line">				   char * const argv[], bootm_headers_t *images,</span><br><span class="line">				   ulong *os_data, ulong *os_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)</span></span><br><span class="line">	image_header_t	*hdr;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	ulong		img_addr;</span><br><span class="line">	const void *buf;</span><br><span class="line">	const char	*fit_uname_config = NULL;</span><br><span class="line">	const char	*fit_uname_kernel = NULL;</span><br><span class="line"><span class="comment">#if IMAGE_ENABLE_FIT</span></span><br><span class="line">	int		os_noffset;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	img_addr = genimg_get_kernel_addr_fit(argc &lt; 1 ? NULL : argv[0],</span><br><span class="line">					      &amp;fit_uname_config,</span><br><span class="line">					      &amp;fit_uname_kernel);</span><br><span class="line"></span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);</span><br><span class="line"></span><br><span class="line">	/* check image <span class="built_in">type</span>, <span class="keyword">for</span> FIT images get FIT kernel node */</span><br><span class="line">	*os_data = *os_len = 0;</span><br><span class="line">	buf = map_sysmem(img_addr, 0); //没有启用MMU，没有变化</span><br><span class="line">	switch (genimg_get_format(buf)) &#123; //判断FIT-uImage类型</span><br><span class="line"><span class="comment">#if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_LEGACY:  //Legacy-uImage</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;## Booting kernel from Legacy Image at %08lx ...\n&quot;</span>,</span><br><span class="line">		       img_addr);</span><br><span class="line">		hdr = image_get_kernel(img_addr, images-&gt;verify);</span><br><span class="line">		<span class="keyword">if</span> (!hdr)</span><br><span class="line">			<span class="built_in">return</span> NULL;</span><br><span class="line">		bootstage_mark(BOOTSTAGE_ID_CHECK_IMAGETYPE);</span><br><span class="line"></span><br><span class="line">		/* get os_data and os_len */</span><br><span class="line">		switch (image_get_type(hdr)) &#123;</span><br><span class="line">		<span class="keyword">case</span> IH_TYPE_KERNEL:</span><br><span class="line">		<span class="keyword">case</span> IH_TYPE_KERNEL_NOLOAD:</span><br><span class="line">			*os_data = image_get_data(hdr);</span><br><span class="line">			*os_len = image_get_data_size(hdr);</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IH_TYPE_MULTI:</span><br><span class="line">			image_multi_getimg(hdr, 0, os_data, os_len);</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IH_TYPE_STANDALONE:</span><br><span class="line">			*os_data = image_get_data(hdr);</span><br><span class="line">			*os_len = image_get_data_size(hdr);</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		default:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Wrong Image Type for %s command\n&quot;</span>,</span><br><span class="line">			       cmdtp-&gt;name);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_CHECK_IMAGETYPE);</span><br><span class="line">			<span class="built_in">return</span> NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * copy image header to allow <span class="keyword">for</span> image overwrites during</span><br><span class="line">		 * kernel decompression.</span><br><span class="line">		 */</span><br><span class="line">		memmove(&amp;images-&gt;legacy_hdr_os_copy, hdr,</span><br><span class="line">			sizeof(image_header_t));</span><br><span class="line"></span><br><span class="line">		/* save pointer to image header */</span><br><span class="line">		images-&gt;legacy_hdr_os = hdr;</span><br><span class="line"></span><br><span class="line">		images-&gt;legacy_hdr_valid = 1;</span><br><span class="line">		bootstage_mark(BOOTSTAGE_ID_DECOMP_IMAGE);</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if IMAGE_ENABLE_FIT</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_FIT:</span><br><span class="line">		os_noffset = fit_image_load(images, img_addr,</span><br><span class="line">				&amp;fit_uname_kernel, &amp;fit_uname_config,</span><br><span class="line">				IH_ARCH_DEFAULT, IH_TYPE_KERNEL,</span><br><span class="line">				BOOTSTAGE_ID_FIT_KERNEL_START,</span><br><span class="line">				FIT_LOAD_IGNORED, os_data, os_len);</span><br><span class="line">		        // 在fit_image_load中会去查找IH_TYPE_KERNEL指定的节点</span><br><span class="line">                // 设置到os_data和os_len中，也就是images.os.image_start和images.os.image_len中</span><br><span class="line">		<span class="keyword">if</span> (os_noffset &lt; 0)</span><br><span class="line">			<span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">		// 设置 itb的头部，对应就是FIT-uImage的起始地址</span><br><span class="line">		images-&gt;fit_hdr_os = map_sysmem(img_addr, 0);</span><br><span class="line">		// 设置kernel节点的名称</span><br><span class="line">		images-&gt;fit_uname_os = fit_uname_kernel;</span><br><span class="line">		// 设置configuration节点名称</span><br><span class="line">		images-&gt;fit_uname_cfg = fit_uname_config;</span><br><span class="line">		// 设置kernel节点的节点偏移，直接代表了kernel节点</span><br><span class="line">		images-&gt;fit_noffset_os = os_noffset;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_ANDROID_BOOT_IMAGE</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_ANDROID:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;## Booting Android Image at 0x%08lx ...\n&quot;</span>, img_addr);</span><br><span class="line">		<span class="keyword">if</span> (android_image_get_kernel(buf, images-&gt;verify,</span><br><span class="line">					     os_data, os_len))</span><br><span class="line">			<span class="built_in">return</span> NULL;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	default:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Wrong Image Format for %s command\n&quot;</span>, cmdtp-&gt;name);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);</span><br><span class="line">		<span class="built_in">return</span> NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;   kernel data at 0x%08lx, len = 0x%08lx (%ld)\n&quot;</span>,</span><br><span class="line">	      *os_data, *os_len, *os_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，就得到了itb的地址和itb（FIT-uImage）中kernel的节点偏移，类似于fdt的操作，后续就可以通过这两个itb的地址和itb（FIT-uImage）中kernel的节点偏移来获得kernel节点的属性</p>
<h3 id="Legacy-uImage"><a href="#Legacy-uImage" class="headerlink" title="Legacy-uImage"></a>Legacy-uImage</h3><p>Legacy-uImage的解析流程与FIT-uImage类似，只是解析的内容不同，代码流程都是上面这些，只是在代码中会判断是FIT-uImage还是Legacy-uImage来决定解析代码分支。</p>
<p>声明：本文参考<a href="https://blog.csdn.net/ooonebook/article/details/53544658">https://blog.csdn.net/ooonebook/article/details/53544658</a></p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>uImage</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-prepare</title>
    <url>/2018/08/26/u-boot-prepare/</url>
    <content><![CDATA[<h2 id="arm-linux-gcc选项"><a href="#arm-linux-gcc选项" class="headerlink" title="arm-linux-gcc选项"></a>arm-linux-gcc选项</h2><h3 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h3><ul>
<li>-c<br>预处理、编译、和汇编源文件，但是不连接</li>
<li>-S<br>编译后停止，不进行汇编</li>
<li>-E<br>预处理后停止，不编译</li>
<li>-o file<br>指定输出文件名为file</li>
<li>-v<br>显示gcc工具自身的配置命令，显示编译器版本号</li>
</ul>
<h3 id="警告选项"><a href="#警告选项" class="headerlink" title="警告选项"></a>警告选项</h3><ul>
<li>-Wall<br>打开所有警告信息，eg: gcc -Wall main.c</li>
</ul>
<h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><ul>
<li>-g<br>产生调试信息</li>
</ul>
<h3 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h3><ul>
<li>-o<br>优化选项 eg： gcc -o2 main.c</li>
</ul>
<h3 id="连接选项"><a href="#连接选项" class="headerlink" title="连接选项"></a>连接选项</h3><ul>
<li>-llibrary<br>链接名为library的库文件，实际库文件名为library.a -L选项指定库文件路径</li>
<li>-nostartfiles<br>不链接系统标准启动文件，而标准库文件仍正常使用</li>
<li>-nostdlib<br>不链接系统标准启动文件和标准库文件，用于编译内核和bootloader程序</li>
<li>-static<br>阻止链接共享库，在不使用 -static的文件时程序执行前要链接共享库，需要将共享库放入文件系统中</li>
<li>-shared<br>生成共享OBJ文件</li>
<li>-Xlinker option<br>把选项option传递给连接器 eg: -Xlinker -assert -Xlinker definitions</li>
<li>-Wl, option<br>把选项option传递给连接器</li>
</ul>
<h3 id="目录选项"><a href="#目录选项" class="headerlink" title="目录选项"></a>目录选项</h3><ul>
<li>-Idir<br>在头文件的指定搜索目录中添加dir目录</li>
</ul>
<h2 id="arm-linux-ld选项"><a href="#arm-linux-ld选项" class="headerlink" title="arm-linux-ld选项"></a>arm-linux-ld选项</h2><ul>
<li>-Tbss ADDRESS bss段的链接地址</li>
<li>-Ttext ADDRESS 代码段</li>
<li>-Tdata ADDRESS 数据段</li>
<li>-Tfile 指定一个链接器脚本文件，指示编译器按照脚本进行链接</li>
<li>-T选项一般用于bootloader、内核等没有底层软件支持的链接 </li>
</ul>
<h3 id="arm-linux-objcopy"><a href="#arm-linux-objcopy" class="headerlink" title="arm-linux-objcopy"></a>arm-linux-objcopy</h3><p>用来复制一个目标文件的内容到另一个文件中，进行格式转换</p>
<ul>
<li>-I bfdname or –input-target=bfdname<br>指定源文件格式，如果未指定arm-linux-objcopy会自己分析</li>
<li>-O bfdname or –output-target=bfdname<br>用指定格式来输出文件</li>
<li>-F bfdname or –target=bfdname<br>同时指明源文件和目标文件格式，即不做文件格式转换</li>
<li>-R sectionname or –remove-section=sectionname<br>从输出文件中删除sectionname段</li>
<li>-S or –strip-all<br>不从源文件中复制从定向信息和符号到目标文件中去</li>
<li>-g or –strip-debug<br>不从源文件中复制调试信息到目标文件中去<br>eg:在编译bootloader和内核时将elf文件转化为binary文件<br>  arm-linux-objcopy -O binary -S elf_file bin_file</li>
</ul>
<h3 id="arm-linux-objdump-选项"><a href="#arm-linux-objdump-选项" class="headerlink" title="arm-linux-objdump 选项"></a>arm-linux-objdump 选项</h3><ul>
<li>-b bfdname指定目标码格式</li>
<li>—disassemble或者-d反汇编可执行段</li>
<li>—dissassemble-all或者-D反汇编所有段</li>
<li>-EB,-EL指定字节序</li>
<li>—file-headers或者-f显示文件的整体头部摘要信息</li>
<li>—section-headers,–headers或者-h显示目标文件中各个段的头部摘要信息</li>
<li>—info或者-I显示支持的目标文件格式和CPU架构</li>
<li>—section=name或者-j name显示指定section的信息</li>
<li>—architecture=machine或者-m machine指定反汇编目标文件时使用的架构<br>eg： Arm-linux-objdump –D elf_file &gt; dis_file //将elf格式文件反汇编<br>  Arm -linux-objdump –D –b binary –m arm bin_file &gt; dis_file //将binary文件反汇编    </li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p><strong>立即变量(:=)</strong> 覆盖之前的值<br>x := foo<br>y := $(x)b<br>x := new<br>结果<br>x =&gt; new<br>y =&gt; foob</p>
<p><strong>递归赋值(=)</strong> 变量是整个文件最后赋值的值<br>x = foo<br>y = $(x)b<br>x = new<br>结果<br>x =&gt; new<br>y =&gt; newb</p>
<p><strong>条件赋值(?=)</strong> 是如果没有被赋值过就赋予等号后面的值<br>x := foo<br>y := $(x)b<br>x ?= new<br>结果<br>x =&gt; foo<br>y =&gt;foob</p>
<p><strong>追加赋值(+=)</strong> 在原变量之后加一个新值<br>x := foo<br>y := $(x)b<br>x += $(y)<br>结果<br>x =&gt;foo foob<br>y =&gt;foob</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>$(subst FROM,TO,TEXT)</strong><br>函数名称：字符串替换函数<br>函数功能：把字符串TEXT中的FROM字符串替换为TO<br>返回值：替换后的新字符串<br>$(subst ee,EE,feet on the stree) //替换“feet on the street“中的ee为EE。结果得到字符串”fEEt on the strEEt”</p>
<p><strong>$(patsubst PATTERN,REPLACEMENT,TEXT)</strong><br>函数名称：模式替换函数<br>函数功能：搜索TEXT中以空格分开的单词，将符合模式PATTERN替换为REPLACEMENT。参数PATTERN中可以用模式通配符%来表示一个单词中的诺干字符。如果参数REPLACEMENT中也包含一个%，那么REPLACEMENT中的”%”将使PATTERN中的那个”%”所代表的字符串。而且只有第一个%作为模式字符来处理，之后出现的不再作为模式字符（作为一个字符）。转义字符可以避免%不作为为模式字符<br>返回值：替换后的新字符串<br>函数说明：参数TEXT单词之间的多个空格在处理时被合并为一个空格，并忽略前导和结尾空格<br>$(patsubst %.c,%.o,xcc bar.c)<br>替换以.o结尾的字符，函数的返回结果就为”xco bar.o”</p>
<p><strong>$(strip STRING)</strong><br>函数名称：去空格函数<br>函数功能：去掉字符串STRING开头和结尾的空格，并将其中多个连续空字符合并为一个空字符<br>返回值：无前导和结尾空字符，使用单一空格分隔的多个单词的字符串<br>Strip函数常用语条件判断语句的表达式中，确保表达式比较可靠和健壮</p>
<p><strong>$(findstring FIND,IN)</strong><br>函数名称：查找字符串函数<br>函数功能：在字符串IN中查找FIND字符串<br>返回值：如果在IN中找到FIND子字符串，则返回FIND，否则返回空<br>函数说明：收索是严格的文本匹配<br>$(findstring a,abc) 返回 a<br>$(findstring a,bc) 返回空字符</p>
<p><strong>$(filter PATTERN…,TEXT)</strong><br>函数名称:过滤函数<br>函数功能：过滤掉字符串TEXT中所有不符合模式PATTERN的单词，保留所有符合此模式的单词。模式中一般需要包含字符%，存在多个模式时，模式之间用空格分隔<br>返回值：空格分隔的TEXT字符串中所有符合模式PATTERN的字符串<br>函数说明：filter可以用来去除一个变量中的某些字符串。<br>source := foo.c bar.c baz.s ugh.h<br>foo: $(source)<br>cc $(filter %.c %s,$(source)) -o foo 此句话等于cc foo.c bar.c baz.s -o foo 剔除掉了不符合.c,.s 的文件</p>
<p><strong>$(filter-out PATTERN…,TEXT)</strong><br>函数名称：反过滤函数<br>函数功能：和filter相反，剔除掉TEXT中所有符合模式PATTERN的单词<br>返回值：空格分隔的所有不符合模式PATTERN的字符串<br>objects = main1.o foo.o main2.o bar.o<br>mains = main1.o main2.o<br>$(filter-out $(mains),$(objects)) 去除了变量object中mains定义的字符串（文件名）的功能，返回”foo.o bar.o”</p>
<p><strong>$(sort LIST)</strong><br>函数名称：排序<br>函数功能：给字符串LIST中的单词以首字母为主进行排序，并去掉重复的单词<br>返回值：空格分隔的没有重复单词的字符串<br>$(sort foo bar lose foo)<br>返回值为”bar foo lose” 升序排，去掉重复单词</p>
<p><strong>$(word N,TEXT)</strong><br>函数名称：取单词函数<br>函数功能：取字符串TEXT中第N个单词(N的值从1开始)<br>返回值：返回字符串TEXT中第N个单词<br>函数说明：N大雨字符串TEXT中单词数目，返回空字符串。如果N为0，出错！！<br>$(word 2,foo bar baz) 返回bar</p>
<p><strong>$(wordlist S,E,TEXT)</strong><br>函数名称：取字符串函数<br>函数功能：从字符串TEXT中去除从S开始到E打单词串。S和E表示单词在字符串中位置的数字<br>返回值：TEXT中从第S到E的单词串<br>函数说明：“S”和“E”都是从1开始的数字。当“S”比“TEXT”中的字数大时，返回空。如果“E”大于“TEXT”字数，返回从“S”开始，到“TEXT”结束的单词串。如果“S”大于“E”，返回空。<br>$(wordlist 2,3,foo bar baz) 返回”bar baz”</p>
<p><strong>$(words TEXT)</strong><br>统计TEXT字符串的单词个数，返回值即为单词个数<br>$(words,foo bar) 返回值为2.字符串TEXT最后一个单词就是$(word $(words TEXT),TEXT)</p>
<p><strong>$(firstword NAMES…)</strong><br>函数名称：取首单词函数<br>功能：取字符串“NAMES…“的第一个单词<br>返回值：返回NAMES的第一个单词<br>$(firstword foo bar)<br>返回值为foo。Firstword的实现功能等同于$(word 1,NAMES…)</p>
<h3 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h3><p><strong>$(dir)</strong><br>名称：取目录函数——dir。<br>功能：从文件名序列中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。<br>返回：返回文件名序列的目录部分。<br>示例： $(dir src/foo.c hacks)返回值是“src/ ./”。</p>
<p><strong>$(notdir)</strong><br>名称：取文件函数——notdir。<br>功能：从文件名序列中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。<br>返回：返回文件名序列的非目录部分。<br>示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。</p>
<p><strong>$(suffix)</strong><br>名称：取后缀函数——suffix。<br>功能：从文件名序列中取出各个文件名的后缀。<br>返回：返回文件名序列的后缀序列，如果文件没有后缀，则返回空字串。<br>示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p>
<p><strong>$(basename)</strong><br>名称：取前缀函数——basename。<br>功能：从文件名序列中取出各个文件名的前缀部分。<br>返回：返回文件名序列的前缀序列，如果文件没有前缀，则返回空字串。<br>示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。</p>
<p><strong>$(addsuffix,)</strong><br>名称：加后缀函数——addsuffix。<br>功能：把后缀加到中的每个单词后面。返回：返回加过后缀的文件名序列。<br>示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。</p>
<p><strong>$(addprefix,)</strong><br>名称：加前缀函数——addprefix。<br>功能：把前缀加到中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。</p>
<p><strong>$(join,)</strong><br>名称：连接函数——join。<br>功能：把中的单词对应地加到的单词后面。如果的单词个数要比的多，那么，中的多出来的单词将保持原样。如果的单词个数要比多，那么，多出来的单词将被复制到中。<br>返回：返回连接过后的字符串。<br>示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p><strong>$(foreach var,list,text )</strong><br>把参数list中的单词逐一取出放到参数var所指定的变量中，<br>然后再执行text所包含的表达式。每一次text会返回一个字符串，循环过程中，<br>text的所返回的每个字符串会以空格分隔<br>eg: names := a b c d<br>    files := $(foreach n,$(names),$(n).o)<br>$(files)的值是“a.o b.o c.o d.o”。<br><strong>$(if condition,then-part ) or $(if condition,then-part,else-part )</strong></p>
<p>condition参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就<br>相当于返回真，于是，then-part会被计算，否则else-part会被计算。<br>如果condition为真（非空字符串），那个then-part会是整 个函数的返回值</p>
<p><strong>$(origin variable )</strong><br>查询变量的名字</p>
<p><strong>$(shell command arguments)</strong><br>shell是Makefile与外部通讯工具，与在shell中执行结果相似<br>eg：当前目录下有foo.c bar.c foo.h bar.h<br>src := $(shell ls *.c)<br>结果位foo.c bar.c</p>
<h3 id="Makefile中几个符号"><a href="#Makefile中几个符号" class="headerlink" title="Makefile中几个符号"></a>Makefile中几个符号</h3><p>$@ 表示目标文件<br>$^ 表示所有的依赖文件<br>$&lt; 表示第一个依赖文件<br>$? 表示比目标还要新的依赖文件列表<br>$+ 这个变量很像“$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标<br>$* 这个变量表示目标模式中“%”及其之前的部分。如果目标是“dir/a.foo.b”，并且目标的模式是“a.%.b”，那么，“$*”的值就是“dir/a.foo”<br>$% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是“foo.a(bar.o)”，那么，“$%”就是“bar.o”，“$@”就是“foo.a”</p>
<h3 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h3><p><strong>DSB</strong><br>数据同步隔离。比 DMB 严格： 仅当所有在它前面的存储器访问操作<br>都执行完毕后，才执行在它后面的指令</p>
<p><strong>ISB</strong><br>指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执<br>行完毕之后，才执行它后面的指令。</p>
<p><strong>LDR</strong><br>指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。</p>
<p><strong>LDM</strong><br>虽然貌似是LDR的升级，但是，千万要注意，这个指令运行的方向和LDR是不一样的，是从左到右运行的。该指令是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作</p>
<p><strong>STR</strong><br>指令用于从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p>
<p><strong>MCR</strong><br>指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<p><strong>MRC</strong><br>指令将协处理器的寄存器中数值传送到ARM处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<p><strong>WFI</strong><br>cpu core进入idle模式</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>cross-compile makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-readme</title>
    <url>/2018/08/23/u-boot-readme/</url>
    <content><![CDATA[<h3 id="板子初始化"><a href="#板子初始化" class="headerlink" title="板子初始化"></a>板子初始化</h3><ol>
<li><p>start<br>执行通常从特定于体系结构开始（并且可能是CPU特定的）start.S文件</p>
</li>
<li><p>三个初始化函数</p>
</li>
</ol>
<p>lowlevel_init():<br>    目的：必要的初始化执行到board_init_f<br>    没有：global_data or BSS<br>    没有设置栈<br>    没有设置sdram和console</p>
<p>board_init_f():<br>    目的： 做运行到board_init_r的准备，例如初始化sdram和console<br>    设置好global_data<br>    栈在sdram<br>    没有设置bss段，因此不能使用全局变量或静态变量，只能使用栈变量和global_data</p>
<pre><code>**SPL:**
spl里可以自己实现board_init_f函数，以覆盖uboot版本
执行preloader_console_init、
初始化sdram和console
不用清bss，他会在crt0.s文件里完成</code></pre>
<p>board_init_r():<br>    目的：执行通用代码<br>    global_data，sdram，bss都可以使用<br>    执行最终继续到main_loop（）</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol>
<li>设置环境变量，如果使用的是ELDK 4xxx cpu，则：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE=ppc_4xx-</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE</span><br></pre></td></tr></table></figure></li>
<li>配置uboot<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">make NAME_<span class="function"><span class="keyword">def</span><span class="title">config</span></span></span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">make</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure>
得到如下文件<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">- &quot;u-boot.bin&quot; <span class="keyword">is</span> a raw binary image</span><br><span class="line">- &quot;u-boot&quot; <span class="keyword">is</span> an image <span class="keyword">in</span> ELF binary <span class="keyword">format</span></span><br><span class="line">- &quot;u-boot.srec&quot; <span class="keyword">is</span> <span class="keyword">in</span> Motorola S-<span class="type">Record</span> <span class="keyword">format</span></span><br></pre></td></tr></table></figure></li>
<li>定制编译<br>指定编译路径的两种方法<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">make <span class="attribute">O</span>=/tmp/build distclean</span><br><span class="line">make <span class="attribute">O</span>=/tmp/build NAME_defconfig</span><br><span class="line">make <span class="attribute">O</span>=/tmp/build all</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KBUILD_OUTPUT</span>=/tmp/build</span><br><span class="line">make distclean</span><br><span class="line">make NAME_defconfig</span><br><span class="line">make all</span><br></pre></td></tr></table></figure>
其中O=会替代KBUILD_OUTPUT环境变量<br>指定编译参数<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make</span> KCFLAGS=-W<span class="literal">error</span></span><br></pre></td></tr></table></figure>
<h3 id="适配新板子"><a href="#适配新板子" class="headerlink" title="适配新板子"></a>适配新板子</h3></li>
<li>创建一个新目录用于保存指定代码，至少要包含Makefile和<board>.c文件</li>
<li>创建配置文件include/configs/<board>.h</li>
<li>如果添加一个新的cpu还需要创建一个cpu文件夹保存cpu相关代码</li>
<li>配置 make <board>_defconfig</li>
<li>编译 make</li>
<li>调试 </li>
</ol>
<h3 id="uboot命令"><a href="#uboot命令" class="headerlink" title="uboot命令"></a>uboot命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go	- start application at address <span class="string">&#x27;addr&#x27;</span></span><br><span class="line">run	- run commands <span class="keyword">in</span> an environment variable</span><br><span class="line">bootm	- boot application image from memory</span><br><span class="line">bootp	- boot image via network using BootP/TFTP protocol</span><br><span class="line">bootz   - boot zImage from memory</span><br><span class="line">tftpboot- boot image via network using TFTP protocol</span><br><span class="line">	       and env variables <span class="string">&quot;ipaddr&quot;</span> and <span class="string">&quot;serverip&quot;</span></span><br><span class="line">	       (and eventually <span class="string">&quot;gatewayip&quot;</span>)</span><br><span class="line">tftpput - upload a file via network using TFTP protocol</span><br><span class="line">rarpboot- boot image via network using RARP/TFTP protocol</span><br><span class="line">diskboot- boot from IDE devicebootd   - boot default, i.e., run <span class="string">&#x27;bootcmd&#x27;</span></span><br><span class="line">loads	- load S-Record file over serial line</span><br><span class="line">loadb	- load binary file over serial line (kermit mode)</span><br><span class="line">md	- memory display</span><br><span class="line">mm	- memory modify (auto-incrementing)</span><br><span class="line">nm	- memory modify (constant address)</span><br><span class="line">mw	- memory write (fill)</span><br><span class="line">cp	- memory copy</span><br><span class="line">cmp	- memory compare</span><br><span class="line">crc32	- checksum calculation</span><br><span class="line">i2c	- I2C sub-system</span><br><span class="line">sspi	- SPI utility commands</span><br><span class="line">base	- <span class="built_in">print</span> or <span class="built_in">set</span> address offset</span><br><span class="line">printenv- <span class="built_in">print</span> environment variables</span><br><span class="line">setenv	- <span class="built_in">set</span> environment variables</span><br><span class="line">saveenv - save environment variables to persistent storage</span><br><span class="line">protect - <span class="built_in">enable</span> or <span class="built_in">disable</span> FLASH write protection</span><br><span class="line">erase	- erase FLASH memory</span><br><span class="line">flinfo	- <span class="built_in">print</span> FLASH memory information</span><br><span class="line">nand	- NAND memory operations (see doc/README.nand)</span><br><span class="line">bdinfo	- <span class="built_in">print</span> Board Info structure</span><br><span class="line">iminfo	- <span class="built_in">print</span> header information <span class="keyword">for</span> application image</span><br><span class="line">coninfo - <span class="built_in">print</span> console devices and informations</span><br><span class="line">ide	- IDE sub-system</span><br><span class="line">loop	- infinite loop on address range</span><br><span class="line">loopw	- infinite write loop on address range</span><br><span class="line">mtest	- simple RAM <span class="built_in">test</span></span><br><span class="line">icache	- <span class="built_in">enable</span> or <span class="built_in">disable</span> instruction cache</span><br><span class="line">dcache	- <span class="built_in">enable</span> or <span class="built_in">disable</span> data cache</span><br><span class="line">reset	- Perform RESET of the CPU</span><br><span class="line"><span class="built_in">echo</span>	- <span class="built_in">echo</span> args to console</span><br><span class="line">version - <span class="built_in">print</span> monitor version</span><br><span class="line"><span class="built_in">help</span>	- <span class="built_in">print</span> online <span class="built_in">help</span></span><br><span class="line">?	- <span class="built_in">alias</span> <span class="keyword">for</span> <span class="string">&#x27;help&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="uboot环境变量"><a href="#uboot环境变量" class="headerlink" title="uboot环境变量"></a>uboot环境变量</h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">baudrate	- see CONFIG_BAUDRATE</span><br><span class="line"></span><br><span class="line">  bootdelay	- see CONFIG_BOOTDELAY</span><br><span class="line"></span><br><span class="line">  bootcmd	- see CONFIG_BOOTCOMMAND</span><br><span class="line"></span><br><span class="line">  bootargs	- Boot arguments <span class="keyword">when</span> booting an RTOS image</span><br><span class="line"></span><br><span class="line">  bootfile	- Name <span class="keyword">of</span> the image <span class="keyword">to</span> load <span class="keyword">with</span> TFTP</span><br><span class="line"></span><br><span class="line">  bootm_low	- Memory range available <span class="keyword">for</span> image processing <span class="keyword">in</span> the bootm</span><br><span class="line">		  command can be restricted. This variable <span class="built_in">is</span> given <span class="keyword">as</span></span><br><span class="line">		  a hexadecimal number <span class="built_in">and</span> defines lowest address allowed</span><br><span class="line">		  <span class="keyword">for</span> use <span class="keyword">by</span> the bootm command. See also <span class="string">&quot;bootm_size&quot;</span></span><br><span class="line">		  environment variable. Address defined <span class="keyword">by</span> <span class="string">&quot;bootm_low&quot;</span> <span class="built_in">is</span></span><br><span class="line">		  also the base <span class="keyword">of</span> the initial memory mapping <span class="keyword">for</span> the Linux</span><br><span class="line">		  kernel -- see the description <span class="keyword">of</span> CONFIG_SYS_BOOTMAPSZ <span class="built_in">and</span></span><br><span class="line">		  bootm_mapsize.</span><br><span class="line"></span><br><span class="line">  bootm_mapsize - Size <span class="keyword">of</span> the initial memory mapping <span class="keyword">for</span> the Linux kernel.</span><br><span class="line">		  This variable <span class="built_in">is</span> given <span class="keyword">as</span> a hexadecimal number <span class="built_in">and</span> it</span><br><span class="line">		  defines the size <span class="keyword">of</span> the memory region starting at base</span><br><span class="line">		  address bootm_low that <span class="built_in">is</span> accessible <span class="keyword">by</span> the Linux kernel</span><br><span class="line">		  during early boot.  <span class="keyword">If</span> unset, CONFIG_SYS_BOOTMAPSZ <span class="built_in">is</span> used</span><br><span class="line">		  <span class="keyword">as</span> the <span class="keyword">default</span> value <span class="keyword">if</span> it <span class="built_in">is</span> defined, <span class="built_in">and</span> bootm_size <span class="built_in">is</span></span><br><span class="line">		  used otherwise.</span><br><span class="line"></span><br><span class="line">  bootm_size	- Memory range available <span class="keyword">for</span> image processing <span class="keyword">in</span> the bootm</span><br><span class="line">		  command can be restricted. This variable <span class="built_in">is</span> given <span class="keyword">as</span></span><br><span class="line">		  a hexadecimal number <span class="built_in">and</span> defines the size <span class="keyword">of</span> the region</span><br><span class="line">		  allowed <span class="keyword">for</span> use <span class="keyword">by</span> the bootm command. See also <span class="string">&quot;bootm_low&quot;</span></span><br><span class="line">		  environment variable.</span><br><span class="line"></span><br><span class="line">  bootstopkeysha256, bootdelaykey, bootstopkey	- See README.autoboot</span><br><span class="line"></span><br><span class="line">  updatefile	- Location <span class="keyword">of</span> the software update file <span class="keyword">on</span> a TFTP server, used</span><br><span class="line">		  <span class="keyword">by</span> the automatic software update feature. Please refer <span class="keyword">to</span></span><br><span class="line">		  documentation <span class="keyword">in</span> doc/README.update <span class="keyword">for</span> more details.</span><br><span class="line"></span><br><span class="line">  autoload	- <span class="keyword">if</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&quot;no&quot;</span> (any <span class="type">string</span> beginning <span class="keyword">with</span> <span class="comment">&#x27;n&#x27;),</span></span><br><span class="line">		  <span class="string">&quot;bootp&quot;</span> will just load perform a lookup <span class="keyword">of</span> the</span><br><span class="line">		  configuration <span class="keyword">from</span> the BOOTP server, but <span class="built_in">not</span> <span class="keyword">try</span> <span class="keyword">to</span></span><br><span class="line">		  load any image <span class="keyword">using</span> TFTP</span><br><span class="line"></span><br><span class="line">  autostart	- <span class="keyword">if</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&quot;yes&quot;</span>, an image loaded <span class="keyword">using</span> the <span class="string">&quot;bootp&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;rarpboot&quot;</span>, <span class="string">&quot;tftpboot&quot;</span> <span class="built_in">or</span> <span class="string">&quot;diskboot&quot;</span> commands will</span><br><span class="line">		  be automatically started (<span class="keyword">by</span> internally calling</span><br><span class="line">		  <span class="string">&quot;bootm&quot;</span>)</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">If</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&quot;no&quot;</span>, a standalone image passed <span class="keyword">to</span> the</span><br><span class="line">		  <span class="string">&quot;bootm&quot;</span> command will be copied <span class="keyword">to</span> the load address</span><br><span class="line">		  (<span class="built_in">and</span> eventually uncompressed), but <span class="built_in">NOT</span> be started.</span><br><span class="line">		  This can be used <span class="keyword">to</span> load <span class="built_in">and</span> uncompress arbitrary</span><br><span class="line">		  data.</span><br><span class="line"></span><br><span class="line">  fdt_high	- <span class="keyword">if</span> <span class="keyword">set</span> this restricts the maximum address that the</span><br><span class="line">		  flattened device tree will be copied <span class="keyword">into</span> upon boot.</span><br><span class="line">		  <span class="keyword">For</span> example, <span class="keyword">if</span> you have a system <span class="keyword">with</span> <span class="number">1</span> GB memory</span><br><span class="line">		  at physical address <span class="number">0</span>x10000000, <span class="keyword">while</span> Linux kernel</span><br><span class="line">		  only recognizes the first <span class="number">704</span> MB <span class="keyword">as</span> low memory, you</span><br><span class="line">		  may need <span class="keyword">to</span> <span class="keyword">set</span> fdt_high <span class="keyword">as</span> <span class="number">0</span>x3C000000 <span class="keyword">to</span> have the</span><br><span class="line">		  device tree blob be copied <span class="keyword">to</span> the maximum address</span><br><span class="line">		  <span class="keyword">of</span> the <span class="number">704</span> MB low memory, so that Linux kernel can</span><br><span class="line">		  access it during the boot procedure.</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">If</span> this <span class="built_in">is</span> <span class="keyword">set</span> <span class="keyword">to</span> the special value <span class="number">0</span>xFFFFFFFF <span class="keyword">then</span></span><br><span class="line">		  the fdt will <span class="built_in">not</span> be copied at all <span class="keyword">on</span> boot.  <span class="keyword">For</span> this</span><br><span class="line">		  <span class="keyword">to</span> work it must reside <span class="keyword">in</span> writable memory, have</span><br><span class="line">		  sufficient padding <span class="keyword">on</span> the <span class="keyword">end</span> <span class="keyword">of</span> it <span class="keyword">for</span> u-boot <span class="keyword">to</span></span><br><span class="line">		  add the information it needs <span class="keyword">into</span> it, <span class="built_in">and</span> the memory</span><br><span class="line">		  must be accessible <span class="keyword">by</span> the kernel.</span><br><span class="line"></span><br><span class="line">  fdtcontroladdr- <span class="keyword">if</span> <span class="keyword">set</span> this <span class="built_in">is</span> the address <span class="keyword">of</span> the control flattened</span><br><span class="line">		  device tree used <span class="keyword">by</span> U-Boot <span class="keyword">when</span> CONFIG_OF_CONTROL <span class="built_in">is</span></span><br><span class="line">		  defined.</span><br><span class="line"></span><br><span class="line">  i2cfast	- (PPC405GP|PPC405EP only)</span><br><span class="line">		  <span class="keyword">if</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="comment">&#x27;y&#x27; configures Linux I2C driver for fast</span></span><br><span class="line">		  mode (<span class="number">400</span>kHZ). This environment variable <span class="built_in">is</span> used <span class="keyword">in</span></span><br><span class="line">		  initialization code. So, <span class="keyword">for</span> changes <span class="keyword">to</span> be effective</span><br><span class="line">		  it must be saved <span class="built_in">and</span> board must be reset.</span><br><span class="line"></span><br><span class="line">  initrd_high	- restrict positioning <span class="keyword">of</span> initrd images:</span><br><span class="line">		  <span class="keyword">If</span> this variable <span class="built_in">is</span> <span class="built_in">not</span> <span class="keyword">set</span>, initrd images will be</span><br><span class="line">		  copied <span class="keyword">to</span> the highest possible address <span class="keyword">in</span> RAM; this</span><br><span class="line">		  <span class="built_in">is</span> usually what you want since it allows <span class="keyword">for</span></span><br><span class="line">		  maximum initrd size. <span class="keyword">If</span> <span class="keyword">for</span> some reason you want <span class="keyword">to</span></span><br><span class="line">		  make sure that the initrd image <span class="built_in">is</span> loaded below the</span><br><span class="line">		  CONFIG_SYS_BOOTMAPSZ limit, you can <span class="keyword">set</span> this environment</span><br><span class="line">		  variable <span class="keyword">to</span> a value <span class="keyword">of</span> <span class="string">&quot;no&quot;</span> <span class="built_in">or</span> <span class="string">&quot;off&quot;</span> <span class="built_in">or</span> <span class="string">&quot;0&quot;</span>.</span><br><span class="line">		  Alternatively, you can <span class="keyword">set</span> it <span class="keyword">to</span> a maximum upper</span><br><span class="line">		  address <span class="keyword">to</span> use (U-Boot will still check that it</span><br><span class="line">		  does <span class="built_in">not</span> overwrite the U-Boot stack <span class="built_in">and</span> data).</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">For</span> instance, <span class="keyword">when</span> you have a system <span class="keyword">with</span> <span class="number">16</span> MB</span><br><span class="line">		  RAM, <span class="built_in">and</span> want <span class="keyword">to</span> reserve <span class="number">4</span> MB <span class="keyword">from</span> use <span class="keyword">by</span> Linux,</span><br><span class="line">		  you can <span class="keyword">do</span> this <span class="keyword">by</span> adding <span class="string">&quot;mem=12M&quot;</span> <span class="keyword">to</span> the value <span class="keyword">of</span></span><br><span class="line">		  the <span class="string">&quot;bootargs&quot;</span> variable. However, now you must make</span><br><span class="line">		  sure that the initrd image <span class="built_in">is</span> placed <span class="keyword">in</span> the first</span><br><span class="line">		  <span class="number">12</span> MB <span class="keyword">as</span> well - this can be done <span class="keyword">with</span></span><br><span class="line"></span><br><span class="line">		  setenv initrd_high <span class="number">00</span>c00000</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">If</span> you <span class="keyword">set</span> initrd_high <span class="keyword">to</span> <span class="number">0</span>xFFFFFFFF, this <span class="built_in">is</span> an</span><br><span class="line">		  indication <span class="keyword">to</span> U-Boot that all addresses are legal</span><br><span class="line">		  <span class="keyword">for</span> the Linux kernel, including addresses <span class="keyword">in</span> flash</span><br><span class="line">		  memory. <span class="keyword">In</span> this <span class="keyword">case</span> U-Boot will <span class="built_in">NOT</span> COPY the</span><br><span class="line">		  ramdisk at all. This may be useful <span class="keyword">to</span> reduce the</span><br><span class="line">		  boot time <span class="keyword">on</span> your system, but requires that this</span><br><span class="line">		  feature <span class="built_in">is</span> supported <span class="keyword">by</span> your Linux kernel.</span><br><span class="line"></span><br><span class="line">  ipaddr	- IP address; needed <span class="keyword">for</span> tftpboot command</span><br><span class="line"></span><br><span class="line">  loadaddr	- <span class="keyword">Default</span> load address <span class="keyword">for</span> commands <span class="built_in">like</span> <span class="string">&quot;bootp&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;rarpboot&quot;</span>, <span class="string">&quot;tftpboot&quot;</span>, <span class="string">&quot;loadb&quot;</span> <span class="built_in">or</span> <span class="string">&quot;diskboot&quot;</span></span><br><span class="line"></span><br><span class="line">  loads_echo	- see CONFIG_LOADS_ECHO</span><br><span class="line"></span><br><span class="line">  serverip	- TFTP server IP address; needed <span class="keyword">for</span> tftpboot command</span><br><span class="line"></span><br><span class="line">  bootretry	- see CONFIG_BOOT_RETRY_TIME</span><br><span class="line"></span><br><span class="line">  bootdelaykey	- see CONFIG_AUTOBOOT_DELAY_STR</span><br><span class="line"></span><br><span class="line">  bootstopkey	- see CONFIG_AUTOBOOT_STOP_STR</span><br><span class="line"></span><br><span class="line">  ethprime	- controls which <span class="keyword">interface</span> <span class="built_in">is</span> used first.</span><br><span class="line"></span><br><span class="line">  ethact	- controls which <span class="keyword">interface</span> <span class="built_in">is</span> currently active.</span><br><span class="line">		  <span class="keyword">For</span> example you can <span class="keyword">do</span> the following</span><br><span class="line"></span><br><span class="line">		  =&gt; setenv ethact FEC</span><br><span class="line">		  =&gt; ping <span class="number">192.168</span>.<span class="number">0.1</span> # traffic sent <span class="keyword">on</span> FEC</span><br><span class="line">		  =&gt; setenv ethact SCC</span><br><span class="line">		  =&gt; ping <span class="number">10.0</span>.<span class="number">0.1</span> # traffic sent <span class="keyword">on</span> SCC</span><br><span class="line"></span><br><span class="line">  ethrotate	- <span class="keyword">When</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&quot;no&quot;</span> U-Boot does <span class="built_in">not</span> go through all</span><br><span class="line">		  available network interfaces.</span><br><span class="line">		  It just stays at the currently selected <span class="keyword">interface</span>.</span><br><span class="line"></span><br><span class="line">  netretry	- <span class="keyword">When</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&quot;no&quot;</span> <span class="keyword">each</span> network operation will</span><br><span class="line">		  either succeed <span class="built_in">or</span> fail without retrying.</span><br><span class="line">		  <span class="keyword">When</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&quot;once&quot;</span> the network operation will</span><br><span class="line">		  fail <span class="keyword">when</span> all the available network interfaces</span><br><span class="line">		  are tried once without success.</span><br><span class="line">		  Useful <span class="keyword">on</span> scripts which control the retry operation</span><br><span class="line">		  themselves.</span><br><span class="line"></span><br><span class="line">  npe_ucode	- <span class="keyword">set</span> load address <span class="keyword">for</span> the NPE microcode</span><br><span class="line"></span><br><span class="line">  silent_linux  - <span class="keyword">If</span> <span class="keyword">set</span> <span class="keyword">then</span> Linux will be told <span class="keyword">to</span> boot silently, <span class="keyword">by</span></span><br><span class="line">		  changing the console <span class="keyword">to</span> be empty. <span class="keyword">If</span> <span class="string">&quot;yes&quot;</span> it will be</span><br><span class="line">		  made silent. <span class="keyword">If</span> <span class="string">&quot;no&quot;</span> it will <span class="built_in">not</span> be made silent. <span class="keyword">If</span></span><br><span class="line">		  unset, <span class="keyword">then</span> it will be made silent <span class="keyword">if</span> the U-Boot console</span><br><span class="line">		  <span class="built_in">is</span> silent.</span><br><span class="line"></span><br><span class="line">  tftpsrcp	- <span class="keyword">If</span> this <span class="built_in">is</span> <span class="keyword">set</span>, the value <span class="built_in">is</span> used <span class="keyword">for</span> TFTP<span class="comment">&#x27;s</span></span><br><span class="line">		  UDP source port.</span><br><span class="line"></span><br><span class="line">  tftpdstp	- <span class="keyword">If</span> this <span class="built_in">is</span> <span class="keyword">set</span>, the value <span class="built_in">is</span> used <span class="keyword">for</span> TFTP<span class="comment">&#x27;s UDP</span></span><br><span class="line">		  destination port instead <span class="keyword">of</span> the Well Know Port <span class="number">69</span>.</span><br><span class="line"></span><br><span class="line">  tftpblocksize - Block size <span class="keyword">to</span> use <span class="keyword">for</span> TFTP transfers; <span class="keyword">if</span> <span class="built_in">not</span> <span class="keyword">set</span>,</span><br><span class="line">		  we use the TFTP server<span class="comment">&#x27;s default block size</span></span><br><span class="line"></span><br><span class="line">  tftptimeout	- Retransmission timeout <span class="keyword">for</span> TFTP packets (<span class="keyword">in</span> milli-</span><br><span class="line">		  seconds, minimum value <span class="built_in">is</span> <span class="number">1000</span> = <span class="number">1</span> second). Defines</span><br><span class="line">		  <span class="keyword">when</span> a packet <span class="built_in">is</span> considered <span class="keyword">to</span> be lost so it has <span class="keyword">to</span></span><br><span class="line">		  be retransmitted. The <span class="keyword">default</span> <span class="built_in">is</span> <span class="number">5000</span> = <span class="number">5</span> seconds.</span><br><span class="line">		  Lowering this value may make downloads succeed</span><br><span class="line">		  faster <span class="keyword">in</span> networks <span class="keyword">with</span> high packet loss rates <span class="built_in">or</span></span><br><span class="line">		  <span class="keyword">with</span> unreliable TFTP servers.</span><br><span class="line"></span><br><span class="line">  tftptimeoutcountmax	- maximum count <span class="keyword">of</span> TFTP timeouts (no</span><br><span class="line">		  unit, minimum value = <span class="number">0</span>). Defines how many timeouts</span><br><span class="line">		  can happen during a <span class="type">single</span> file transfer before that</span><br><span class="line">		  transfer <span class="built_in">is</span> aborted. The <span class="keyword">default</span> <span class="built_in">is</span> <span class="number">10</span>, <span class="built_in">and</span> <span class="number">0</span> means</span><br><span class="line">		  <span class="comment">&#x27;no timeouts allowed&#x27;. Increasing this value may help</span></span><br><span class="line">		  downloads succeed <span class="keyword">with</span> high packet loss rates, <span class="built_in">or</span> <span class="keyword">with</span></span><br><span class="line">		  unreliable TFTP servers <span class="built_in">or</span> client hardware.</span><br><span class="line"></span><br><span class="line">  vlan		- <span class="keyword">When</span> <span class="keyword">set</span> <span class="keyword">to</span> a value &lt; <span class="number">4095</span> the traffic over</span><br><span class="line">		  Ethernet <span class="built_in">is</span> encapsulated/received over <span class="number">802.1</span>q</span><br><span class="line">		  VLAN tagged frames.</span><br><span class="line"></span><br><span class="line">  bootpretryperiod	- Period during which BOOTP/DHCP sends retries.</span><br><span class="line">		  Unsigned value, <span class="keyword">in</span> milliseconds. <span class="keyword">If</span> <span class="built_in">not</span> <span class="keyword">set</span>, the period will</span><br><span class="line">		  be either the <span class="keyword">default</span> (<span class="number">28000</span>), <span class="built_in">or</span> a value based <span class="keyword">on</span></span><br><span class="line">		  CONFIG_NET_RETRY_COUNT, <span class="keyword">if</span> defined. This value has</span><br><span class="line">		  precedence over the valu based <span class="keyword">on</span> CONFIG_NET_RETRY_COUNT.</span><br></pre></td></tr></table></figure>
<h3 id="引导格式"><a href="#引导格式" class="headerlink" title="引导格式"></a>引导格式</h3><p><strong>FIT</strong><br>Flexible and powerful format based on Flattened Image Tree – FIT (similar<br>to Flattened Device Tree). It allows the use of images with multiple<br>components (several kernels, ramdisks, etc.), with contents protected by<br>SHA1, MD5 or CRC32. More details are found in the doc/uImage.FIT directory.<br><strong>老的uImage</strong></p>
<p>Old image format is based on binary files which can be basically anything,<br>preceded by a special header; see the definitions in include/image.h for<br>details; basically, the header defines the following image properties:</p>
<ul>
<li>Target Operating System (Provisions for OpenBSD, NetBSD, FreeBSD,<br>4.4BSD, Linux, SVR4, Esix, Solaris, Irix, SCO, Dell, NCR, VxWorks,<br>LynxOS, pSOS, QNX, RTEMS, INTEGRITY;<br>Currently supported: Linux, NetBSD, VxWorks, QNX, RTEMS, LynxOS,<br>INTEGRITY).</li>
<li>Target CPU Architecture (Provisions for Alpha, ARM, Intel x86,<br>IA64, MIPS, NDS32, Nios II, PowerPC, IBM S390, SuperH, Sparc, Sparc 64 Bit;<br>Currently supported: ARM, Intel x86, MIPS, NDS32, Nios II, PowerPC).</li>
<li>Compression Type (uncompressed, gzip, bzip2)</li>
<li>Load Address</li>
<li>Entry Point</li>
<li>Image Name</li>
<li>Image Timestamp<h3 id="构建linux"><a href="#构建linux" class="headerlink" title="构建linux"></a>构建linux</h3>例如：<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span> TQM850L_defconfig</span><br><span class="line"><span class="built_in">make</span> oldconfig</span><br><span class="line"><span class="built_in">make</span> dep</span><br><span class="line"><span class="built_in">make</span> uImage</span><br></pre></td></tr></table></figure>
uImage使用tools/mkimage添加uImage的头部信息<br>构建标准kernel镜像vmlinux elf格式<br>转化为binary格式<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span>&#123;CROSS_COMPILE&#125;-objcopy -O <span class="keyword">binary</span> \</span><br><span class="line">			 -R .note -R .comment \</span><br><span class="line">			 -S vmlinux linux.bin</span><br></pre></td></tr></table></figure>
压缩镜像<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gzip</span> -<span class="number">9</span> linux.bin</span><br></pre></td></tr></table></figure>
用于uboot的压缩binary镜像<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mkimage -A ppc -O linux -T kernel -C gzip \</span><br><span class="line">	-<span class="selector-tag">a</span> <span class="number">0</span> -e <span class="number">0</span> -n <span class="string">&quot;Linux Kernel Image&quot;</span> \</span><br><span class="line">	-d linux<span class="selector-class">.bin</span><span class="selector-class">.gz</span> uImage</span><br></pre></td></tr></table></figure>
<h3 id="64字节头"><a href="#64字节头" class="headerlink" title="64字节头"></a>64字节头</h3></li>
</ul>
<p>“mkimage” encapsulates the images with a 64<br>byte header containing information about target architecture,<br>operating system, image type, compression method, entry points, time<br>stamp, CRC32 checksums, etc.</p>
<h3 id="启动linux"><a href="#启动linux" class="headerlink" title="启动linux"></a>启动linux</h3><p>bootm命令用于启动在ram中的linux，bootargs环境变量会作为参数传入kernel，可以使用printenv和setenv命令去查看和修改环境变量</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">=&gt; printenv bootargs</span><br><span class="line">	bootargs=root=<span class="regexp">/dev/ram</span></span><br><span class="line"></span><br><span class="line">	=&gt; setenv bootargs root=<span class="regexp">/dev/nfs</span> rw nfsroot=<span class="number">10.0</span>.<span class="number">0.2</span><span class="symbol">:/LinuxPPC</span> nfsaddrs=<span class="number">10.0</span>.<span class="number">0.99</span><span class="symbol">:</span><span class="number">10.0</span>.<span class="number">0.2</span></span><br><span class="line"></span><br><span class="line">	=&gt; printenv bootargs</span><br><span class="line">	bootargs=root=<span class="regexp">/dev/nfs</span> rw nfsroot=<span class="number">10.0</span>.<span class="number">0.2</span><span class="symbol">:/LinuxPPC</span> nfsaddrs=<span class="number">10.0</span>.<span class="number">0.99</span><span class="symbol">:</span><span class="number">10.0</span>.<span class="number">0.2</span></span><br><span class="line"></span><br><span class="line">	=&gt; bootm <span class="number">40020000</span></span><br><span class="line">	<span class="comment">## Booting Linux kernel at 40020000 ...</span></span><br><span class="line">	   Image <span class="symbol">Name:</span>	 <span class="number">2.2</span>.<span class="number">13</span> <span class="keyword">for</span> NFS on TQM850L</span><br><span class="line">	   Image <span class="symbol">Type:</span>	 PowerPC Linux Kernel Image (gzip compressed)</span><br><span class="line">	   Data <span class="symbol">Size:</span>	 <span class="number">381681</span> Bytes = <span class="number">372</span> kB = <span class="number">0</span> MB</span><br><span class="line">	   Load <span class="symbol">Address:</span> <span class="number">00000000</span></span><br><span class="line">	   Entry <span class="symbol">Point:</span>	 0000000c</span><br><span class="line">	   Verifying Checksum ... OK</span><br><span class="line">	   Uncompressing Kernel Image ... OK</span><br></pre></td></tr></table></figure>
<h3 id="传入设备树启动linux"><a href="#传入设备树启动linux" class="headerlink" title="传入设备树启动linux"></a>传入设备树启动linux</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">=&gt; print oftaddr</span><br><span class="line">oftaddr=<span class="number">0</span>x300000</span><br><span class="line">=&gt; print oft</span><br><span class="line">oft=oftrees/mpc8540ads.dtb</span><br><span class="line">=&gt; tftp $oftaddr $oft</span><br><span class="line">Spe<span class="symbol">ed:</span> <span class="number">1000</span>, full duplex</span><br><span class="line">Using TSEC0 device</span><br><span class="line">TFTP from server <span class="number">192.168</span>.<span class="number">1.1</span>; our IP <span class="built_in">address</span> is <span class="number">192.168</span>.<span class="number">1.101</span></span><br><span class="line">Filename &#x27;oftrees/mpc8540ads.dtb&#x27;.</span><br><span class="line">Load addre<span class="symbol">ss:</span> <span class="number">0</span>x300000</span><br><span class="line">Loadi<span class="symbol">ng:</span> #</span><br><span class="line">done</span><br><span class="line">Bytes transferred = <span class="number">4106</span> (<span class="number">100</span>a hex)</span><br><span class="line">=&gt; tftp $loadaddr $bootfile</span><br><span class="line">Spe<span class="symbol">ed:</span> <span class="number">1000</span>, full duplex</span><br><span class="line">Using TSEC0 device</span><br><span class="line">TFTP from server <span class="number">192.168</span>.<span class="number">1.1</span>; our IP <span class="built_in">address</span> is <span class="number">192.168</span>.<span class="number">1.2</span></span><br><span class="line">Filename &#x27;uImage&#x27;.</span><br><span class="line">Load addre<span class="symbol">ss:</span> <span class="number">0</span>x200000</span><br><span class="line">Loadi<span class="symbol">ng:</span>############</span><br><span class="line">done</span><br><span class="line">Bytes transferred = <span class="number">1029407</span> (fb51f hex)</span><br><span class="line">=&gt; print loadaddr</span><br><span class="line">loadaddr=<span class="number">200000</span></span><br><span class="line">=&gt; print oftaddr</span><br><span class="line">oftaddr=<span class="number">0</span>x300000</span><br><span class="line">=&gt; bootm $loadaddr - $oftaddr</span><br><span class="line">## Booting image at <span class="number">00200000</span> ...</span><br><span class="line">   Image <span class="built_in">Na</span><span class="symbol">me:</span>	 Linux-<span class="number">2.6</span>.<span class="number">17</span>-dirty</span><br><span class="line">   Image Ty<span class="symbol">pe:</span>	 PowerPC Linux Kernel Image (gzip compressed)</span><br><span class="line">   Data Si<span class="symbol">ze:</span>	 <span class="number">1029343</span> Bytes = <span class="number">1005.2</span> kB</span><br><span class="line">   Load Addre<span class="symbol">ss:</span> <span class="number">00000000</span></span><br><span class="line">   Entry Poi<span class="symbol">nt:</span>	 <span class="number">00000000</span></span><br><span class="line">   Verifying Checksum ... OK</span><br><span class="line">   Uncompressing Kernel Image ... OK</span><br><span class="line">Booting using flat device tree at <span class="number">0</span>x300000</span><br><span class="line">Using MPC85xx ADS machine description</span><br><span class="line">Memory CAM mappi<span class="symbol">ng:</span> CAM0=<span class="number">256</span>Mb, CAM1=<span class="number">256</span>Mb, CAM2=<span class="number">0</span>Mb residu<span class="symbol">al:</span> <span class="number">0</span>Mb</span><br><span class="line">[snip]</span><br></pre></td></tr></table></figure>
<h3 id="启动其他类型镜像"><a href="#启动其他类型镜像" class="headerlink" title="启动其他类型镜像"></a>启动其他类型镜像</h3><p>“Standalone Programs” are directly runnable in the environment<br>    provided by U-Boot; it is expected that (if they behave<br>    well) you can continue to work in U-Boot after return from<br>    the Standalone Program.<br>   “OS Kernel Images” are usually images of some Embedded OS which<br>    will take over control completely. Usually these programs<br>    will install their own set of exception handlers, device<br>    drivers, set up the MMU, etc. - this means, that you cannot<br>    expect to re-enter U-Boot except by resetting the CPU.<br>   “RAMDisk Images” are more or less just data blocks, and their<br>    parameters (address, size) are passed to an OS kernel that is<br>    being started.<br>   “Multi-File Images” contain several images, typically an OS<br>    (Linux) kernel image and one or more data images like<br>    RAMDisks. This construct is useful for instance when you want<br>    to boot over the network using BOOTP etc., where the boot<br>    server provides just a single image file, but you want to get<br>    for instance an OS kernel and a RAMDisk image.</p>
<pre><code>&quot;Multi-File Images&quot; start with a list of image sizes, each
image size (in bytes) specified by an &quot;uint32_t&quot; in network
byte order. This list is terminated by an &quot;(uint32_t)0&quot;.
Immediately after the terminating 0 follow the images, one by
one, all aligned on &quot;uint32_t&quot; boundaries (size rounded up to
a multiple of 4 bytes).</code></pre>
<p>   “Firmware Images” are binary images containing firmware (like<br>    U-Boot or FPGA images) which usually will be programmed to<br>    flash memory.</p>
<p>   “Script files” are command sequences that will be executed by<br>    U-Boot’s command interpreter; this feature is especially<br>    useful when you configure U-Boot to use a real shell (hush)<br>    as command interpreter.</p>
<h3 id="启动zImage"><a href="#启动zImage" class="headerlink" title="启动zImage"></a>启动zImage</h3><p>On some platforms, it’s possible to boot Linux zImage. This is done<br>using the “bootz” command. The syntax of “bootz” command is the same<br>as the syntax of “bootm” command.<br>Note, defining the CONFIG_SUPPORT_RAW_INITRD allows user to supply<br>kernel with raw initrd images. The syntax is slightly different, the<br>address of the initrd must be augmented by it’s size, in the following<br>format: “<initrd addres>:<initrd size>“.</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>reame</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-relocate_code</title>
    <url>/2018/08/26/u-boot-relocate-code/</url>
    <content><![CDATA[<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ldr</span>	x0, [x18, <span class="symbol">#GD_START_ADDR_SP</span>]	<span class="comment">/* x0 &lt;- gd-&gt;start_addr_sp */</span></span><br><span class="line"><span class="keyword">bic</span>	<span class="built_in">sp</span>, x0, <span class="number">#0xf</span>	<span class="comment">/* 16-byte alignment for ABI compliance */</span></span><br><span class="line"><span class="keyword">ldr</span>	x18, [x18, <span class="symbol">#GD_NEW_GD</span>]		<span class="comment">/* x18 &lt;- gd-&gt;new_gd */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">adr</span>	<span class="built_in">lr</span>, relocation_return</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add in link-vs-relocation offset */</span></span><br><span class="line"><span class="keyword">ldr</span>	x9, [x18, <span class="symbol">#GD_RELOC_OFF</span>]	<span class="comment">/* x9 &lt;- gd-&gt;reloc_off */</span></span><br><span class="line"><span class="keyword">add</span>	<span class="built_in">lr</span>, <span class="built_in">lr</span>, x9	<span class="comment">/* new return address after relocation */</span></span><br><span class="line"><span class="keyword">ldr</span>	x0, [x18, <span class="symbol">#GD_RELOCADDR</span>]	<span class="comment">/* x0 &lt;- gd-&gt;relocaddr */</span></span><br><span class="line"><span class="keyword">b</span>	relocate_code <span class="comment">//重定位代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码主体如下"><a href="#代码主体如下" class="headerlink" title="代码主体如下"></a>代码主体如下</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * void relocate_code (addr_moni)</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> relocates the monitor code.</span><br><span class="line"> * x0 holds the destination address.</span><br><span class="line"> */</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	stp	x29, x30, [sp, <span class="comment">#-32]!	/* create a stack frame */</span></span><br><span class="line">	mov	x29, sp    //保存栈的地址到x29中</span><br><span class="line">	str	x0, [sp, <span class="comment">#16]       //将重定向地址x0存入到sp+16处</span></span><br><span class="line">	/*</span><br><span class="line">	 * Copy u-boot from flash to RAM</span><br><span class="line">	 */</span><br><span class="line">	adrp	x1, __image_copy_start		/* x1 &lt;- address bits [31:12] */         //__image_copy_start在连接文件中定义，程序的起始地址</span><br><span class="line">	add	x1, x1, :lo12:__image_copy_start/* x1 &lt;- address bits [11:00] */</span><br><span class="line">	subs	x9, x0, x1			/* x9 &lt;- Run to copy offset */</span><br><span class="line">	b.eq	relocate_done			/* skip relocation */  //如果重定向地址等于程序的起始地址，则跳过重定向过程</span><br><span class="line">	/*</span><br><span class="line">	 * Don<span class="string">&#x27;t ldr x1, __image_copy_start here, since if the code is already</span></span><br><span class="line"><span class="string">	 * running at an address other than it was linked to, that instruction</span></span><br><span class="line"><span class="string">	 * will load the relocated value of __image_copy_start. To</span></span><br><span class="line"><span class="string">	 * correctly apply relocations, we need to know the linked value.</span></span><br><span class="line"><span class="string">	 *</span></span><br><span class="line"><span class="string">	 * Linked &amp;__image_copy_start, which we know was at</span></span><br><span class="line"><span class="string">	 * CONFIG_SYS_TEXT_BASE, which is stored in _TEXT_BASE, as a non-</span></span><br><span class="line"><span class="string">	 * relocated value, since it isn&#x27;</span>t a symbol reference.</span><br><span class="line">	 */</span><br><span class="line">	ldr	x1, _TEXT_BASE		/* x1 &lt;- Linked &amp;__image_copy_start */</span><br><span class="line">	subs	x9, x0, x1		/* x9 &lt;- Link to copy offset */</span><br><span class="line"></span><br><span class="line">	 //计算出重定向地址与程序代码段地址的偏移量offset并存入x9寄存器中</span><br><span class="line">	adrp	x1, __image_copy_start		/* x1 &lt;- address bits [31:12] */</span><br><span class="line">	add	x1, x1, :lo12:__image_copy_start/* x1 &lt;- address bits [11:00] */</span><br><span class="line">	adrp	x2, __image_copy_end		/* x2 &lt;- address bits [31:12] */</span><br><span class="line">	add	x2, x2, :lo12:__image_copy_end	/* x2 &lt;- address bits [11:00] */</span><br><span class="line">copy_loop:</span><br><span class="line">	ldp	x10, x11, [x1], <span class="comment">#16	/* copy from source address [x1] */</span></span><br><span class="line">	stp	x10, x11, [x0], <span class="comment">#16	/* copy to   target address [x0] */</span></span><br><span class="line">	cmp	x1, x2			/* until <span class="built_in">source</span> end address [x2] */</span><br><span class="line">	b.lo	copy_loop</span><br><span class="line">	str	x0, [sp, <span class="comment">#24]</span></span><br><span class="line">	//将__image_copy_start 到__image_copy_end 中的代码拷贝到重定向地址处，并保存新的代码段地址到sp+24中</span><br><span class="line">	/*</span><br><span class="line">	 * Fix .rela.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	adrp	x2, __rel_dyn_start		/* x2 &lt;- address bits [31:12] */</span><br><span class="line">	add	x2, x2, :lo12:__rel_dyn_start	/* x2 &lt;- address bits [11:00] */</span><br><span class="line">	adrp	x3, __rel_dyn_end		/* x3 &lt;- address bits [31:12] */</span><br><span class="line">	add	x3, x3, :lo12:__rel_dyn_end	/* x3 &lt;- address bits [11:00] */</span><br><span class="line">fixloop:</span><br><span class="line">	ldp	x0, x1, [x2], <span class="comment">#16	/* (x0,x1) &lt;- (SRC location, fixup) */</span></span><br><span class="line">	ldr	x4, [x2], <span class="comment">#8		/* x4 &lt;- addend */</span></span><br><span class="line">	and	x1, x1, <span class="comment">#0xffffffff</span></span><br><span class="line">	cmp	x1, <span class="comment">#R_AARCH64_RELATIVE</span></span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: store addend plus offset at dest location */</span><br><span class="line">	add	x0, x0, x9</span><br><span class="line">	add	x4, x4, x9</span><br><span class="line">	str	x4, [x0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	x2, x3</span><br><span class="line">	b.lo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line">	switch_el x1, 3f, 2f, 1f</span><br><span class="line">	bl	hang</span><br><span class="line">3:	mrs	x0, sctlr_el3</span><br><span class="line">	b	0f</span><br><span class="line">2:	mrs	x0, sctlr_el2</span><br><span class="line">	b	0f</span><br><span class="line">1:	mrs	x0, sctlr_el1</span><br><span class="line">//根据不同中断等级读取相应的sctlr_el寄存器值存入到x0中</span><br><span class="line">0:	tbz	w0, <span class="comment">#2, 5f	/* skip flushing cache if disabled */  </span></span><br><span class="line">	tbz	w0, <span class="comment">#12, 4f	/* skip invalidating i-cache if disabled */</span></span><br><span class="line">	ic	iallu		/* i-cache invalidate all */  //设置对整个i-cache有效</span><br><span class="line">	isb	sy 				  //指令同步</span><br><span class="line">4:	ldp	x0, x1, [sp, <span class="comment">#16]   //取出sp+16处的值分别赋给x0、x1，从上面分析可知,x0为重定向地址，x1为重定向代码末端地址</span></span><br><span class="line">	bl	__asm_flush_dcache_range     //刷新数据缓存区</span><br><span class="line">	bl     __asm_flush_l3_dcache      //取出保存的 x29, x30寄存器的值</span><br><span class="line">5:	ldp	x29, x30, [sp],<span class="comment">#32</span></span><br><span class="line">	ret</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></table></figure>
<p>非64位处理器代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * void relocate_code(addr_moni)</span><br><span class="line"> *</span><br><span class="line"> * This <span class="keyword">function</span> relocates the monitor code.</span><br><span class="line"> *</span><br><span class="line"> * NOTE:</span><br><span class="line"> * To prevent the code below from containing references with an R_ARM_ABS32</span><br><span class="line"> * relocation record <span class="built_in">type</span>, we never refer to linker-defined symbols directly.</span><br><span class="line"> * Instead, we <span class="built_in">declare</span> literals <span class="built_in">which</span> contain their relative location with</span><br><span class="line"> * respect to relocate_code, and at run time, add relocate_code back to them.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	/* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		/* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		/* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end	/* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, &#123;r10-r11&#125;		/* copy from <span class="built_in">source</span> address [r1]    */</span><br><span class="line">	stmia	r0!, &#123;r10-r11&#125;		/* copy to   target address [r0]    */  /* x0 &lt;- gd-&gt;relocaddr */</span><br><span class="line">	cmp	r1, r2			/* until <span class="built_in">source</span> end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	/*由于重定向之后，程序的运行地址与链接地址不一致，需要使用需要使用“位置无关代码”。对于一些绝对地址符号，使用位置无关码技术会将其以label的形式放在每个函数的代码实现的末端，统一保存在rel_dyn段中。该处程序的功能即将这些绝对地址转化为重定位之后的新的地址。</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, &#123;r0-r1&#125;		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, <span class="comment">#0xff</span></span><br><span class="line">	cmp	r1, <span class="comment">#R_ARM_RELATIVE</span></span><br><span class="line">	bne	fixnext //不相等是相对位置，而不是绝对位置，不需要转换</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */ //绝对位置转换</span><br><span class="line">	add	r0, r0, r4   /* r4 &lt;- relocation offset */</span><br><span class="line">	ldr	r1, [r0]     //取出绝对地址值</span><br><span class="line">	add	r1, r1, r4   // 加上绝对地址与重定位后地址的差值</span><br><span class="line">	str	r1, [r0]   //重定位后地址写入r0保存的地址里</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef __XSCALE__</span></span><br><span class="line">	/*</span><br><span class="line">	 * On xscale, icache must be invalidated and write buffers drained,</span><br><span class="line">	 * even with cache disabled - 4.2.7 of xscale core developer<span class="string">&#x27;s manual</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */</span></span><br><span class="line"><span class="string">	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* ARMv4- don&#x27;</span>t know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef __ARM_ARCH_4__</span></span><br><span class="line">	mov	pc, lr</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	bx	lr</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_code)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重定位代码主要完成两个任务，<br>一：将代码搬运到重定位后的位置，<br>二：将绝对位置转换为重定位后的相对位置<br>声明：本文参考<a href="https://blog.csdn.net/yanggx0929/article/details/88625845">https://blog.csdn.net/yanggx0929/article/details/88625845</a></p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>relocate_code</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-start</title>
    <url>/2018/08/24/u-boot-start/</url>
    <content><![CDATA[<h3 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h3><p>u-boot的入口函数是start.s里的start函数，以pine_h64为例可以看下主要完成的任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.globl	_start</span><br><span class="line">_start:</span><br><span class="line"><span class="comment">#if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER)</span></span><br><span class="line"><span class="comment">#include &lt;asm/boot0-linux-kernel-header.h&gt;</span></span><br><span class="line"><span class="comment">#elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)</span></span><br><span class="line">/*</span><br><span class="line"> * Various SoCs need something special and SoC-specific up front <span class="keyword">in</span></span><br><span class="line"> * order to boot, allow them to <span class="built_in">set</span> that <span class="keyword">in</span> their boot0.h file and <span class="keyword">then</span></span><br><span class="line"> * use it here.</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#include &lt;asm/arch/boot0.h&gt;</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	<span class="comment">#b	reset</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	.align 3</span><br></pre></td></tr></table></figure>
<p>这里定义了CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK因此这里包含boot0.h这个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if defined(CONFIG_RESERVE_ALLWINNER_BOOT0_HEADER) &amp;&amp; !defined(CONFIG_SPL_BUILD)</span></span><br><span class="line">/* reserve space <span class="keyword">for</span> BOOT0 header information */</span><br><span class="line">	b	reset</span><br><span class="line">	.space	1532</span><br><span class="line"><span class="comment">#elif defined(CONFIG_ARM_BOOT_HOOK_RMR)</span></span><br><span class="line">/*</span><br><span class="line"> * Switch into AArch64 <span class="keyword">if</span> needed.</span><br><span class="line"> * Refer to arch/arm/mach-sunxi/rmr_switch.S <span class="keyword">for</span> the original <span class="built_in">source</span>.</span><br><span class="line"> */</span><br><span class="line">	tst     x0, x0                  // this is <span class="string">&quot;b #0x84&quot;</span> <span class="keyword">in</span> ARM</span><br><span class="line">	b       reset</span><br><span class="line">	.space  0x7c</span><br><span class="line">	.word	0xe59f1024	// ldr     r1, [pc, <span class="comment">#36] ; 0x170000a0</span></span><br><span class="line">	.word	0xe59f0024	// ldr     r0, [pc, <span class="comment">#36] ; CONFIG_*_TEXT_BASE</span></span><br><span class="line">	.word	0xe5810000	// str     r0, [r1]</span><br><span class="line">	.word	0xf57ff04f	// dsb     sy</span><br><span class="line">	.word	0xf57ff06f	// isb     sy</span><br><span class="line">	.word	0xee1c0f50	// mrc     15, 0, r0, cr12, cr0, &#123;2&#125; ; RMR</span><br><span class="line">	.word	0xe3800003	// orr     r0, r0, <span class="comment">#3</span></span><br><span class="line">	.word	0xee0c0f50	// mcr     15, 0, r0, cr12, cr0, &#123;2&#125; ; RMR</span><br><span class="line">	.word	0xf57ff06f	// isb     sy</span><br><span class="line">	.word	0xe320f003	// wfi</span><br><span class="line">	.word	0xeafffffd	// b       @wfi</span><br><span class="line"><span class="comment">#ifndef CONFIG_MACH_SUN50I_H6</span></span><br><span class="line">	.word	0x017000a0	// writeable RVBAR mapping address</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	.word	0x09010040	// writeable RVBAR mapping address</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_SPL_BUILD</span></span><br><span class="line">	.word	CONFIG_SPL_TEXT_BASE</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	.word   CONFIG_SYS_TEXT_BASE</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">/* normal execution */</span><br><span class="line">	b	reset</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>这段代码的注释很清楚实际上就是rmr_switch.S文件里的内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;config.h&gt;</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef CONFIG_MACH_SUN50I_H6</span></span><br><span class="line">	ldr	r1, =0x017000a0		@ MMIO mapped RVBAR[0] register</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	ldr	r1, =0x09010040		@ MMIO mapped RVBAR[0] register</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	ldr	r0, =0x57aA7add		@ start address, to be replaced</span><br><span class="line">	str	r0, [r1]</span><br><span class="line">	dsb	sy</span><br><span class="line">	isb	sy</span><br><span class="line">	mrc	15, 0, r0, cr12, cr0, 2	@ <span class="built_in">read</span> RMR register</span><br><span class="line">	orr	r0, r0, <span class="comment">#3		@ request reset in AArch64</span></span><br><span class="line">	mcr	15, 0, r0, cr12, cr0, 2 @ write RMR register</span><br><span class="line">	isb	sy</span><br><span class="line">1:	wfi</span><br><span class="line">	b	1b</span><br></pre></td></tr></table></figure>
<p>之后跳转到reset处执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reset:</span><br><span class="line">	/* Allow the board to save important registers */</span><br><span class="line">	b	save_boot_params //什么时也没做直接返回</span><br><span class="line">.globl	save_boot_params_ret</span><br><span class="line">save_boot_params_ret:</span><br><span class="line"></span><br><span class="line"><span class="comment">#if CONFIG_POSITION_INDEPENDENT // 未定义</span></span><br><span class="line">	/*</span><br><span class="line">	 * Fix .rela.dyn relocations. This allows U-Boot to be loaded to and</span><br><span class="line">	 * executed at a different address than it was linked at.</span><br><span class="line">	 */</span><br><span class="line">pie_fixup:</span><br><span class="line">	adr	x0, _start		/* x0 &lt;- Runtime value of _start */</span><br><span class="line">	ldr	x1, _TEXT_BASE		/* x1 &lt;- Linked value of _start */</span><br><span class="line">	sub	x9, x0, x1		/* x9 &lt;- Run-vs-link offset */</span><br><span class="line">	adr	x2, __rel_dyn_start	/* x2 &lt;- Runtime &amp;__rel_dyn_start */</span><br><span class="line">	adr	x3, __rel_dyn_end	/* x3 &lt;- Runtime &amp;__rel_dyn_end */</span><br><span class="line">pie_fix_loop:</span><br><span class="line">	ldp	x0, x1, [x2], <span class="comment">#16	/* (x0, x1) &lt;- (Link location, fixup) */</span></span><br><span class="line">	ldr	x4, [x2], <span class="comment">#8		/* x4 &lt;- addend */</span></span><br><span class="line">	cmp	w1, <span class="comment">#1027		/* relative fixup? */</span></span><br><span class="line">	bne	pie_skip_reloc</span><br><span class="line">	/* relative fix: store addend plus offset at dest location */</span><br><span class="line">	add	x0, x0, x9</span><br><span class="line">	add	x4, x4, x9</span><br><span class="line">	str	x4, [x0]</span><br><span class="line">pie_skip_reloc:</span><br><span class="line">	cmp	x2, x3</span><br><span class="line">	b.lo	pie_fix_loop</span><br><span class="line">pie_fixup_done:</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_RESET_SCTRL // 未定义</span></span><br><span class="line">	bl reset_sctrl</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_ARMV8_SPL_EXCEPTION_VECTORS) || !defined(CONFIG_SPL_BUILD) //執行</span></span><br><span class="line">.macro	set_vbar, regname, reg //宏定義</span><br><span class="line">	msr	\regname, \reg </span><br><span class="line">.endm</span><br><span class="line">	adr	x0, vectors</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">.macro	set_vbar, regname, reg</span><br><span class="line">.endm</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	/*</span><br><span class="line">	 * Could be EL3/EL2/EL1, Initial State:</span><br><span class="line">	 * Little Endian, MMU Disabled, i/dCache Disabled</span><br><span class="line">	 */</span><br><span class="line">	switch_el x1, 3f, 2f, 1f</span><br><span class="line">	/* //使能EL3等级下的NS|IRQ|FIQ|EA和FP/SIMD */</span><br><span class="line">3:	set_vbar vbar_el3, x0</span><br><span class="line">	mrs	x0, scr_el3</span><br><span class="line">	orr	x0, x0, <span class="comment">#0xf			/* SCR_EL3.NS|IRQ|FIQ|EA */</span></span><br><span class="line">	msr	scr_el3, x0</span><br><span class="line">	msr	cptr_el3, xzr			/* Enable FP/SIMD */</span><br><span class="line">	/* include/configs/sunxi-common.h:52:<span class="comment">#define COUNTER_FREQUENCY             24000000</span></span><br><span class="line">     */</span><br><span class="line"><span class="comment">#ifdef COUNTER_FREQUENCY</span></span><br><span class="line">	ldr	x0, =COUNTER_FREQUENCY</span><br><span class="line">	msr	cntfrq_el0, x0			/* Initialize CNTFRQ */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	b	0f</span><br><span class="line">	/* 使能EL2等级下的FP/SIMD */</span><br><span class="line">2:	set_vbar	vbar_el2, x0</span><br><span class="line">	mov	x0, <span class="comment">#0x33ff</span></span><br><span class="line">	msr	cptr_el2, x0			/* Enable FP/SIMD */</span><br><span class="line">	b	0f</span><br><span class="line">	/* 使能EL1等级下的FP/SIMD */</span><br><span class="line">1:	set_vbar	vbar_el1, x0</span><br><span class="line">	mov	x0, <span class="comment">#3 &lt;&lt; 20</span></span><br><span class="line">	msr	cpacr_el1, x0			/* Enable FP/SIMD */</span><br><span class="line">0:</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Enable SMPEN bit <span class="keyword">for</span> coherency.</span><br><span class="line">	 * This register is not architectural but at the moment</span><br><span class="line">	 * this bit should be <span class="built_in">set</span> <span class="keyword">for</span> A53/A57/A72.</span><br><span class="line">	 */</span><br><span class="line"><span class="comment">#ifdef CONFIG_ARMV8_SET_SMPEN</span></span><br><span class="line">	switch_el x1, 3f, 1f, 1f //切换执行等级</span><br><span class="line">3:</span><br><span class="line">	mrs     x0, S3_1_c15_c2_1               /* cpuectlr_el1 */</span><br><span class="line">	orr     x0, x0, <span class="comment">#0x40</span></span><br><span class="line">	msr     S3_1_c15_c2_1, x0</span><br><span class="line">1:</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* Apply ARM core specific erratas */</span><br><span class="line">	bl	apply_core_errata //指定应用勘误表</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Cache/BPB/TLB Invalidate</span><br><span class="line">	 * i-cache is invalidated before enabled <span class="keyword">in</span> icache_enable()</span><br><span class="line">	 * tlb is invalidated before mmu is enabled <span class="keyword">in</span> dcache_enable()</span><br><span class="line">	 * d-cache is invalidated before enabled <span class="keyword">in</span> dcache_enable()</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/* Processor specific initialization */</span><br><span class="line">	bl	lowlevel_init</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_ARMV8_SPIN_TABLE) &amp;&amp; !defined(CONFIG_SPL_BUILD) //不执行</span></span><br><span class="line">	branch_if_master x0, x1, master_cpu</span><br><span class="line">	b	spin_table_secondary_jump</span><br><span class="line">	/* never <span class="built_in">return</span> */</span><br><span class="line"><span class="comment">#elif defined(CONFIG_ARMV8_MULTIENTRY) //未定义，不执行</span></span><br><span class="line">	branch_if_master x0, x1, master_cpu</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Slave CPUs</span><br><span class="line">	 */</span><br><span class="line">slave_cpu:</span><br><span class="line">	wfe</span><br><span class="line">	ldr	x1, =CPU_RELEASE_ADDR</span><br><span class="line">	ldr	x0, [x1]</span><br><span class="line">	cbz	x0, slave_cpu</span><br><span class="line">	br	x0			/* branch to the given address */</span><br><span class="line"><span class="comment">#endif /* CONFIG_ARMV8_MULTIENTRY */</span></span><br><span class="line">master_cpu: // master cpu跳转到_main</span><br><span class="line">	bl	_main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>switch_el定义如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Branch according to exception level</span><br><span class="line"> */</span><br><span class="line">.macro	switch_el, xreg, el3_label, el2_label, el1_label</span><br><span class="line">	mrs	\xreg, CurrentEL</span><br><span class="line">	cmp	\xreg, 0xc</span><br><span class="line">	b.eq	\el3_label</span><br><span class="line">	cmp	\xreg, 0x8</span><br><span class="line">	b.eq	\el2_label</span><br><span class="line">	cmp	\xreg, 0x4</span><br><span class="line">	b.eq	\el1_label</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>带入得到如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.macro	switch_el, x1, 3f, 2f, 1f</span><br><span class="line">	mrs	\x1, CurrentEL //读取当前CurrentEL寄存器</span><br><span class="line">	cmp	\x1, 0xc //与0xc比较</span><br><span class="line">	b.eq	\3f //相等跳转到label3</span><br><span class="line">	cmp	\x1, 0x8 //与0x8比较</span><br><span class="line">	b.eq	\2f //相等跳转到label2</span><br><span class="line">	cmp	\x1, 0x4 //与0x4比较</span><br><span class="line">	b.eq	\1f //相等则跳转到label1</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>apply_core_errata定义如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	mov	x29, lr			/* Save LR */</span><br><span class="line">	/* For now, we support Cortex-A53, Cortex-A57 specific errata */</span><br><span class="line"></span><br><span class="line">	/* Check <span class="keyword">if</span> we are running on a Cortex-A53 core */</span><br><span class="line">	branch_if_a53_core x0, apply_a53_core_errata</span><br><span class="line"></span><br><span class="line">	/* Check <span class="keyword">if</span> we are running on a Cortex-A57 core */</span><br><span class="line">	branch_if_a57_core x0, apply_a57_core_errata</span><br><span class="line">0:</span><br><span class="line">	mov	lr, x29			/* Restore LR */</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>branch_if_a57_core宏定义如下，指定勘误表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Branch <span class="keyword">if</span> current processor is a Cortex-A57 core.</span><br><span class="line"> */</span><br><span class="line">.macro	branch_if_a57_core, xreg, a57_label</span><br><span class="line">	mrs	\xreg, midr_el1</span><br><span class="line">	lsr	\xreg, \xreg, <span class="comment">#4</span></span><br><span class="line">	and	\xreg, \xreg, <span class="comment">#0x00000FFF</span></span><br><span class="line">	cmp	\xreg, <span class="comment">#0xD07		/* Cortex-A57 MPCore processor. */</span></span><br><span class="line">	b.eq	\a57_label</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>lowlevel_init定义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WEAK(lowlevel_init)</span><br><span class="line">	mov	x29, lr			/* Save LR */</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_GICV2) || defined(CONFIG_GICV3)</span></span><br><span class="line">	branch_if_slave x0, 1f</span><br><span class="line">	ldr	x0, =GICD_BASE</span><br><span class="line">	bl	gic_init_secure</span><br><span class="line">1:</span><br><span class="line"><span class="comment">#if defined(CONFIG_GICV3)</span></span><br><span class="line">	ldr	x0, =GICR_BASE</span><br><span class="line">	bl	gic_init_secure_percpu</span><br><span class="line"><span class="comment">#elif defined(CONFIG_GICV2)</span></span><br><span class="line">	ldr	x0, =GICD_BASE</span><br><span class="line">	ldr	x1, =GICC_BASE</span><br><span class="line">	bl	gic_init_secure_percpu</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_ARMV8_MULTIENTRY</span></span><br><span class="line">	branch_if_master x0, x1, 2f</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Slave should <span class="built_in">wait</span> <span class="keyword">for</span> master clearing spin table.</span><br><span class="line">	 * This sync prevent salves observing incorrect</span><br><span class="line">	 * value of spin table and jumping to wrong place.</span><br><span class="line">	 */</span><br><span class="line"><span class="comment">#if defined(CONFIG_GICV2) || defined(CONFIG_GICV3)</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_GICV2</span></span><br><span class="line">	ldr	x0, =GICC_BASE</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	bl	gic_wait_for_interrupt</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * All slaves will enter EL2 and optionally EL1.</span><br><span class="line">	 */</span><br><span class="line">	adr	x4, lowlevel_in_el2</span><br><span class="line">	ldr	x5, =ES_TO_AARCH64</span><br><span class="line">	bl	armv8_switch_to_el2</span><br><span class="line"></span><br><span class="line">lowlevel_in_el2:</span><br><span class="line"><span class="comment">#ifdef CONFIG_ARMV8_SWITCH_TO_EL1</span></span><br><span class="line">	adr	x4, lowlevel_in_el1</span><br><span class="line">	ldr	x5, =ES_TO_AARCH64</span><br><span class="line">	bl	armv8_switch_to_el1</span><br><span class="line"></span><br><span class="line">lowlevel_in_el1:</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif /* CONFIG_ARMV8_MULTIENTRY */</span></span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">	mov	lr, x29			/* Restore LR */</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>这些宏定义并没有定义，什么也没做</p>
<h3 id="crt0-64-S"><a href="#crt0-64-S" class="headerlink" title="crt0_64.S"></a>crt0_64.S</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENTRY(_main)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#if defined(CONFIG_TPL_BUILD) &amp;&amp; defined(CONFIG_TPL_NEEDS_SEPARATE_STACK)</span></span><br><span class="line">	ldr	x0, =(CONFIG_TPL_STACK)</span><br><span class="line"><span class="comment">#elif defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span></span><br><span class="line">	ldr	x0, =(CONFIG_SPL_STACK)</span><br><span class="line"><span class="comment">#elif defined(CONFIG_INIT_SP_RELATIVE)</span></span><br><span class="line">	adr	x0, __bss_start</span><br><span class="line">	add	x0, x0, <span class="comment">#CONFIG_SYS_INIT_SP_BSS_OFFSET</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	ldr	x0, =(CONFIG_SYS_INIT_SP_ADDR) //執行这里</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	bic	sp, x0, <span class="comment">#0xf	/* 16-byte alignment for ABI compliance */ //16字节对其</span></span><br><span class="line">	mov	x0, sp //设置sp指针</span><br><span class="line">	bl	board_init_f_alloc_reserve //调用board_init_f_alloc_reserve函数</span><br><span class="line">		ulong board_init_f_alloc_reserve(ulong top) //top = sp = 0x28820</span><br><span class="line">		&#123;</span><br><span class="line">			/* Reserve early malloc arena */</span><br><span class="line">		<span class="comment">#if CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">			top -= CONFIG_VAL(SYS_MALLOC_F_LEN); //top-=0x400</span><br><span class="line">		<span class="comment">#endif</span></span><br><span class="line">			/* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span><br><span class="line">			top = rounddown(top-sizeof(struct global_data), 16);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">return</span> top;</span><br><span class="line">		&#125;</span><br><span class="line">	mov	sp, x0 //再设置sp指针 ，sp设置好之后就可以调用c代码了</span><br><span class="line">	/* <span class="built_in">set</span> up gd here, outside any C code */</span><br><span class="line">	mov	x18, x0</span><br><span class="line">	bl	board_init_f_init_reserve //跳转到board_init_f_init_reserve执行，这里主要分配gd空间及初始化</span><br><span class="line"></span><br><span class="line">	mov	x0, <span class="comment">#0</span></span><br><span class="line">	bl	board_init_f // 初始化设置电源管理，串口初始化，dram初始化，时钟初始化</span><br><span class="line"></span><br><span class="line"><span class="comment">#if !defined(CONFIG_SPL_BUILD)</span></span><br><span class="line">/*</span><br><span class="line"> * Set up intermediate environment (new sp and gd) and call</span><br><span class="line"> * relocate_code(addr_moni). Trick here is that we<span class="string">&#x27;ll return</span></span><br><span class="line"><span class="string"> * &#x27;</span>here<span class="string">&#x27; but relocated.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">	ldr	x0, [x18, #GD_START_ADDR_SP]	/* x0 &lt;- gd-&gt;start_addr_sp */</span></span><br><span class="line"><span class="string">	bic	sp, x0, #0xf	/* 16-byte alignment for ABI compliance */</span></span><br><span class="line"><span class="string">	ldr	x18, [x18, #GD_NEW_GD]		/* x18 &lt;- gd-&gt;new_gd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	adr	lr, relocation_return</span></span><br><span class="line"><span class="string">#if CONFIG_POSITION_INDEPENDENT //未定义</span></span><br><span class="line"><span class="string">	/* Add in link-vs-runtime offset */</span></span><br><span class="line"><span class="string">	adr	x0, _start		/* x0 &lt;- Runtime value of _start */</span></span><br><span class="line"><span class="string">	ldr	x9, _TEXT_BASE		/* x9 &lt;- Linked value of _start */</span></span><br><span class="line"><span class="string">	sub	x9, x9, x0		/* x9 &lt;- Run-vs-link offset */</span></span><br><span class="line"><span class="string">	add	lr, lr, x9</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">	/* Add in link-vs-relocation offset */</span></span><br><span class="line"><span class="string">	ldr	x9, [x18, #GD_RELOC_OFF]	/* x9 &lt;- gd-&gt;reloc_off */</span></span><br><span class="line"><span class="string">	add	lr, lr, x9	/* new return address after relocation */</span></span><br><span class="line"><span class="string">	ldr	x0, [x18, #GD_RELOCADDR]	/* x0 &lt;- gd-&gt;relocaddr */</span></span><br><span class="line"><span class="string">	b	relocate_code //重定位代码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">relocation_return:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * Set up final (full) environment</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">	bl	c_runtime_cpu_setup		/* still call old routine */ start.S文件里</span></span><br><span class="line"><span class="string">#endif /* !CONFIG_SPL_BUILD */</span></span><br><span class="line"><span class="string">#if defined(CONFIG_SPL_BUILD)</span></span><br><span class="line"><span class="string">	bl	spl_relocate_stack_gd           /* may return NULL */ //重定位堆栈准备好执行board_init_r</span></span><br><span class="line"><span class="string">	/* set up gd here, outside any C code, if new stack is returned */</span></span><br><span class="line"><span class="string">	cmp	x0, #0</span></span><br><span class="line"><span class="string">	csel	x18, x0, x18, ne</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Perform &#x27;</span>sp = (x0 != NULL) ? x0 : sp<span class="string">&#x27; while working</span></span><br><span class="line"><span class="string">	 * around the constraint that conditional moves can not</span></span><br><span class="line"><span class="string">	 * have &#x27;</span>sp<span class="string">&#x27; as an operand</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	mov	x1, sp</span></span><br><span class="line"><span class="string">	cmp	x0, #0</span></span><br><span class="line"><span class="string">	csel	x0, x0, x1, ne</span></span><br><span class="line"><span class="string">	mov	sp, x0</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * Clear BSS section //清BSS段</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">	ldr	x0, =__bss_start		/* this is auto-relocated! */</span></span><br><span class="line"><span class="string">	ldr	x1, =__bss_end			/* this is auto-relocated! */</span></span><br><span class="line"><span class="string">clear_loop:</span></span><br><span class="line"><span class="string">	str	xzr, [x0], #8</span></span><br><span class="line"><span class="string">	cmp	x0, x1</span></span><br><span class="line"><span class="string">	b.lo	clear_loop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* call board_init_r(gd_t *id, ulong dest_addr) */</span></span><br><span class="line"><span class="string">	mov	x0, x18				/* gd_t */</span></span><br><span class="line"><span class="string">	ldr	x1, [x18, #GD_RELOCADDR]	/* dest_addr */</span></span><br><span class="line"><span class="string">	b	board_init_r			/* PC relative jump */ //其他初始化</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* NOTREACHED - board_init_r() does not return */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ENDPROC(_main)</span></span><br></pre></td></tr></table></figure>
<p>CONFIG_TPL_BUILD，CONFIG_SPL_BUILD，CONFIG_INIT_SP_RELATIVE都没有定义执行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldr	x0, =(CONFIG_SYS_INIT_SP_ADDR)</span><br></pre></td></tr></table></figure>
<p>CONFIG_SYS_INIT_SP_ADDR的定义如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define CONFIG_SYS_INIT_RAM_SIZE	0x8000 /* 32 KiB */</span></span><br><span class="line"><span class="comment">#define CONFIG_SYS_INIT_SP_OFFSET \</span></span><br><span class="line">	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)</span><br><span class="line"><span class="comment">#define CONFIG_SYS_INIT_SP_ADDR \</span></span><br><span class="line">	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define CONFIG_SUNXI_SRAM_ADDRESS 0x20000</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">#define CONFIG_SYS_INIT_RAM_ADDR	CONFIG_SUNXI_SRAM_ADDRESS</span></span><br><span class="line"><span class="comment">#define GENERATED_GBL_DATA_SIZE 384 /* (sizeof(struct global_data) + 15) &amp; ~15	// */</span></span><br></pre></td></tr></table></figure>
<p>因此可以算出sp指向的地址是sp = 0x28820<br>这里有几个重要函数board_init_f、relocate_code和board_init_r，这些代码的详细分析后续文章再展开。</p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>start uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>u-boot-startKernel</title>
    <url>/2018/08/31/u-boot-startKernel/</url>
    <content><![CDATA[<h3 id="bootm"><a href="#bootm" class="headerlink" title="bootm"></a>bootm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	bootm,	CONFIG_SYS_MAXARGS,	1,	do_bootm,</span><br><span class="line">	<span class="string">&quot;boot application image from memory&quot;</span>, bootm_help_text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>do_bootm</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*******************************************************************/</span><br><span class="line">/* bootm - boot application image from image <span class="keyword">in</span> memory */</span><br><span class="line">/*******************************************************************/</span><br><span class="line"></span><br><span class="line">int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	static int relocated = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!relocated) &#123;</span><br><span class="line">		int i;</span><br><span class="line"></span><br><span class="line">		/* relocate names of sub-command table */</span><br><span class="line">		<span class="keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(cmd_bootm_sub); i++)</span><br><span class="line">			cmd_bootm_sub[i].name += gd-&gt;reloc_off;</span><br><span class="line"></span><br><span class="line">		relocated = 1;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* determine <span class="keyword">if</span> we have a sub <span class="built_in">command</span> */</span><br><span class="line">	argc--; argv++;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; 0) &#123;</span><br><span class="line">		char *endp;</span><br><span class="line"></span><br><span class="line">		simple_strtoul(argv[0], &amp;endp, 16);</span><br><span class="line">		/* endp pointing to NULL means that argv[0] was just a</span><br><span class="line">		 * valid number, pass it along to the normal bootm processing</span><br><span class="line">		 *</span><br><span class="line">		 * If endp is <span class="string">&#x27;:&#x27;</span> or <span class="string">&#x27;#&#x27;</span> assume a FIT identifier so pass</span><br><span class="line">		 * along <span class="keyword">for</span> normal processing.</span><br><span class="line">		 *</span><br><span class="line">		 * Right now we assume the first arg should never be <span class="string">&#x27;-&#x27;</span></span><br><span class="line">		 */</span><br><span class="line">		<span class="keyword">if</span> ((*endp != 0) &amp;&amp; (*endp != <span class="string">&#x27;:&#x27;</span>) &amp;&amp; (*endp != <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">			<span class="built_in">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |</span><br><span class="line">		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |</span><br><span class="line">		BOOTM_STATE_LOADOS |</span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line">		BOOTM_STATE_RAMDISK |</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_PPC) || defined(CONFIG_MIPS)</span></span><br><span class="line">		BOOTM_STATE_OS_CMDLINE |</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class="line">		BOOTM_STATE_OS_GO, &amp;images, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>do_bootm_states</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Execute selected states of the bootm <span class="built_in">command</span>.</span><br><span class="line"> *</span><br><span class="line"> * Note the arguments to this state must be the first argument, Any <span class="string">&#x27;bootm&#x27;</span></span><br><span class="line"> * or sub-command arguments must have already been taken.</span><br><span class="line"> *</span><br><span class="line"> * Note that <span class="keyword">if</span> states contains more than one flag it MUST contain</span><br><span class="line"> * BOOTM_STATE_START, since this handles and consumes the <span class="built_in">command</span> line args.</span><br><span class="line"> *</span><br><span class="line"> * Also note that aside from boot_os_fn <span class="built_in">functions</span> and bootm_load_os no other</span><br><span class="line"> * <span class="built_in">functions</span> we store the <span class="built_in">return</span> value of <span class="keyword">in</span> <span class="string">&#x27;ret&#x27;</span> may use a negative <span class="built_in">return</span></span><br><span class="line"> * value, without special handling.</span><br><span class="line"> *</span><br><span class="line"> * @param cmdtp		Pointer to bootm <span class="built_in">command</span> table entry</span><br><span class="line"> * @param flag		Command flags (CMD_FLAG_...)</span><br><span class="line"> * @param argc		Number of subcommand arguments (0 = no arguments)</span><br><span class="line"> * @param argv		Arguments</span><br><span class="line"> * @param states	Mask containing states to run (BOOTM_STATE_...)</span><br><span class="line"> * @param images	Image header information</span><br><span class="line"> * @param boot_progress 1 to show boot progress, 0 to not <span class="keyword">do</span> this</span><br><span class="line"> * @<span class="built_in">return</span> 0 <span class="keyword">if</span> ok, something <span class="keyword">else</span> on error. Some errors will cause this</span><br><span class="line"> *	<span class="keyword">function</span> to perform a reboot! If states contains BOOTM_STATE_OS_GO</span><br><span class="line"> *	<span class="keyword">then</span> the intent is to boot an OS, so this <span class="keyword">function</span> will not <span class="built_in">return</span></span><br><span class="line"> *	unless the image <span class="built_in">type</span> is standalone.</span><br><span class="line"> */</span><br><span class="line">int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],</span><br><span class="line">		    int states, bootm_headers_t *images, int boot_progress)</span><br><span class="line">&#123;</span><br><span class="line">	boot_os_fn *boot_fn;</span><br><span class="line">	ulong iflag = 0;</span><br><span class="line">	int ret = 0, need_boot_fn;</span><br><span class="line"></span><br><span class="line">	images-&gt;state |= states;   // 把states放到bootm_headers_t images内部</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Work through the states and see how far we get. We stop on</span><br><span class="line">	 * any error.</span><br><span class="line">	 */</span><br><span class="line">	 // 判断states是否需要BOOTM_STATE_START动作，也就是bootm的准备动作，需要的话则调用bootm_start</span><br><span class="line">	<span class="keyword">if</span> (states &amp; BOOTM_STATE_START)    </span><br><span class="line">		ret = bootm_start(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	// 判断states是否需要BOOTM_STATE_FINDOS动作，也就是获取kernel信息，需要的话在调用bootm_find_os</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class="line">		ret = bootm_find_os(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">  // 判断states是否需要BOOTM_STATE_FINDOTHER动作，也就是获取ramdisk和fdt等其他镜像的信息，需要的话则调用bootm_find_other</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER))</span><br><span class="line">		ret = bootm_find_other(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">  // 判断states是否需要BOOTM_STATE_LOADOS动作，也就是加载操作系统的动作，需要的话则调用bootm_load_os</span><br><span class="line">	/* Load the OS */</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) &#123;</span><br><span class="line">		iflag = bootm_disable_interrupts();</span><br><span class="line">		ret = bootm_load_os(images, 0);</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; ret != BOOTM_ERR_OVERLAP)</span><br><span class="line">			goto err;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_OVERLAP)</span><br><span class="line">			ret = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Relocate the ramdisk */  // 是否需要重定向ramdinsk，do_bootm流程的话是不需要的</span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) &#123;</span><br><span class="line">		ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class="line"></span><br><span class="line">		ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class="line">			rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);</span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">			env_set_hex(<span class="string">&quot;initrd_start&quot;</span>, images-&gt;initrd_start);</span><br><span class="line">			env_set_hex(<span class="string">&quot;initrd_end&quot;</span>, images-&gt;initrd_end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if IMAGE_ENABLE_OF_LIBFDT &amp;&amp; defined(CONFIG_LMB)    // 是否需要重定向fdt，do_bootm流程的话是不需要的</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) &#123;</span><br><span class="line">		boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class="line">		ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class="line">					&amp;images-&gt;ft_len);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* From now on, we need the OS boot <span class="keyword">function</span> */</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	boot_fn = bootm_os_get_boot_func(images-&gt;os.os);// 获取对应操作系统的启动函数，存放到boot_fn中</span><br><span class="line">	need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |</span><br><span class="line">			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |</span><br><span class="line">			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);</span><br><span class="line">	<span class="keyword">if</span> (boot_fn == NULL &amp;&amp; need_boot_fn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iflag)</span><br><span class="line">			enable_interrupts();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: booting os &#x27;%s&#x27; (%d) is not supported\n&quot;</span>,</span><br><span class="line">		       genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Call various other states that are not generally used */</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class="line"><span class="comment">#if defined(CONFIG_SILENT_CONSOLE) &amp;&amp; !defined(CONFIG_SILENT_U_BOOT_ONLY)</span></span><br><span class="line">		<span class="keyword">if</span> (images-&gt;os.os == IH_OS_LINUX)</span><br><span class="line">			fixup_silent_linux();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);// 跳转到操作系统前的准备动作，会直接调用启动函数，但是标识是BOOTM_STATE_OS_PREP</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_TRACE   // BOOTM_STATE_OS_GO标识，跳转到操作系统中，并且不应该再返回了</span></span><br><span class="line">	/* Pretend to run the OS, <span class="keyword">then</span> run a user <span class="built_in">command</span> */</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		char *cmd_list = env_get(<span class="string">&quot;fakegocmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line">		<span class="keyword">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class="line">			ret = run_command_list(cmd_list, -1, flag);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* Check <span class="keyword">for</span> unsupported subcommand. */</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		puts(<span class="string">&quot;subcommand not supported\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Now run the OS! We hope this doesn<span class="string">&#x27;t return */</span></span><br><span class="line"><span class="string">	if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))</span></span><br><span class="line"><span class="string">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span></span><br><span class="line"><span class="string">				images, boot_fn);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Deal with any fallout */</span></span><br><span class="line"><span class="string">err:</span></span><br><span class="line"><span class="string">	if (iflag)</span></span><br><span class="line"><span class="string">		enable_interrupts();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (ret == BOOTM_ERR_UNIMPLEMENTED)</span></span><br><span class="line"><span class="string">		bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);</span></span><br><span class="line"><span class="string">	else if (ret == BOOTM_ERR_RESET)</span></span><br><span class="line"><span class="string">		do_reset(cmdtp, flag, argc, argv);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先查看一个结构体bootm_headers_t</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Legacy and FIT format headers used by do_bootm() and do_bootm_&lt;os&gt;()</span><br><span class="line"> * routines.</span><br><span class="line"> */</span><br><span class="line">typedef struct bootm_headers &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * Legacy os image header, <span class="keyword">if</span> it is a multi component image</span><br><span class="line">	 * <span class="keyword">then</span> boot_get_ramdisk() and get_fdt() will attempt to get</span><br><span class="line">	 * data from second and third component accordingly.</span><br><span class="line">	 */</span><br><span class="line">	image_header_t	*legacy_hdr_os;		/* image header pointer */</span><br><span class="line">	image_header_t	legacy_hdr_os_copy;	/* header copy */</span><br><span class="line">	ulong		legacy_hdr_valid;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if IMAGE_ENABLE_FIT</span></span><br><span class="line">	const char	*fit_uname_cfg;	/* configuration node unit name */</span><br><span class="line"></span><br><span class="line">	void		*fit_hdr_os;	/* os FIT image header */</span><br><span class="line">	const char	*fit_uname_os;	/* os subimage node unit name */</span><br><span class="line">	int		fit_noffset_os;	/* os subimage node offset */</span><br><span class="line"></span><br><span class="line">	void		*fit_hdr_rd;	/* init ramdisk FIT image header */</span><br><span class="line">	const char	*fit_uname_rd;	/* init ramdisk subimage node unit name */</span><br><span class="line">	int		fit_noffset_rd;	/* init ramdisk subimage node offset */</span><br><span class="line"></span><br><span class="line">	void		*fit_hdr_fdt;	/* FDT blob FIT image header */</span><br><span class="line">	const char	*fit_uname_fdt;	/* FDT blob subimage node unit name */</span><br><span class="line">	int		fit_noffset_fdt;/* FDT blob subimage node offset */</span><br><span class="line"></span><br><span class="line">	void		*fit_hdr_setup;	/* x86 setup FIT image header */</span><br><span class="line">	const char	*fit_uname_setup; /* x86 setup subimage node name */</span><br><span class="line">	int		fit_noffset_setup;/* x86 setup subimage node offset */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef USE_HOSTCC</span></span><br><span class="line">	image_info_t	os;		/* os image info */</span><br><span class="line">	ulong		ep;		/* entry point of OS */</span><br><span class="line"></span><br><span class="line">	ulong		rd_start, rd_end;/* ramdisk start/end */</span><br><span class="line"></span><br><span class="line">	char		*ft_addr;	/* flat dev tree address */</span><br><span class="line">	ulong		ft_len;		/* length of flat device tree */</span><br><span class="line"></span><br><span class="line">	ulong		initrd_start;</span><br><span class="line">	ulong		initrd_end;</span><br><span class="line">	ulong		cmdline_start;</span><br><span class="line">	ulong		cmdline_end;</span><br><span class="line">	bd_t		*kbd;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	int		verify;		/* env_get(<span class="string">&quot;verify&quot;</span>)[0] != <span class="string">&#x27;n&#x27;</span> */</span><br><span class="line"></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_START	(0x00000001)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_FINDOS	(0x00000002)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_FINDOTHER	(0x00000004)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_LOADOS	(0x00000008)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_RAMDISK	(0x00000010)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_FDT		(0x00000020)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_OS_CMDLINE	(0x00000040)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_OS_BD_T	(0x00000080)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_OS_PREP	(0x00000100)</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_OS_FAKE_GO	(0x00000200)	/* &#x27;Almost&#x27; run the OS */</span></span><br><span class="line"><span class="comment">#define	BOOTM_STATE_OS_GO	(0x00000400)</span></span><br><span class="line">	int		state;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_LMB</span></span><br><span class="line">	struct lmb	lmb;		/* <span class="keyword">for</span> memory mgmt */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125; bootm_headers_t;</span><br></pre></td></tr></table></figure>
<p>里面几个重要函数说明<br>bootm_start<br>实现verify和lmb<br>bootm_find_os<br>实现os和ep。<br>也就是说，不管是Legacy-uImage还是FIT-uImage，最终解析出来要得到的都是这两个成员。<br>bootm_find_other<br>实现rd_start, rd_end，ft_addr和initrd_end。<br>也就是说，不管是Legacy-uImage还是FIT-uImage，最终解析出来要得到的都是这两个成员。 </p>
<p><strong>bootm_load_os</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int bootm_load_os(bootm_headers_t *images, int boot_progress)</span><br><span class="line">&#123;</span><br><span class="line">	image_info_t os = images-&gt;os;</span><br><span class="line">	ulong load = os.load;// kernel要加载的地址</span><br><span class="line">	ulong load_end;</span><br><span class="line">	ulong blob_start = os.start;</span><br><span class="line">	ulong blob_end = os.end;</span><br><span class="line">	ulong image_start = os.image_start;// kernel实际存在的位置</span><br><span class="line">	ulong image_len = os.image_len;// kernel的长度</span><br><span class="line">	ulong flush_start = ALIGN_DOWN(load, ARCH_DMA_MINALIGN);</span><br><span class="line">	bool no_overlap;</span><br><span class="line">	void *load_buf, *image_buf;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	load_buf = map_sysmem(load, 0);</span><br><span class="line">	image_buf = map_sysmem(os.image_start, image_len);</span><br><span class="line">	// 调用bootm_decomp_image，对image_buf的镜像进行解压缩，并load到load_buf上</span><br><span class="line">	err = image_decomp(os.comp, load, os.image_start, os.type,</span><br><span class="line">			   load_buf, image_buf, image_len,</span><br><span class="line">			   CONFIG_SYS_BOOTM_LEN, &amp;load_end);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		err = handle_decomp_error(os.comp, load_end - load, err);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);</span><br><span class="line">		<span class="built_in">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flush_cache(flush_start, ALIGN(load_end, ARCH_DMA_MINALIGN) - flush_start);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;   kernel loaded at 0x%08lx, end = 0x%08lx\n&quot;</span>, load, load_end);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);</span><br><span class="line"></span><br><span class="line">	no_overlap = (os.comp == IH_COMP_NONE &amp;&amp; load == image_start);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!no_overlap &amp;&amp; load &lt; blob_end &amp;&amp; load_end &gt; blob_start) &#123;</span><br><span class="line">		debug(<span class="string">&quot;images.os.start = 0x%lX, images.os.end = 0x%lx\n&quot;</span>,</span><br><span class="line">		      blob_start, blob_end);</span><br><span class="line">		debug(<span class="string">&quot;images.os.load = 0x%lx, load_end = 0x%lx\n&quot;</span>, load,</span><br><span class="line">		      load_end);</span><br><span class="line"></span><br><span class="line">		/* Check what <span class="built_in">type</span> of image this is. */</span><br><span class="line">		<span class="keyword">if</span> (images-&gt;legacy_hdr_valid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (image_get_type(&amp;images-&gt;legacy_hdr_os_copy)</span><br><span class="line">					== IH_TYPE_MULTI)</span><br><span class="line">				puts(<span class="string">&quot;WARNING: legacy format multi component image overwritten\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span> BOOTM_ERR_OVERLAP;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			puts(<span class="string">&quot;ERROR: new format image overwritten - must RESET the board to recover\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);</span><br><span class="line">			<span class="built_in">return</span> BOOTM_ERR_RESET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lmb_reserve(&amp;images-&gt;lmb, images-&gt;os.load, (load_end -</span><br><span class="line">						    images-&gt;os.load));</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bootm_os_get_boot_func</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static boot_os_fn *boot_os[] = &#123;</span><br><span class="line">	[IH_OS_U_BOOT] = do_bootm_standalone,</span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOTM_LINUX</span></span><br><span class="line">	[IH_OS_LINUX] = do_bootm_linux,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOTM_NETBSD</span></span><br><span class="line">	[IH_OS_NETBSD] = do_bootm_netbsd,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_LYNXKDI</span></span><br><span class="line">	[IH_OS_LYNXOS] = do_bootm_lynxkdi,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOTM_RTEMS</span></span><br><span class="line">	[IH_OS_RTEMS] = do_bootm_rtems,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_BOOTM_OSE)</span></span><br><span class="line">	[IH_OS_OSE] = do_bootm_ose,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_BOOTM_PLAN9)</span></span><br><span class="line">	[IH_OS_PLAN9] = do_bootm_plan9,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_BOOTM_VXWORKS) &amp;&amp; \</span></span><br><span class="line">	(defined(CONFIG_PPC) || defined(CONFIG_ARM) || defined(CONFIG_RISCV))</span><br><span class="line">	[IH_OS_VXWORKS] = do_bootm_vxworks,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_CMD_ELF)</span></span><br><span class="line">	[IH_OS_QNX] = do_bootm_qnxelf,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_INTEGRITY</span></span><br><span class="line">	[IH_OS_INTEGRITY] = do_bootm_integrity,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOTM_OPENRTOS</span></span><br><span class="line">	[IH_OS_OPENRTOS] = do_bootm_openrtos,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_BOOTM_OPTEE</span></span><br><span class="line">	[IH_OS_TEE] = do_bootm_tee,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">boot_os_fn *bootm_os_get_boot_func(int os)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	static bool relocated;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!relocated) &#123;</span><br><span class="line">		int i;</span><br><span class="line"></span><br><span class="line">		/* relocate boot <span class="keyword">function</span> table */</span><br><span class="line">		<span class="keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(boot_os); i++)</span><br><span class="line">			<span class="keyword">if</span> (boot_os[i] != NULL)</span><br><span class="line">				boot_os[i] += gd-&gt;reloc_off;</span><br><span class="line"></span><br><span class="line">		relocated = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="built_in">return</span> boot_os[os];// 根据操作系统类型获得到对应的操作函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出最终启动linux的核心函数是do_bootm_linux。 </p>
<p><strong>do_bootm_linux</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Main Entry point <span class="keyword">for</span> arm bootm implementation</span><br><span class="line"> *</span><br><span class="line"> * Modeled after the powerpc implementation</span><br><span class="line"> * DIFFERENCE: Instead of calling prep and go at the end</span><br><span class="line"> * they are called <span class="keyword">if</span> subcommand is equal 0.</span><br><span class="line"> */</span><br><span class="line">int do_bootm_linux(int flag, int argc, char * const argv[],</span><br><span class="line">		   bootm_headers_t *images)</span><br><span class="line">&#123;</span><br><span class="line">	/* No need <span class="keyword">for</span> those on ARM */</span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line"></span><br><span class="line">	 // 当flag为BOOTM_STATE_OS_PREP，则说明只需要做准备动作boot_prep_linux</span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class="line">		boot_prep_linux(images);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 当flag为BOOTM_STATE_OS_GO ，则说明只需要做跳转动作 </span><br><span class="line">	<span class="keyword">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		boot_jump_linux(images, flag);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	boot_prep_linux(images); // 以全局变量bootm_headers_t images为参数传递给boot_prep_linux</span><br><span class="line">	boot_jump_linux(images, flag);  // 以全局变量bootm_headers_t images为参数传递给boot_jump_linux</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>boot_prep_linux用于实现跳转到linux前的准备动作。<br>而boot_jump_linux用于跳转到linux中。 </p>
<p><strong>boot_jump_linux</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Subcommand: GO */</span><br><span class="line">static void boot_jump_linux(bootm_headers_t *images, int flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_ARM64</span></span><br><span class="line">	void (*kernel_entry)(void *fdt_addr, void *res0, void *res1,</span><br><span class="line">			void *res2);</span><br><span class="line">	int fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO); // 伪跳转，并不真正地跳转到kernel中</span><br><span class="line"></span><br><span class="line">	// 将kernel_entry设置为images中的ep（kernel的入口地址），后面直接执行kernel_entry也就跳转到了kernel中了</span><br><span class="line">    // 这里要注意这种跳转的方法</span><br><span class="line">	kernel_entry = (void (*)(void *fdt_addr, void *res0, void *res1,</span><br><span class="line">				void *res2))images-&gt;ep;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;## Transferring control to Linux (at address %lx)...\n&quot;</span>,</span><br><span class="line">		(ulong) kernel_entry);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line"></span><br><span class="line">	announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fake) &#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_ARMV8_PSCI</span></span><br><span class="line">		armv8_setup_psci();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		do_nonsec_virt_switch();</span><br><span class="line"></span><br><span class="line">		update_os_arch_secondary_cores(images-&gt;os.arch);</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_ARMV8_SWITCH_TO_EL1</span></span><br><span class="line">		armv8_switch_to_el2((u64)images-&gt;ft_addr, 0, 0, 0,</span><br><span class="line">				    (u64)switch_to_el1, ES_TO_AARCH64);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">		<span class="keyword">if</span> ((IH_ARCH_DEFAULT == IH_ARCH_ARM64) &amp;&amp;</span><br><span class="line">		    (images-&gt;os.arch == IH_ARCH_ARM))</span><br><span class="line">			armv8_switch_to_el2(0, (u64)gd-&gt;bd-&gt;bi_arch_number,</span><br><span class="line">					    (u64)images-&gt;ft_addr, 0,</span><br><span class="line">					    (u64)images-&gt;ep,</span><br><span class="line">					    ES_TO_AARCH32);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			armv8_switch_to_el2((u64)images-&gt;ft_addr, 0, 0, 0,</span><br><span class="line">					    images-&gt;ep,</span><br><span class="line">					    ES_TO_AARCH64);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	unsigned long machid = gd-&gt;bd-&gt;bi_arch_number; // 从bd中获取machine-id</span><br><span class="line">	char *s;</span><br><span class="line">	void (*kernel_entry)(int zero, int arch, uint params);</span><br><span class="line">	unsigned long r2;</span><br><span class="line">	int fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line"></span><br><span class="line">	kernel_entry = (void (*)(int, int, uint))images-&gt;ep;</span><br><span class="line"><span class="comment">#ifdef CONFIG_CPU_V7M</span></span><br><span class="line">	ulong addr = (ulong)kernel_entry | 1;</span><br><span class="line">	kernel_entry = (void *)addr;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	s = env_get(<span class="string">&quot;machid&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (strict_strtoul(s, 16, &amp;machid) &lt; 0) &#123;</span><br><span class="line">			debug(<span class="string">&quot;strict_strtoul failed!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Using machid 0x%lx from environment\n&quot;</span>, machid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;## Transferring control to Linux (at address %08lx)&quot;</span> \</span><br><span class="line">		<span class="string">&quot;...\n&quot;</span>, (ulong) kernel_entry);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line">	announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line">	  // 把images-&gt;ft_addr（fdt的地址）放在r2寄存器中</span><br><span class="line">	<span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)</span><br><span class="line">		r2 = (unsigned long)images-&gt;ft_addr;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r2 = gd-&gt;bd-&gt;bi_boot_params;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fake) &#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_ARMV7_NONSEC</span></span><br><span class="line">		<span class="keyword">if</span> (armv7_boot_nonsec()) &#123;</span><br><span class="line">			armv7_init_nonsec();</span><br><span class="line">			secure_ram_addr(_do_nonsec_entry)(kernel_entry,</span><br><span class="line">							  0, machid, r2);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">			// 这里通过调用kernel_entry，就跳转到了images-&gt;ep中了，也就是跳转到kernel中了，具体则是kernel的_start符号的地址。</span><br><span class="line">			 // 参数0则传入到r0寄存器中，参数machid传入到r1寄存器中，把images-&gt;ft_addr（fdt的地址）放在r2寄存器中</span><br><span class="line">			kernel_entry(0, machid, r2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明：本文参考<a href="https://blog.csdn.net/ooonebook/article/details/53495021%EF%BC%8C%E5%8E%9F%E6%96%87%E6%9B%B4%E8%AF%A6%E7%BB%86">https://blog.csdn.net/ooonebook/article/details/53495021，原文更详细</a></p>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>start kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu-vmware</title>
    <url>/2020/02/11/ubuntu-vmware/</url>
    <content><![CDATA[<h3 id="vmware扩容方法"><a href="#vmware扩容方法" class="headerlink" title="vmware扩容方法"></a>vmware扩容方法</h3><p>1、先在vmware里将最大磁盘空间进行扩展<br>2、进入系统，使用fdisk工具先删除/dev/sda2分区，然后创建新分区，注意开始的磁柱号要和原来的一致（是保证数据不丢失的关键步骤），结束的磁柱号默认回车使用全部磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure>
<p> 3、调整分区大小<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e2fsck -f /dev/sda2                <span class="comment">#检查分区信息</span></span><br><span class="line">resize2fs -p /dev/sda2             <span class="comment">#调整分区大小</span></span><br></pre></td></tr></table></figure><br>4、检查是否已经完成扩容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>ucos-PrioritylookupAlgorithm</title>
    <url>/2018/08/03/ucos-PrioritylookupAlgorithm/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ucos是嵌入式实时操作系统，因此对于任务调度有着严格的时间要求，即在不同优先级任务之间的调度时间应该保持一致，但是普通查表法会从头开始遍历数组，这样就绪态最高优先级的任务的优先级高的会比就绪态最高优先级低的任务先被查找到，造成不同优先级任务在调度上花费时间不一致的情况发生。为了可以在相同时间里查找到最高就绪态优先级任务，ucos采用的空间换取时间的算法在相同时间里查找到优先级最高任务，具体算法如下：</p>
<h3 id="设置任务优先级"><a href="#设置任务优先级" class="headerlink" title="设置任务优先级"></a>设置任务优先级</h3><p>整个算法由两个变量、两个表格和三个程序组成：两个变量是OSRdyGrp和OSRdyTbl[];两个表格是位掩码表OSMapTbl[]和优先级判定表OSUnMap[]，三个程序分别是使任务进入就绪、使任务脱离就绪、寻找准备就绪的最高优先级任务的程序。<br><img src="/picture/%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8.jpg" alt="优先级表"> <img src="/picture/OSMAPTBL.jpg" alt="OSUnMapTbl"><br>使任务进入就绪态的程序如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 将prio优先级放入就绪态优先级表中*/</span><br><span class="line">OSRdyGrp = OSMapTbl[prio&gt;&gt;3]; //设置就绪态优先级组标志</span><br><span class="line">OSRdyTbl[prio&gt;&gt;3] |= OSMapTbl[prio&amp;0x07]; //设置就绪态优先级组内的位标志</span><br></pre></td></tr></table></figure>
<p>就是将OSRdyTbl相应元素的相应位置位，使任务脱离就绪状态就是将相应位置零，程序如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*将prio优先级从就绪态优先级表中删除*/</span><br><span class="line"><span class="keyword">if</span>(OSRdyTbl[prio&gt;&gt;3] &amp;=~OSMapTbl[prio &amp; 0x07]) == 0) </span><br><span class="line">OSRdyGrp &amp;=~ OSMapTbl[prio&gt;&gt;3]; </span><br></pre></td></tr></table></figure>
<p>变量OSRdyGrp的每一位就代表一个组。</p>
<h3 id="查找高优先级任务"><a href="#查找高优先级任务" class="headerlink" title="查找高优先级任务"></a>查找高优先级任务</h3><p>任务优先级计算公式prio=y*8+x，其中y=OSRdyGrp最高优先级的任务在OSRdyGrp的最低不为0的位的那个组，在这个组里优先级最高的任务在组内最低不为0的位，因此寻找最高优先级任务就相当于寻找这两个变量里最低不为0的位。接下来就是通过OSUnMapTbl[]数组来查找最低位不为0的位的数组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INT8U const OSUnMapTbl[256] = &#123;</span><br><span class="line">    0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x00 to 0x0F */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x10 to 0x1F */</span><br><span class="line">    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x20 to 0x2F */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x30 to 0x3F */</span><br><span class="line">    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x40 to 0x4F */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x50 to 0x5F */</span><br><span class="line">    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x60 to 0x6F */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x70 to 0x7F */</span><br><span class="line">    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x80 to 0x8F */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x90 to 0x9F */</span><br><span class="line">    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0xA0 to 0xAF */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0xB0 to 0xBF */</span><br><span class="line">    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0xC0 to 0xCF */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0xD0 to 0xDF */</span><br><span class="line">    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0xE0 to 0xEF */</span><br><span class="line">    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0  /* 0xF0 to 0xFF */</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>这个表格里的数据很奇怪，好像没什么规律，其实这些数据是0x00-0xff这些数据中最低位不为0的位数详细如下：</p>
<p>0x00 ==00000000b 最低位为1的位数为 bit0；0x01 ==00000001b 最低位为1的位数为 bit0；0x02 ==00000010b 最低位为1的位数为 bit1；<br>0x03 ==00000011b 最低位为1的位数为 bit0；0x04 ==00000100b 最低位为1的位数为 bit2；0x05 ==00000101b 最低位为1的位数为 bit0；以此类推就得到OSUnMapTbl表格。<br>最高优先级任务就是在优先级组和位里找到最低位不为0的位并组合位一个完整的优先级，计算如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 计算就绪态最高优先级 */</span><br><span class="line">y = OSUnMapTbl[OSRdyGrp];</span><br><span class="line">x = OSUnMapTbl[OSRdyTbl[y]];</span><br><span class="line">OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="string">3) + x);</span></span><br></pre></td></tr></table></figure>
<p>这就是用空间换时间的算法，可以保障寻找到最高优先级任务的时间相同。</p>
<p>声明：本文参考嵌入式实时操作系统ucos-ii教程</p>
]]></content>
      <categories>
        <category>ucos</category>
      </categories>
      <tags>
        <tag>ucos Priority algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ucos-delayjitter</title>
    <url>/2018/08/04/ucos-delayjitter/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于操作系统来讲时间是颗粒性的不是连续的（物理世界也是这样的），就是操作系统有最小时间颗粒，假如操作系统的时钟滴答是1ms那么操作系统是没办法区分小于这个时间的，这就是操作系统延时抖动的一个重要原因，操作系统会把999us到1ms的这个1us是1ms处理，当然也会将1us到1999us这个接近2ms的时间当成1ms计算，这就造成了一定的延时误差，另一个延时误差来自任务的运行，任务是轮询运行的也就是延时1ms后时间到了，但是高优先级任务会先运行，之后再将cpu控制权转交给延时任务，这两个延时共同构成了操作系统的延时抖动，对于精确的延时需要采用硬件定时器延时，但是对于精度要求不是那么高利用操作系统提供的延时是非常方便的，其延时误差在时钟颗粒级别非常小。</p>
<h3 id="任务调度时机"><a href="#任务调度时机" class="headerlink" title="任务调度时机"></a>任务调度时机</h3><p>假设时钟节拍是1ms发生一次，要求任务A延时一个时钟节拍下面三种情况体现了延时抖动的原因。<br><img src="/picture/rtos%E5%BB%B6%E6%97%B6.png" alt="任务调度时机"></p>
<p>第一种情况下执行延时函数后不到1ms就到来时钟节拍而其他高优先级任务又没有多少任务可以执行很快轮到任务A执行因此任务A实际延时小于1ms。</p>
<p>第二种情况当调用延时函数后高优先级任务执行时间较长大于上一次时钟节拍到来到调用延时函数的时间，那么延时将大于1ms</p>
<p>第三种情况是高优先级任务执行时间过长超过一个时钟节拍那么那么实际延时可能是2ms因此，采用操作系统延时是不准确的，下图是任务调度时机:</p>
<p>延时的实际执行过程是这样的，在每一次时钟周期到来将发生一次中断，调用节拍服务函数OSTimeTick()，该函数主要的功能是给每个用户任务控制块OS_TCB中的时钟延时项OSTCBDly减一直到等于0，在减到0之前任务是挂起的，而当任务延时减到0时任务不一定是就绪态最高优先级任务，因此任务不一定立即得到执行，而产生延时误差。如果需要精确的延时可以采用定时器延时，定时器延时产生的中断优先级更高需要立即处理。</p>
<p>如下是该函数的源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*********************************************************************************************************</span><br><span class="line">*                                         PROCESS SYSTEM TICK</span><br><span class="line">*</span><br><span class="line">* Description: This <span class="keyword">function</span> is used to signal to uC/OS-II the occurrence of a <span class="string">&#x27;system tick&#x27;</span> (also known</span><br><span class="line">*              as a <span class="string">&#x27;clock tick&#x27;</span>).  This <span class="keyword">function</span> should be called by the ticker ISR but, can also be</span><br><span class="line">*              called by a high priority task.</span><br><span class="line">*</span><br><span class="line">* Arguments  : none</span><br><span class="line">*</span><br><span class="line">* Returns    : none</span><br><span class="line">*********************************************************************************************************</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void  OSTimeTick (void)</span><br><span class="line">&#123;</span><br><span class="line">    OS_TCB    *ptcb;</span><br><span class="line"><span class="comment">#if OS_TICK_STEP_EN &gt; 0</span></span><br><span class="line">    BOOLEAN    step;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */</span></span><br><span class="line">    OS_CPU_SR  cpu_sr = 0;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if OS_TIME_TICK_HOOK_EN &gt; 0</span></span><br><span class="line">    OSTimeTickHook();                                      /* Call user definable hook                     */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if OS_TIME_GET_SET_EN &gt; 0</span></span><br><span class="line">    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */</span><br><span class="line">    OSTime++;</span><br><span class="line">    OS_EXIT_CRITICAL();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    <span class="keyword">if</span> (OSRunning == OS_TRUE) &#123;</span><br><span class="line"><span class="comment">#if OS_TICK_STEP_EN &gt; 0</span></span><br><span class="line">        switch (OSTickStepState) &#123;                         /* Determine whether we need to process a tick  */</span><br><span class="line">            <span class="keyword">case</span> OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */</span><br><span class="line">                 step = OS_TRUE;</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OS_TICK_STEP_WAIT:                        /* No,  waiting <span class="keyword">for</span> uC/OS-View to <span class="built_in">set</span> …       */</span><br><span class="line">                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OS_TICK_STEP_ONCE:                        /* Yes, process tick once and <span class="built_in">wait</span> <span class="keyword">for</span> next … */</span><br><span class="line">                 step            = OS_TRUE;                /*      … step <span class="built_in">command</span> from uC/OS-View        */</span><br><span class="line">                 OSTickStepState = OS_TICK_STEP_WAIT;</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">            default:                                       /* Invalid <span class="keyword">case</span>, correct situation              */</span><br><span class="line">                 step            = OS_TRUE;</span><br><span class="line">                 OSTickStepState = OS_TICK_STEP_DIS;</span><br><span class="line">                 <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step == OS_FALSE) &#123;                            /* Return <span class="keyword">if</span> waiting <span class="keyword">for</span> step <span class="built_in">command</span>           */</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        ptcb = OSTCBList;                                  /* Point at first TCB <span class="keyword">in</span> TCB list               */</span><br><span class="line">        <span class="keyword">while</span> (ptcb-&gt;OSTCBPrio != OS_TASK_IDLE_PRIO) &#123;     /* Go through all TCBs <span class="keyword">in</span> TCB list              */</span><br><span class="line">            OS_ENTER_CRITICAL();</span><br><span class="line">            <span class="keyword">if</span> (ptcb-&gt;OSTCBDly != 0) &#123;                     /* No, Delayed or waiting <span class="keyword">for</span> event with TO     */</span><br><span class="line">                <span class="keyword">if</span> (–ptcb-&gt;OSTCBDly == 0) &#123;               /* Decrement nbr of ticks to end of delay       */</span><br><span class="line">                                                           /* Check <span class="keyword">for</span> timeout                            */</span><br><span class="line">                    <span class="keyword">if</span> ((ptcb-&gt;OSTCBStat &amp; OS_STAT_PEND_ANY) != OS_STAT_RDY) &#123;</span><br><span class="line">                        ptcb-&gt;OSTCBStat  &amp;= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */</span><br><span class="line">                        ptcb-&gt;OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ptcb-&gt;OSTCBStatPend = OS_STAT_PEND_OK;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((ptcb-&gt;OSTCBStat &amp; OS_STAT_SUSPEND) == OS_STAT_RDY) &#123;  /* Is task suspended?       */</span><br><span class="line">                        OSRdyGrp               |= ptcb-&gt;OSTCBBitY;             /* No,  Make ready          */</span><br><span class="line">                        OSRdyTbl[ptcb-&gt;OSTCBY] |= ptcb-&gt;OSTCBBitX;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptcb = ptcb-&gt;OSTCBNext;                        /* Point at next TCB <span class="keyword">in</span> TCB list                */</span><br><span class="line">            OS_EXIT_CRITICAL();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明：本文参考嵌入式实时操作系统ucos教程</p>
]]></content>
      <categories>
        <category>ucos</category>
      </categories>
      <tags>
        <tag>ucos itter</tag>
      </tags>
  </entry>
  <entry>
    <title>ucos-scheduling</title>
    <url>/2018/08/03/ucos-scheduling/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>操作系统提供的一个基本功能就是多任务运行，而多个任务运行实质上是轮询占用CPU，这就涉及到任务之间的调度算法，而任务的调度就是利用中断来进行任务之间的切换，周期性进入中断函数，然后选择一个合适的任务运行就是操作系统的任务调度算法，调度算法决定了操作系统的好坏，因此调度算法是操作系统的一项核心功能，ucos操作系统是基于优先级的可剥夺内核调度，即任务的调度基于任务的优先级，同时高优先级可以抢占低优先级任务运行，因此，每个任务在运行完需要一个延时以将cpu资源让给其他低优先级任务。ucos的任务调度分为两种方式：一种是任务级的调度由函数OS_SChed()函数完成，另一种是中断级的调度由函数OSIntExt()函数完成，本文只分析任务级调度：</p>
<h3 id="OS-Sched函数："><a href="#OS-Sched函数：" class="headerlink" title="OS_Sched函数："></a>OS_Sched函数：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void  OS_Sched (void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if OS_CRITICAL_METHOD == 3    /* Allocate storage for CPU status register     */</span></span><br><span class="line">    OS_CPU_SR  cpu_sr = 0;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    OS_ENTER_CRITICAL();</span><br><span class="line">    <span class="keyword">if</span> (OSIntNesting == 0) &#123;   /* Schedule only <span class="keyword">if</span> all ISRs <span class="keyword">done</span> and ...  */</span><br><span class="line">        <span class="keyword">if</span> (OSLockNesting == 0) &#123; /* ... scheduler is not locked   */</span><br><span class="line">            OS_SchedNew();</span><br><span class="line">            <span class="keyword">if</span> (OSPrioHighRdy != OSPrioCur) &#123; /* No Ctx Sw <span class="keyword">if</span> current task is highest rdy  */</span><br><span class="line">                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];</span><br><span class="line"><span class="comment">#if OS_TASK_PROFILE_EN &gt; 0</span></span><br><span class="line">                OSTCBHighRdy-&gt;OSTCBCtxSwCtr++;  /* Inc. <span class="comment"># of context switches to this task  */</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">                OSCtxSwCtr++;   /* Increment context switch counter  */</span><br><span class="line">                OS_TASK_SW();     /* Perform a context switch  */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OS_EXIT_CRITICAL();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数主要完成以下工作：<br>1、定义关中断方式。</p>
<p>#if OS_CRITICAL_METHOD == 3 /* Allocate storage for CPU status register */<br>OS_CPU_SR cpu_sr = 0;</p>
<p>是定义第三种方法开关中断，这里插入讲解一下os开关中断的三种方式，<br>第一种是利用cpu自带的总中断寄存器来实现开关全局中断，优点是实现方便缺点是总中断有可能原本就是关着的，在调用完会将全局中断打开；<br>第二种开关全局中断的方式是利用堆栈保存中断的状态，关中断后恢复之前的中断状态，解决了第一种中断的弊端；<br>第三种方法是定义一个局部变量cpu_sr来保存PSW再关中断之后再恢复cpu_sr到PSW程序状态寄存器中。</p>
<p>2、关中断。<br>OS_ENTER_CRITICAL();就是关全局中断</p>
<p>3、判断是否在中断里或调度器是否上锁，是就执行一次调度<br>if (OSIntNesting == 0) { /* Schedule only if all ISRs done and … */<br>if (OSLockNesting == 0) </p>
<p>4、判断当前任务是否是就绪的最高优先级任务以减少任务调度带来的额外开销<br>if (OSPrioHighRdy != OSPrioCur)</p>
<p>5、将准备就绪的最高优先级任务指向该该任务的任务控制块<br>OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];</p>
<p>6、任务切换统计计数器加一<br>OSCtxSwCtr++; </p>
<p>7、任务切换<br>OS_TASK_SW(); </p>
<p>8、开中断<br>OS_EXIT_CRITICAL();</p>
<h3 id="OS-TASK-SW函数"><a href="#OS-TASK-SW函数" class="headerlink" title="OS_TASK_SW函数"></a>OS_TASK_SW函数</h3><p>下面介绍 OS_TASK_SW()函数，任务级调度其实就是认为模拟一次中断分两步进行，第一步是将被挂起任务的CPU寄存器压入堆栈，第二步是将准备就绪的最高优先级任务的寄存器从任务堆栈中恢复到寄存器中。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">OSCtxSw</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R0</span>, <span class="symbol">=NVIC_INT_CTRL</span> <span class="comment">; Trigger the PendSV exception (causes context switch)</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=NVIC_PENDSVSET</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line"><span class="keyword">BX</span> <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<p>OS_TASK_SW()是一个宏定义他实际上是OSCtxSw汇编代码的宏定义</p>
<p>NVIC_INT_CTRL EQU 0xE000ED04 ; Interrupt control state register.</p>
<p>NVIC_PENDSVSET EQU 0x10000000 ; Value to trigger PendSV exception.</p>
<p>这段汇编代码是为了触发PendSV 异常进入异常指令代码去执行，通过查询我们发现查询跳转到OS_CPU_PendSVHandler处执行，代码如下</p>
<h3 id="PendSV异常代码"><a href="#PendSV异常代码" class="headerlink" title="PendSV异常代码"></a>PendSV异常代码</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">OS_CPU_PendSVHandler</span></span><br><span class="line"><span class="keyword">CPSID</span> I <span class="comment">; Prevent interruption during context switch</span></span><br><span class="line"><span class="keyword">MRS</span> <span class="built_in">R0</span>, PSP <span class="comment">; PSP is process stack pointer</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R0</span>, OS_CPU_PendSVHandler_nosave <span class="comment">; Skip register save the first time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SUBS</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#0x20</span> <span class="comment">; Save remaining regs r4-11 on process stack</span></span><br><span class="line"><span class="keyword">STM</span> <span class="built_in">R0</span>, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=OSTCBCur</span> <span class="comment">; OSTCBCur-&gt;OSTCBStkPtr = SP;</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, [<span class="built_in">R1</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R1</span>] <span class="comment">; R0 is SP of process being switched out; At this point, entire context of process has been saved</span></span><br><span class="line"><span class="symbol">OS_CPU_PendSVHandler_nosave</span></span><br><span class="line"><span class="keyword">PUSH</span> &#123;<span class="built_in">R14</span>&#125; <span class="comment">; Save LR exc_return value</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R0</span>, <span class="symbol">=OSTaskSwHook</span> <span class="comment">; OSTaskSwHook();</span></span><br><span class="line"><span class="keyword">BLX</span> <span class="built_in">R0</span></span><br><span class="line"><span class="keyword">POP</span> &#123;<span class="built_in">R14</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R0</span>, <span class="symbol">=OSPrioCur</span> <span class="comment">; OSPrioCur = OSPrioHighRdy;</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=OSPrioHighRdy</span></span><br><span class="line"><span class="keyword">LDRB</span> <span class="built_in">R2</span>, [<span class="built_in">R1</span>]</span><br><span class="line"><span class="keyword">STRB</span> <span class="built_in">R2</span>, [<span class="built_in">R0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R0</span>, <span class="symbol">=OSTCBCur</span> <span class="comment">; OSTCBCur = OSTCBHighRdy;</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=OSTCBHighRdy</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, [<span class="built_in">R1</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R2</span>, [<span class="built_in">R0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R0</span>, [<span class="built_in">R2</span>] <span class="comment">; R0 is new process SP; SP = OSTCBHighRdy-&gt;OSTCBStkPtr;</span></span><br><span class="line"><span class="keyword">LDM</span> <span class="built_in">R0</span>, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>&#125; <span class="comment">; Restore r4-11 from new process stack</span></span><br><span class="line"><span class="keyword">ADDS</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#0x20</span></span><br><span class="line"><span class="keyword">MSR</span> PSP, <span class="built_in">R0</span> <span class="comment">; Load PSP with new process SP</span></span><br><span class="line"><span class="keyword">ORR</span> <span class="built_in">LR</span>, <span class="built_in">LR</span>, <span class="number">#0x04</span> <span class="comment">; Ensure exception return uses process stack</span></span><br><span class="line"><span class="keyword">CPSIE</span> I</span><br><span class="line"><span class="keyword">BX</span> <span class="built_in">LR</span> <span class="comment">; Exception return will restore remaining context</span></span><br><span class="line"><span class="symbol">END</span></span><br></pre></td></tr></table></figure>
<p>总结起来就是将当前寄存器保存到当前查询堆栈中，</p>
<p>OSTCPHightRdy-&gt;OSTCBsTKpTR</p>
<p>获取到就绪态最高优先级任务的SP并将其恢复到CPU SP寄存器中将其他寄存器弹出执行中断返回，当前寄存器环境sp，pc等就是要切换任务的环境值，运行代码就是切换后的任务，操作系统实现了任务调度。</p>
<p>声明： 本文参考嵌入式实时操作系统ucos-ii教程</p>
]]></content>
      <categories>
        <category>ucos</category>
      </categories>
      <tags>
        <tag>ucos scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>ucos-statisticattask</title>
    <url>/2018/08/03/ucos-statisticattask/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ucos计算CPU利用率的实现方法是：</p>
<p>1、在运行任务之前计算出空闲任务运行的最大速率OSIdleCtrMax；</p>
<p>2、求出任务运行时空闲任务计数器的计数速率OSIdleCtr；</p>
<p>3、利用公式求出CPU利用率就是OSIdleCtr/OSIdleCtrMax * 100% </p>
<p>就是通过计算cpu进入空闲任务的比例来推算出cpu利用率。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>其代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if OS_TASK_STAT_EN &gt; 0</span></span><br><span class="line">void  OS_TaskStat (void *p_arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */</span></span><br><span class="line">    OS_CPU_SR  cpu_sr = 0;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    (void)p_arg;                                 /* Prevent compiler warning <span class="keyword">for</span> not using <span class="string">&#x27;p_arg&#x27;</span>     */</span><br><span class="line">    <span class="keyword">while</span> (OSStatRdy == OS_FALSE) &#123;</span><br><span class="line">        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */</span><br><span class="line">    &#125;</span><br><span class="line">    OSIdleCtrMax /= 100L;</span><br><span class="line">    <span class="keyword">if</span> (OSIdleCtrMax == 0L) &#123;</span><br><span class="line">        OSCPUUsage = 0;</span><br><span class="line">        (void)OSTaskSuspend(OS_PRIO_SELF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        OS_ENTER_CRITICAL();</span><br><span class="line">        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter <span class="keyword">for</span> the past second */</span><br><span class="line">        OSIdleCtr    = 0L;                       /* Reset the idle counter <span class="keyword">for</span> the next second         */</span><br><span class="line">        OS_EXIT_CRITICAL();</span><br><span class="line">        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);</span><br><span class="line">        OSTaskStatHook();                        /* Invoke user definable hook                         */</span><br><span class="line"><span class="comment">#if (OS_TASK_STAT_STK_CHK_EN &gt; 0) &amp;&amp; (OS_TASK_CREATE_EXT_EN &gt; 0)</span></span><br><span class="line">        OS_TaskStatStkChk();                     /* Check the stacks <span class="keyword">for</span> each task                     */</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr <span class="keyword">for</span> the next 1/10 second      */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>代码结构和上一篇差不多，具体可以参考任务调度一文。<br>OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);这就是计算cpu利用率的公式了</p>
<p>声明：本文参考嵌入式实时操作系统ucos-ii教程</p>
]]></content>
      <categories>
        <category>ucos</category>
      </categories>
      <tags>
        <tag>ucos statisticat</tag>
      </tags>
  </entry>
  <entry>
    <title>ucos-synchronize</title>
    <url>/2018/08/05/ucos-synchronize/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>操作系统提供的一项重要功能是同步，由于每个任务之间的运行是相互独立的，他们之间的协作就需要同步机制，同步分为两种，一种是行为同步，就是任务之间的先后顺序，例如任务B的运行需要任务A的运行结果那么就需要在任务A运行后再进行任务B的运行，这就是行为同步，另一种是资源同步，就是两个任务或多个任务对共享资源的访问，或一个任务的运行条件需要另一个任务提供一些信息这都是同步。</p>
<h3 id="行为同步"><a href="#行为同步" class="headerlink" title="行为同步"></a>行为同步</h3><p>可以实现ucos的行为同步有信号量，互斥信号量和时间标志组。<br>首先讲一下互斥信号量：互斥信号量用于同步两个任务，而互斥信号量特有的性能是优先级反转机制。例如任务A比任务B优先级高，任务B在使用资源s此时高优先级任务A进入就绪态并获得运行权而任务A同样需要访问资源s，此时资源s被低优先级B占据着，高优先级任务将自己挂起让任务B运行，而此时任务C优先级高于B而低于A此时得到CPU运行权的是任务C这样等任务C运行完了以后再运行B最后才是高优先级A运行。这种情况将大大降低系统的实时性，高优先级任务并没能得到及时运行。假设任务A运行还需要共享资源s2，此时任务A获得资源s2请求资源s，cpu运行权给任务B，任务B占据着资源s同时请求资源s2，但此时资源s2被任务A占据着，任务B将运行权再给任务A，如此两个任务在来回切换却都得不到运行就造成死锁。而互斥信号量就是解决这些问题的，通过互斥信号量访问共享资源可以有效解决这些问题，而互斥信号量采用的解决办法是优先级反转机制就是将占据资源s的任务优先级升为最高优先级那么任务B将得到资源并运行结束结束时将优先级再设为原优先级，任务A得到运行，这样可以保证任务的正常运行。即任务在运行期间不会有其他任务运行以及抢占资源。<br>信号量则没有优先级反转机制但是信号量可以标示资源被几个任务使用，事件标志组就是一系列信号量的组合，信号量对信号有更多逻辑操作，例如任务A等待任务B和C两个任务的运行结果那么就是与的关系，只有任务B和C都完成了任务A才得到运行，另一种情况是任务A等待任务B和C中的一个发生那就是或的关系。事件标志组是信号量的集合。</p>
<h3 id="资源同步"><a href="#资源同步" class="headerlink" title="资源同步"></a>资源同步</h3><p>资源同步是两个任务对共享资源保持同步，方法有邮箱和消息队列。<br>可以类比行为同步，消息邮箱一次只能发送一个消息而消息队列则是消息邮箱的集合可以发送多个数据，具体就不多说了可以类比行为同步去理解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有的同步都是建立在消息的生产者的产生速度小于消费者的消费速度上的，否则将会有消息丢弃。另外在只需要发送一个消息时若消息发放速度有时会高于消息执行速度但整体速度低于消息执行速度那需要采用消息队列方式发送消息。在选择消息发送方式时需要考虑较多问题因此，消息同步需要慎重选择。</p>
]]></content>
      <categories>
        <category>ucos</category>
      </categories>
      <tags>
        <tag>ucos synchronize</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-atomic</title>
    <url>/2019/08/19/zephyr-atomic/</url>
    <content><![CDATA[<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>操作系统一般都会提供原子操作，而实现原子操作的原理也很简单，在set一个变量的时候只要不进行任务切换和不进行中断处理就不会被中断那么操作也就是原子的，而任务切换有两种方式一种主动切换另一种在时钟中断中切换，因此只要我们保证所有中断不发生就可以保证操作是原子的。</p>
<p><strong>z_impl_atomic_add</strong></p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">atomic_val_t z_impl_atomic_add(atomic_t *<span class="built_in">target</span>, atomic_val_t value)</span><br><span class="line">&#123;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line">	atomic_val_t ret;</span><br><span class="line"></span><br><span class="line">	key = k_spin_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">	ret = *<span class="built_in">target</span>;</span><br><span class="line">	*<span class="keyword">target +=</span> value;</span><br><span class="line"></span><br><span class="line">	k_spin_unlock(&amp;lock, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>z_impl_atomic_sub</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">atomic_val_t z<span class="constructor">_impl_atomic_sub(<span class="params">atomic_t</span> <span class="operator">*</span><span class="params">target</span>, <span class="params">atomic_val_t</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line">	atomic_val_t ret;</span><br><span class="line"></span><br><span class="line">	key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">	ret = *target;</span><br><span class="line">	*target -= value;</span><br><span class="line"></span><br><span class="line">	k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他操作类似，在操作的时候上锁关中断就可以了。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>atomic</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-brief</title>
    <url>/2018/08/05/zephyr-brief/</url>
    <content><![CDATA[<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>Zephyr™项目是一个采用Apache 2.0协议许可，Linux基金会托管的协作项目。为所有资源受限设备，构建了针对低功耗、小型内存微处理器设备而进行优化的物联网嵌入式小型、可扩展的实时操作系统（RTOS），支持多种硬件架构及多种开发板，可以在小至8 kB内存的系统上运行。网络协议支持丰富，支持Bluetooth®, Bluetooth® Low Energy, Wi-Fi*, 802.15.4，6Lowpan, CoAP, IPv4, IPv6, 和 NFC 等标准，通过社区驱动的发展来改进和增强功能。目前已经支持众多架构cpu包括ARM x86 ARC NIOS II 等RISCV32。</p>
<h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p>以Archlinux系统为例，首先更新系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -Syu</span><br></pre></td></tr></table></figure>
<p>安装软件依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -S git cmake ninja-build gperf \</span><br><span class="line">$  ccache doxygen dfu-util device-tree-compiler \</span><br><span class="line">$  python3-ply python3-pip python3-setuptools python3-wheel xz-utils file \</span><br><span class="line">$  make gcc-multilib autoconf automake libtool</span><br></pre></td></tr></table></figure>
<p>安装cmake</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -S cmake</span><br></pre></td></tr></table></figure>
<p>安装SDK</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.10.2/zephyr-sdk-0.10.2-setup.run</span><br><span class="line">$ <span class="built_in">cd</span> &lt;sdk download directory&gt;</span><br><span class="line">$ ./zephyr-sdk-0.10.2-setup.run -- -d ~/zephyr-sdk-0.10.2</span><br></pre></td></tr></table></figure>
<p>导出环境变量</p>
<ul>
<li>set ZEPHYR_TOOLCHAIN_VARIANT to zephyr</li>
<li>set ZEPHYR_SDK_INSTALL_DIR to $HOME/zephyr-sdk-0.10.2 (or wherever you chose to install the SDK)</li>
</ul>
<p>安装west</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux</span></span><br><span class="line">pip3 install --user -U west</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS (Terminal) and Windows (cmd.exe)</span></span><br><span class="line">pip3 install -U west</span><br></pre></td></tr></table></figure>
<ul>
<li>On Linux, make sure ~/.local/bin is on your PATH environment variable</li>
</ul>
<p>克隆源码设置环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ west init zephyrproject</span><br><span class="line">$ <span class="built_in">cd</span> zephyrproject</span><br><span class="line">$ west update</span><br><span class="line">$ <span class="built_in">cd</span> zephyr</span><br><span class="line"><span class="comment"># Linux</span></span><br><span class="line">$ pip3 install --user -r scripts/requirements.txt</span><br><span class="line"><span class="comment"># macOS and Windows</span></span><br><span class="line">pip3 install -r scripts/requirements.txt</span><br><span class="line">$ <span class="built_in">source</span> zephyr-env.sh</span><br></pre></td></tr></table></figure>
<p>编译helloword程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$ZEPHYR_BASE</span>/samples/hello_world</span><br><span class="line">$ <span class="built_in">export</span> BOARD=nucleo_f103rb</span><br><span class="line">$ cmake -B build/ -H.</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>安装stlink</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -S libusb-dev</span><br><span class="line">$ <span class="comment"># so easy in archlinux</span></span><br></pre></td></tr></table></figure>
<p>烧录程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ st-flash write zephyr/zephyr.bin 0x8000000</span><br></pre></td></tr></table></figure>
<p>好了，开始你的zephyr之旅吧，goog luck O(∩_∩)O哈哈~</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>zephyr</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-dList</title>
    <url>/2019/08/22/zephyr-dList/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>链表是最常用的数据结构之一，zephyr的kernel里很多机制的实现都使用到链表这个数据结构。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct _dnode &#123;</span><br><span class="line">	union &#123;</span><br><span class="line">		struct _dnode *head; /* ptr to head of list (sys_dlist_t) */</span><br><span class="line">		struct _dnode *next; /* ptr to next node    (sys_dnode_t) */</span><br><span class="line">	&#125;;</span><br><span class="line">	union &#123;</span><br><span class="line">		struct _dnode *tail; /* ptr to tail of list (sys_dlist_t) */</span><br><span class="line">		struct _dnode *prev; /* ptr to previous node (sys_dnode_t) */</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct _dnode sys_dlist_t;</span><br><span class="line">typedef struct _dnode sys_dnode_t;</span><br></pre></td></tr></table></figure>
<p>这里使用了一个联合体，这样list和node就不需要单独定义两个结构体了，通过一个typedef起两个别名来方便辨别是list还是node。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list头和尾都指向自己</span><br><span class="line">static inline void sys_dlist_init(sys_dlist_t *list)</span><br><span class="line">&#123;</span><br><span class="line">	list-&gt;head = (sys_dnode_t *)list;</span><br><span class="line">	list-&gt;tail = (sys_dnode_t *)list;</span><br><span class="line">&#125;</span><br><span class="line">node初始化为空</span><br><span class="line">static inline void sys_dnode_init(sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = NULL;</span><br><span class="line">	node-&gt;prev = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = list;</span><br><span class="line">	node-&gt;prev = list-&gt;tail;</span><br><span class="line"></span><br><span class="line">	list-&gt;tail-&gt;next = node;</span><br><span class="line">	list-&gt;tail = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = list-&gt;head;</span><br><span class="line">	node-&gt;prev = list;</span><br><span class="line"></span><br><span class="line">	list-&gt;head-&gt;prev = node;</span><br><span class="line">	list-&gt;head = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;prev = successor-&gt;prev;</span><br><span class="line">	node-&gt;next = successor;</span><br><span class="line">	successor-&gt;prev-&gt;next = node;</span><br><span class="line">	successor-&gt;prev = node;</span><br><span class="line">&#125;</span><br><span class="line">static inline void __deprecated sys_dlist_insert_after(sys_dlist_t *list,</span><br><span class="line">	sys_dnode_t *insert_point, sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (insert_point == NULL) &#123;</span><br><span class="line">		sys_dlist_prepend(list, node);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node-&gt;next = insert_point-&gt;next;</span><br><span class="line">		node-&gt;prev = insert_point;</span><br><span class="line">		insert_point-&gt;next-&gt;prev = node;</span><br><span class="line">		insert_point-&gt;next = node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void __deprecated sys_dlist_insert_before(sys_dlist_t *list,</span><br><span class="line">	sys_dnode_t *insert_point, sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (insert_point == NULL) &#123;</span><br><span class="line">		sys_dlist_append(list, node);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node-&gt;prev = insert_point-&gt;prev;</span><br><span class="line">		node-&gt;next = insert_point;</span><br><span class="line">		insert_point-&gt;prev-&gt;next = node;</span><br><span class="line">		insert_point-&gt;prev = node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static inline void sys_dlist_remove(sys_dnode_t *node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">	node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">	sys_dnode_init(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)</span><br><span class="line">&#123;</span><br><span class="line">	sys_dnode_t *node = NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sys_dlist_is_empty(list)) &#123;</span><br><span class="line">		node = list-&gt;head;</span><br><span class="line">		sys_dlist_remove(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-mbox</title>
    <url>/2019/08/18/zephyr-mbox/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>消息邮箱是线程间复杂的通信方式，通信双方是知道对方的，在通信过程中会校验消息，是否是发送给自己的，且消息邮箱提供通信保障，发送速度不能大于消息消耗速度。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @defgroup mailbox_apis Mailbox APIs</span><br><span class="line"> * @ingroup kernel_apis</span><br><span class="line"> * @&#123;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct k_mbox_msg &#123;</span><br><span class="line">	/** internal use only - needed <span class="keyword">for</span> legacy API support */</span><br><span class="line">	u32_t _mailbox;</span><br><span class="line">	/** size of message (<span class="keyword">in</span> bytes) */</span><br><span class="line">	size_t size;</span><br><span class="line">	/** application-defined information value */</span><br><span class="line">	u32_t info;</span><br><span class="line">	/** sender<span class="string">&#x27;s message data buffer */</span></span><br><span class="line"><span class="string">	void *tx_data;</span></span><br><span class="line"><span class="string">	/** internal use only - needed for legacy API support */</span></span><br><span class="line"><span class="string">	void *_rx_data;</span></span><br><span class="line"><span class="string">	/** message data block descriptor */</span></span><br><span class="line"><span class="string">	struct k_mem_block tx_block;</span></span><br><span class="line"><span class="string">	/** source thread id */</span></span><br><span class="line"><span class="string">	k_tid_t rx_source_thread;</span></span><br><span class="line"><span class="string">	/** target thread id */</span></span><br><span class="line"><span class="string">	k_tid_t tx_target_thread;</span></span><br><span class="line"><span class="string">	/** internal use only - thread waiting on send (may be a dummy) */</span></span><br><span class="line"><span class="string">	k_tid_t _syncing_thread;</span></span><br><span class="line"><span class="string">#if (CONFIG_NUM_MBOX_ASYNC_MSGS &gt; 0)</span></span><br><span class="line"><span class="string">	/** internal use only - semaphore used during asynchronous send */</span></span><br><span class="line"><span class="string">	struct k_sem *_async_sem;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct k_mbox &#123;</span></span><br><span class="line"><span class="string">	_wait_q_t tx_msg_queue;</span></span><br><span class="line"><span class="string">	_wait_q_t rx_msg_queue;</span></span><br><span class="line"><span class="string">	struct k_spinlock lock;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	_OBJECT_TRACING_NEXT_PTR(k_mbox)</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Send a mailbox message.</span><br><span class="line"> *</span><br><span class="line"> * Helper routine that handles both synchronous and asynchronous sends.</span><br><span class="line"> *</span><br><span class="line"> * @param mbox Pointer to the mailbox object.</span><br><span class="line"> * @param tx_msg Pointer to transmit message descriptor.</span><br><span class="line"> * @param timeout Maximum time (milliseconds) to <span class="built_in">wait</span> <span class="keyword">for</span> the message to be</span><br><span class="line"> *        received (although not necessarily completely processed).</span><br><span class="line"> *        Use K_NO_WAIT to <span class="built_in">return</span> immediately, or K_FOREVER to <span class="built_in">wait</span> as long</span><br><span class="line"> *        as necessary.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">return</span> 0 <span class="keyword">if</span> successful, -ENOMSG <span class="keyword">if</span> failed immediately, -EAGAIN <span class="keyword">if</span> timed out</span><br><span class="line"> */</span><br><span class="line">static int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,</span><br><span class="line">			     s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	struct k_thread *sending_thread;</span><br><span class="line">	struct k_thread *receiving_thread;</span><br><span class="line">	struct k_mbox_msg *rx_msg;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line"></span><br><span class="line">	/* save sender id so it can be used during message matching */</span><br><span class="line">	tx_msg-&gt;rx_source_thread = _current;</span><br><span class="line"></span><br><span class="line">	/* finish readying sending thread (actual or dummy) <span class="keyword">for</span> send */</span><br><span class="line">	sending_thread = tx_msg-&gt;_syncing_thread;</span><br><span class="line">	sending_thread-&gt;base.swap_data = tx_msg;</span><br><span class="line"></span><br><span class="line">	/* search mailbox<span class="string">&#x27;s rx queue for a compatible receiver */</span></span><br><span class="line"><span class="string">	key = k_spin_lock(&amp;mbox-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* 查找有没有因等待消息邮箱而挂起的线程，如果有则执行下面程序*/</span></span><br><span class="line"><span class="string">	_WAIT_Q_FOR_EACH(&amp;mbox-&gt;rx_msg_queue, receiving_thread) &#123;</span></span><br><span class="line"><span class="string">		rx_msg = (struct k_mbox_msg *)receiving_thread-&gt;base.swap_data;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		/* 匹配发送的消息是不是挂起的线程请求的消息如果是则唤起线程，如果不是则进行下一轮循环 */</span></span><br><span class="line"><span class="string">		if (mbox_message_match(tx_msg, rx_msg) == 0) &#123;</span></span><br><span class="line"><span class="string">			/* take receiver out of rx queue */</span></span><br><span class="line"><span class="string">			z_unpend_thread(receiving_thread);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			/* ready receiver for execution */</span></span><br><span class="line"><span class="string">			z_set_thread_return_value(receiving_thread, 0);</span></span><br><span class="line"><span class="string">			z_ready_thread(receiving_thread);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			/* 如果定义CONFIG_NUM_MBOX_ASYNC_MSGS则立即执行调度 */</span></span><br><span class="line"><span class="string">#if (CONFIG_NUM_MBOX_ASYNC_MSGS &gt; 0)</span></span><br><span class="line"><span class="string">			/*</span></span><br><span class="line"><span class="string">			 * asynchronous send: swap out current thread</span></span><br><span class="line"><span class="string">			 * if receiver has priority, otherwise let it continue</span></span><br><span class="line"><span class="string">			 *</span></span><br><span class="line"><span class="string">			 * note: dummy sending thread sits (unqueued)</span></span><br><span class="line"><span class="string">			 * until the receiver consumes the message</span></span><br><span class="line"><span class="string">			 */</span></span><br><span class="line"><span class="string">			if ((sending_thread-&gt;base.thread_state &amp; _THREAD_DUMMY)!= 0U) &#123;</span></span><br><span class="line"><span class="string">				/*立即执行调度，然后返回意味着在异步通知中不会等待消息的接受而可以继续接收下一次的发送*/</span></span><br><span class="line"><span class="string">				z_reschedule(&amp;mbox-&gt;lock, key);</span></span><br><span class="line"><span class="string">				return 0;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">			/*</span></span><br><span class="line"><span class="string">			 * synchronous send: pend current thread (unqueued)</span></span><br><span class="line"><span class="string">			 * until the receiver consumes the message</span></span><br><span class="line"><span class="string">			 */</span></span><br><span class="line"><span class="string">			/* 同步传输消息则将自己挂起K_FOREVER，知道消息被接收才被唤起，继续工作 */</span></span><br><span class="line"><span class="string">			return z_pend_curr(&amp;mbox-&gt;lock, key, NULL, K_FOREVER);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* didn&#x27;</span>t find a matching receiver: don<span class="string">&#x27;t wait for one */</span></span><br><span class="line"><span class="string">	if (timeout == K_NO_WAIT) &#123;</span></span><br><span class="line"><span class="string">		k_spin_unlock(&amp;mbox-&gt;lock, key);</span></span><br><span class="line"><span class="string">		return -ENOMSG;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#if (CONFIG_NUM_MBOX_ASYNC_MSGS &gt; 0)</span></span><br><span class="line"><span class="string">	/* asynchronous send: dummy thread waits on tx queue for receiver */</span></span><br><span class="line"><span class="string">	/* 在异步传输中发送消息后不会等待消息接收，但是在发送消息前需要等待上一次发送的消息被接收处理才能继续发送*/</span></span><br><span class="line"><span class="string">	if ((sending_thread-&gt;base.thread_state &amp; _THREAD_DUMMY) != 0U) &#123;</span></span><br><span class="line"><span class="string">		z_pend_thread(sending_thread, &amp;mbox-&gt;tx_msg_queue, K_FOREVER);</span></span><br><span class="line"><span class="string">		k_spin_unlock(&amp;mbox-&gt;lock, key);</span></span><br><span class="line"><span class="string">		return 0;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* 同步发送中因为发送后会等待接收完才进行下一步，等待接收或timeout */</span></span><br><span class="line"><span class="string">	/* synchronous send: sender waits on tx queue for receiver or timeout */</span></span><br><span class="line"><span class="string">	return z_pend_curr(&amp;mbox-&gt;lock, key, &amp;mbox-&gt;tx_msg_queue, timeout);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,</span><br><span class="line">	       s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	struct k_thread *sending_thread;</span><br><span class="line">	struct k_mbox_msg *tx_msg;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	/* save receiver id so it can be used during message matching */</span><br><span class="line">	rx_msg-&gt;tx_target_thread = _current;</span><br><span class="line"></span><br><span class="line">	/* search mailbox<span class="string">&#x27;s tx queue for a compatible sender */</span></span><br><span class="line"><span class="string">	key = k_spin_lock(&amp;mbox-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* 如果有发送线程挂起等待消息的接收则处理接收线程的消息，将线程从发送队列中删除，处理消息 */</span></span><br><span class="line"><span class="string">	_WAIT_Q_FOR_EACH(&amp;mbox-&gt;tx_msg_queue, sending_thread) &#123;</span></span><br><span class="line"><span class="string">		tx_msg = (struct k_mbox_msg *)sending_thread-&gt;base.swap_data;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if (mbox_message_match(tx_msg, rx_msg) == 0) &#123;</span></span><br><span class="line"><span class="string">			/* take sender out of mailbox&#x27;</span>s tx queue */</span><br><span class="line">			z_unpend_thread(sending_thread);</span><br><span class="line"></span><br><span class="line">			k_spin_unlock(&amp;mbox-&gt;lock, key);</span><br><span class="line"></span><br><span class="line">			/* consume message data immediately, <span class="keyword">if</span> needed */</span><br><span class="line">			<span class="built_in">return</span> mbox_message_data_check(rx_msg, buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* didn<span class="string">&#x27;t find a matching sender */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (timeout == K_NO_WAIT) &#123;</span></span><br><span class="line"><span class="string">		/* don&#x27;</span>t <span class="built_in">wait</span> <span class="keyword">for</span> a matching sender to appear */</span><br><span class="line">		k_spin_unlock(&amp;mbox-&gt;lock, key);</span><br><span class="line">		<span class="built_in">return</span> -ENOMSG;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 如果没有发送线程的消息则等待消息，直到收到或timeout */</span><br><span class="line">	/* <span class="built_in">wait</span> until a matching sender appears or a timeout occurs */</span><br><span class="line">	_current-&gt;base.swap_data = rx_msg;</span><br><span class="line">	result = z_pend_curr(&amp;mbox-&gt;lock, key, &amp;mbox-&gt;rx_msg_queue, timeout);</span><br><span class="line"></span><br><span class="line">	/* 接收到消息，立即处理 */</span><br><span class="line">	/* consume message data immediately, <span class="keyword">if</span> needed */</span><br><span class="line">	<span class="keyword">if</span> (result == 0) &#123;</span><br><span class="line">		result = mbox_message_data_check(rx_msg, buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>下面看下消息处理函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Dispose of received message.</span><br><span class="line"> *</span><br><span class="line"> * Releases any memory pool block still associated with the message,</span><br><span class="line"> * <span class="keyword">then</span> notifies the sender that message processing is complete.</span><br><span class="line"> *</span><br><span class="line"> * @param rx_msg Pointer to receive message descriptor.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">return</span> N/A</span><br><span class="line"> */</span><br><span class="line">static void mbox_message_dispose(struct k_mbox_msg *rx_msg)</span><br><span class="line">&#123;</span><br><span class="line">	struct k_thread *sending_thread;</span><br><span class="line">	struct k_mbox_msg *tx_msg;</span><br><span class="line"></span><br><span class="line">	/* <span class="keyword">do</span> nothing <span class="keyword">if</span> message was disposed of when it was received */</span><br><span class="line">	<span class="keyword">if</span> (rx_msg-&gt;_syncing_thread == NULL) &#123;</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* release sender<span class="string">&#x27;s memory pool block */</span></span><br><span class="line"><span class="string">	if (rx_msg-&gt;tx_block.data != NULL) &#123;</span></span><br><span class="line"><span class="string">		k_mem_pool_free(&amp;rx_msg-&gt;tx_block);</span></span><br><span class="line"><span class="string">		rx_msg-&gt;tx_block.data = NULL;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* recover sender info */</span></span><br><span class="line"><span class="string">	sending_thread = rx_msg-&gt;_syncing_thread;</span></span><br><span class="line"><span class="string">	rx_msg-&gt;_syncing_thread = NULL;</span></span><br><span class="line"><span class="string">	tx_msg = (struct k_mbox_msg *)sending_thread-&gt;base.swap_data;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* update data size field for sender */</span></span><br><span class="line"><span class="string">	tx_msg-&gt;size = rx_msg-&gt;size;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#if (CONFIG_NUM_MBOX_ASYNC_MSGS &gt; 0)</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * asynchronous send: free asynchronous message descriptor +</span></span><br><span class="line"><span class="string">	 * dummy thread pair, then give semaphore (if needed)</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if ((sending_thread-&gt;base.thread_state &amp; _THREAD_DUMMY) != 0U) &#123;</span></span><br><span class="line"><span class="string">		struct k_sem *async_sem = tx_msg-&gt;_async_sem;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		mbox_async_free((struct k_mbox_async *)sending_thread);</span></span><br><span class="line"><span class="string">		if (async_sem != NULL) &#123;</span></span><br><span class="line"><span class="string">			k_sem_give(async_sem);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* 在同步通信中，接收到消息并处理完消息后需要将发送线程设置为就绪态并执行线程调度 */</span></span><br><span class="line"><span class="string">	/* synchronous send: wake up sending thread */</span></span><br><span class="line"><span class="string">	z_set_thread_return_value(sending_thread, 0);</span></span><br><span class="line"><span class="string">	z_mark_thread_as_not_pending(sending_thread);</span></span><br><span class="line"><span class="string">	z_ready_thread(sending_thread);</span></span><br><span class="line"><span class="string">	z_reschedule_unlocked();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>消息邮箱可以保证在两个线程之间的通信而其他线程不会接收消息，消息双方是彼此知道的，即消息信息中包含彼此id。消息邮箱可以保证消息的生产速率不大于消息的消耗速率，级无论是同步还是异步消息传输都保证消息在接收并处理后才能继续发送消息，不同之处在于同步消息传输是发送完立即等待，直到消息被处理或超时才进行下一次消息发送和其他任务，而异步则发送完可以处理其他事，在下次发送前检查消息是否被处理，等待消息被处理后再发送。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>mailbox</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-mcuboot</title>
    <url>/2018/09/05/zephyr-mcuboot/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>mcuboot是嵌入式BootLoader，支持zephyr，Mynewt，RIOT操作系统，本文基于zephyr操作系统开发，主要用于嵌入式软件升级，在涉及到嵌入式设备需要实现固件升级时可以使用这个BootLoader方便开发。本文以stm32f103rc系列单片机为目标板分析。</p>
<h3 id="flash驱动"><a href="#flash驱动" class="headerlink" title="flash驱动"></a>flash驱动</h3><p>硬件平台为stm32f103系列芯片，由于升级需要操作嵌入式内部flash，所以必须现在zephyr里将mcu内部flash驱动调试好才能进行开发，有些芯片的内部flash驱动zephyr里已经实现，只需要配置下就可以，不幸的是f1没有实现那么需要自己写一个flash驱动，这里不做详细介绍只有一点需要注意，开HSI.</p>
<h3 id="FLASH分区"><a href="#FLASH分区" class="headerlink" title="FLASH分区"></a>FLASH分区</h3><p>本设计分区如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;flash0 &#123;</span><br><span class="line">    partitions &#123;</span><br><span class="line">            /*  </span><br><span class="line">            * If chosen<span class="string">&#x27;s zephyr,code-partion is unset, the image will be</span></span><br><span class="line"><span class="string">            * linked into the entire flash device.  If it points to an</span></span><br><span class="line"><span class="string">            * individual partition, the code will be linked to, and</span></span><br><span class="line"><span class="string">            * restricted to that partition.</span></span><br><span class="line"><span class="string">            */</span></span><br><span class="line"><span class="string">            compatible = &quot;fixed-partitions&quot;;</span></span><br><span class="line"><span class="string">            #address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="string">            #size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">            boot_partition: partition@0 &#123;</span></span><br><span class="line"><span class="string">            label = &quot;mcuboot&quot;;</span></span><br><span class="line"><span class="string">            reg = &lt;0x00000000 0x0000c000&gt;;</span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            slot0_partition: partition@c000 &#123;</span></span><br><span class="line"><span class="string">            label = &quot;image-0&quot;;</span></span><br><span class="line"><span class="string">            reg = &lt;0x0000c000 0x00011000&gt;;</span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            slot1_partition: partition@1d000 &#123;</span></span><br><span class="line"><span class="string">            label = &quot;image-1&quot;;</span></span><br><span class="line"><span class="string">            reg = &lt;0x0001d000 0x00011000&gt;;</span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            scratch_partition: partition@2e000 &#123;</span></span><br><span class="line"><span class="string">            label = &quot;image-scratch&quot;;</span></span><br><span class="line"><span class="string">            reg = &lt;0x0002e000 0x00011000&gt;;</span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">    &#125;;  </span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>即    mcuboot   0x0000 0000 - 0x0800 c000<br>    solt0      0x0800 c000 - 0x0801 d000<br>    solt1      0x0801 d000 - 0x0802 e000<br>    scratch      0x0802 e000 - 0x0803 f000<br>这是安全升级需要的分区，也就是在升级失败时可以回到升级前的固件</p>
<h3 id="mcuboot签名"><a href="#mcuboot签名" class="headerlink" title="mcuboot签名"></a>mcuboot签名</h3><h4 id="生成签名文件"><a href="#生成签名文件" class="headerlink" title="生成签名文件"></a>生成签名文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./scripts/imgtool.py keygen -k mykey.pem -t rsa-2048</span><br></pre></td></tr></table></figure>
<h4 id="配置签名-在文件prj-conf文件里"><a href="#配置签名-在文件prj-conf文件里" class="headerlink" title="配置签名(在文件prj.conf文件里)"></a>配置签名(在文件prj.conf文件里)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG_BOOT_SIGNATURE_KEY_FILE=<span class="string">&quot;mykey.pem&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="给固件添加头信息"><a href="#给固件添加头信息" class="headerlink" title="给固件添加头信息"></a>给固件添加头信息</h4><p>在将mcuboot和zephyr分别编译后下载到板子的对应分区，此时板子是启动不起来的，因为签名失败因此需要对固件进行签名，执行如下命令<br>./imgtool.py sign   –header-size 0x200  –align 2  –version 1.0  –slot-size 0x11000  –key ~/mcuboot/mykey.pem zephyr.bin signed.bin<br>开启mcuboot选项后固件的前0x200内容为空可以存放一些用户自己的信息以及签名，在本设计中添加了版本号1.0和签名信息。这样signed.bin就是带有头部信息的固件，将其烧录到slot0_partition分区就可以启动系统了。升级则是将升级固件放到slot1_partition分区，系统在启动时会自动检查升级的。</p>
<h4 id="自动升级"><a href="#自动升级" class="headerlink" title="自动升级"></a>自动升级</h4><p>开机运行自动检测slot1分区里的固件需要一些额外设置，可以采用两种方式，一种是在制作固件时将验证信息添加到固件里就是在签名的时候做如下参数调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./imgtool.py sign   --header-size 0x200  --align 1  --pad   --version 2.0  --slot-size 0x11000  --key ~/mcuboot/mykey.pem zephyr.bin sign.bin</span><br></pre></td></tr></table></figure>
<p>多了一个–pad这个参数选项实际上是在固件尾部添加如下信息：<br>        0xf395c277,<br>        0x7fefd260,<br>        0x0f505235,<br>        0x8079b62c,<br>还有一种方式就是在固件写到flash内部后调用boot_request_upgrade函数，该函数的实现在zephyr/subsys/dfu/boot/mcuboot.c文件里，函数实际上就是向分区末尾位置添加上述信息，当添加了上述信息后执行重启，mcuboot就可以检测出固件需要升级开始固件升级。</p>
<h3 id="mcuboot升级流程"><a href="#mcuboot升级流程" class="headerlink" title="mcuboot升级流程"></a>mcuboot升级流程</h3><p>sector data in slot 0 is copied into scratch, then erased<br>sector data in slot 1 is copied into slot 0, then erased<br>sector data in scratch is copied into slot 1<br>除了固件的移动外需要对固件信息进行验证，只有验证通过了才可以运行，详细信息到源码中查看吧，这里不一一列出了。</p>
<h3 id="烧录验证"><a href="#烧录验证" class="headerlink" title="烧录验证"></a>烧录验证</h3><p>烧录<br>先烧录固件到slot0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ st-flash write signed.bin 0x800c000</span><br></pre></td></tr></table></figure>
<p>测试烧录到slot1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ st-flash write sign.bin 0x801d000</span><br></pre></td></tr></table></figure>
<p>再烧录bootloader</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ st-flash write zephyr.bin 0x8000000</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>mcuboot</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-memPoll</title>
    <url>/2019/08/19/zephyr-memPoll/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>The following code defines and initializes a memory pool that has 3 blocks of 4096 bytes each, which can be partitioned into blocks as small as 64 bytes and is aligned to a 4-byte boundary. (That is, the memory pool supports block sizes of 4096, 1024, 256, and 64 bytes.) Observe that the macro defines all of the memory pool data structures, as well as its buffer.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">K_MEM_POOL_DEFINE(my_pool, 64, 4096, 3, 4);</span><br></pre></td></tr></table></figure>
<p>下面展开这个宏看下主要做了哪些工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char __aligned(4) _mpool_buf_my_pool[_ALIGN4(4096) * 3	\</span><br><span class="line">			  + _MPOOL_BITS_SIZE(4096, 64, 3)]; \</span><br><span class="line">struct sys_mem_pool_lvl _mpool_lvls_my_pool[Z_MPOOL_LVLS(4096, 64)]; \</span><br><span class="line">Z_STRUCT_SECTION_ITERABLE(k_mem_pool, my_pool) = &#123; \</span><br><span class="line">	.base = &#123;						\</span><br><span class="line">		.buf = _mpool_buf_my_pool,			\</span><br><span class="line">		.max_sz = _44(4096),			\</span><br><span class="line">		.n_max = 3,					\</span><br><span class="line">		.n_levels = Z_MPOOL_LVLS(4096, 64),		\</span><br><span class="line">		.levels = _mpool_lvls_my_pool,			\</span><br><span class="line">		.flags = SYS_MEM_POOL_KERNEL			\</span><br><span class="line">	&#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里单独展开这个宏定义</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">_MPOOL_BITS_SIZE(<span class="params">maxsz</span>, <span class="params">minsz</span>, <span class="params">nmax</span>)</span></span><br><span class="line"><span class="constructor">_MPOOL_BITS_SIZE(4096, 64, 3)</span></span><br><span class="line"><span class="constructor">Z_MPOOL_LBIT_BYTES(<span class="params">maxsz</span>, <span class="params">minsz</span>, 0, <span class="params">n_max</span>)</span></span><br><span class="line"><span class="constructor">Z_MPOOL_LBIT_BYTES(4096, 64, 0-15, 3)</span></span><br><span class="line">(<span class="constructor">Z_MPOOL_LVLS((4096)</span>, (<span class="number">64</span>)) &gt; (l) ? <span class="number">4</span><span class="operator"> * </span><span class="constructor">Z_MPOOL_LBIT_WORDS((3)</span>, l) : <span class="number">0</span>)</span><br><span class="line"><span class="constructor">__MPOOL_LVLS((4096)</span>, (<span class="number">64</span>) &gt;= _MPOOL_MINBLK ? (<span class="number">64</span>) : _MPOOL_MINBLK)</span><br><span class="line"><span class="constructor">Z_MPOOL_HAVE_LVL((4096)</span>, (<span class="number">64</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>由于正向查看层次比较深，不好理解因此反向查看更容易理清这个宏定义<br>Z_MPOOL_HAVE_LVL(4096, 64, 1-15) (((4096) &gt;&gt; (2*(l-15))) &gt;= (64) ? 1 : 0)<br>可以看到__MPOOL_LVLS(maxsz, minsz)这个宏定义最后得到的是maxsz里面可以分多少级minsz即对4096进行递归二等分，可以分配多少次，即lev的最大等级。现在回到上一级继续看。Z_MPOOL_LVLS<br>__MPOOL_LVLS((maxsz), (minsz) &gt;= _MPOOL_MINBLK ? (minsz) : _MPOOL_MINBLK)<br>注意里面的括号关系，这个是保证minsz不能小于最小分配大小，这里没有影响，结果同上一步为6，下面继续</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">Z_MPOOL_LBIT_BYTES(<span class="params">maxsz</span>, <span class="params">minsz</span>, <span class="params">l</span>, <span class="params">n_max</span>)</span>	\</span><br><span class="line">	(<span class="constructor">Z_MPOOL_LVLS((<span class="params">maxsz</span>)</span>, (minsz)) &gt; (l) ?		\</span><br><span class="line">	 <span class="number">4</span><span class="operator"> * </span><span class="constructor">Z_MPOOL_LBIT_WORDS((<span class="params">n_max</span>)</span>, l) : <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>不同级别的内存需要多少byte表示，_MPOOL_BITS_SIZE将其累计得到，分配的内存需要的位图数组大小，整体就是定义一个需要的大小的内存以及另外需要用来表示这段内存使用情况的内存，然后是定义一个结构图数组，数组大小是lvs层次级数，每一个结构体数组成员管理相应等级内存，例如这个内存区域可以分6个等级，那么就有6个结构图，每个结构图管理一个等级的内存levs。最后定义并初始化一个k_mem_pool结构体，这个结构图存放在指定段中，base的buf指向上面分配的第一个内存数组，n_levels保存等级数，其他成员保存其他相应信息。</p>
<p>一个宏定义牵扯出多少故事来啊，O(∩_∩)O哈哈~</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">k_mem_pool_alloc</span><span class="params">(struct k_mem_pool *p, struct k_mem_block *block,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">s32_t</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">s64_t</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__ASSERT(!(z_is_in_isr() &amp;&amp; timeout != K_NO_WAIT), <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">end</span> = z_tick_get() + z_ms_to_ticks(timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">u32_t</span> level_num, block_num;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* There is a &quot;managed race&quot; in alloc that can fail</span></span><br><span class="line"><span class="comment">		 * (albeit in a well-defined way, see comments there)</span></span><br><span class="line"><span class="comment">		 * with -EAGAIN when simultaneous allocations happen.</span></span><br><span class="line"><span class="comment">		 * Retry exactly once before sleeping to resolve it.</span></span><br><span class="line"><span class="comment">		 * If we&#x27;re so contended that it fails twice, then we</span></span><br><span class="line"><span class="comment">		 * clearly want to block.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">         <span class="comment">/* 有可能分配失败，如果第一次分配失败的话尝试分配两次*/</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">			ret = z_sys_mem_pool_block_alloc(&amp;p-&gt;base, <span class="built_in">size</span>,</span><br><span class="line">							&amp;level_num, &amp;block_num,</span><br><span class="line">							&amp;block-&gt;data);</span><br><span class="line">			<span class="keyword">if</span> (ret != -EAGAIN) &#123;</span><br><span class="line">                <span class="comment">/* 分配成功*/</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret == -EAGAIN) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置分配到的level，block，id等*/</span></span><br><span class="line">		block-&gt;id.pool = pool_id(p);</span><br><span class="line">		block-&gt;id.level = level_num;</span><br><span class="line">		block-&gt;id.block = block_num;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span> || timeout == K_NO_WAIT ||</span><br><span class="line">		    ret != -ENOMEM) &#123;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 分配失败 挂起线程 */</span></span><br><span class="line">		z_pend_curr_unlocked(&amp;p-&gt;wait_q, timeout);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timeout != K_FOREVER) &#123;</span><br><span class="line">			timeout = <span class="built_in">end</span> - z_tick_get();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面涉及一个比较重要的函数z_sys_mem_pool_block_alloc如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">z_sys_mem_pool_block_alloc</span><span class="params">(struct sys_mem_pool_base *p, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">u32_t</span> *level_p, <span class="keyword">u32_t</span> *block_p, <span class="keyword">void</span> **data_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, from_l, alloc_l = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> lsizes[LVL_ARRAY_SZ(p-&gt;n_levels)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Walk down through levels, finding the one from which we</span></span><br><span class="line"><span class="comment">	 * want to allocate and the smallest one with a free entry</span></span><br><span class="line"><span class="comment">	 * from which we can split an allocation if needed.  Along the</span></span><br><span class="line"><span class="comment">	 * way, we populate an array of sizes for each level so we</span></span><br><span class="line"><span class="comment">	 * don&#x27;t need to waste RAM storing it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">      * 从高到底的等级分配策略，即尽可能在刚好比size大的那个等级下划分，</span></span><br><span class="line"><span class="comment">      * 对于剩余的小内存在更低等级下划分，尽可能的利用号内存 </span></span><br><span class="line"><span class="comment">      * 找到稍比size的level存入alloc_l</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">	lsizes[<span class="number">0</span>] = p-&gt;max_sz;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;n_levels; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			lsizes[i] = _ALIGN4(lsizes[i<span class="number">-1</span>] / <span class="number">4</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lsizes[i] &lt; <span class="built_in">size</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		alloc_l = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		*data_p = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now walk back down the levels (i.e. toward bigger sizes)</span></span><br><span class="line"><span class="comment">	 * looking for an available block.  Start at the smallest</span></span><br><span class="line"><span class="comment">	 * enclosing block found above (note that because that loop</span></span><br><span class="line"><span class="comment">	 * was done without synchronization, it may no longer be</span></span><br><span class="line"><span class="comment">	 * available!) as a useful optimization.  Note that the</span></span><br><span class="line"><span class="comment">	 * removal of the block from the list and the re-addition of</span></span><br><span class="line"><span class="comment">	 * its the three unused children needs to be performed</span></span><br><span class="line"><span class="comment">	 * atomically, otherwise we open up a situation where we can</span></span><br><span class="line"><span class="comment">	 * &quot;steal&quot; the top level block of the whole heap, causing a</span></span><br><span class="line"><span class="comment">	 * spurious -ENOMEM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">/* 找到最小level后开始迭代在level_l之下的这些等级块中分配内存 */</span></span><br><span class="line">	key = pool_irq_lock(p);</span><br><span class="line">	<span class="keyword">for</span> (i = alloc_l; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		data = block_alloc(p, i, lsizes[i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Found one.  Iteratively break it down to the size</span></span><br><span class="line"><span class="comment">		 * we need.  Note that we relax the lock to allow a</span></span><br><span class="line"><span class="comment">		 * pending interrupt to fire so we don&#x27;t hurt latency</span></span><br><span class="line"><span class="comment">		 * by locking the full loop.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (from_l = i; from_l &lt; alloc_l; from_l++) &#123;</span><br><span class="line">				data = block_break(p, data, from_l, lsizes);</span><br><span class="line">				pool_irq_unlock(p, key);</span><br><span class="line">				key = pool_irq_lock(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pool_irq_unlock(p, key);</span><br><span class="line"></span><br><span class="line">	*data_p = data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*level_p = alloc_l;</span><br><span class="line">	*block_p = block_num(p, data, lsizes[alloc_l]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><p>k_mem_pool_free调用k_mem_pool_free_id释放内存，函数如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> need_sched = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> k_mem_pool *p = get<span class="constructor">_pool(<span class="params">id</span>-&gt;<span class="params">pool</span>)</span>;</span><br><span class="line"></span><br><span class="line">z<span class="constructor">_sys_mem_pool_block_free(&amp;<span class="params">p</span>-&gt;<span class="params">base</span>, <span class="params">id</span>-&gt;<span class="params">level</span>, <span class="params">id</span>-&gt;<span class="params">block</span>)</span>;</span><br><span class="line">       size_t lsizes<span class="literal">[LVL<span class="identifier">_ARRAY_SZ</span>(<span class="identifier">p</span>-&gt;<span class="identifier">n_levels</span>)]</span>;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* As in z_sys_mem_pool_block_alloc(), we build a table of level sizes</span></span><br><span class="line"><span class="comment">     * to avoid having to store it in precious RAM bytes.</span></span><br><span class="line"><span class="comment">     * Overhead here is somewhat higher because block_free()</span></span><br><span class="line"><span class="comment">     * doesn&#x27;t inherently need to traverse all the larger</span></span><br><span class="line"><span class="comment">     * sublevels.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lsizes<span class="literal">[<span class="number">0</span>]</span> = p-&gt;max_sz;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= level; i++) &#123;</span><br><span class="line">    	lsizes<span class="literal">[<span class="identifier">i</span>]</span> = <span class="constructor">_ALIGN4(<span class="params">lsizes</span>[<span class="params">i</span>-1] <span class="operator">/</span> 4)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">block<span class="constructor">_free(<span class="params">p</span>, <span class="params">level</span>, <span class="params">lsizes</span>, <span class="params">block</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wake up anyone blocked on this pool and let them repeat</span></span><br><span class="line"><span class="comment"> * their allocation attempts</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (Note that this spinlock only exists because z_unpend_all()</span></span><br><span class="line"><span class="comment"> * is unsynchronized.  Maybe we want to put the lock into the</span></span><br><span class="line"><span class="comment"> * wait_q instead and make the API safe?)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">k_spinlock_key_t key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">need_sched = z<span class="constructor">_unpend_all(&amp;<span class="params">p</span>-&gt;<span class="params">wait_q</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (need_sched != <span class="number">0</span>) &#123;</span><br><span class="line">	z<span class="constructor">_reschedule(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放通过id释放，在分配的时候已经将其标识过了，现在只需要通过这些标识找到对应的内存区域释放即可。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>引用官方文档的一段话，这个比较清晰<br>A memory pool’s buffer is an array of maximum-size blocks, with no wasted space between the blocks. Each of these “level 0” blocks is a quad-block that can be partitioned into four smaller “level 1” blocks of equal size, if needed. Likewise, each level 1 block is itself a quad-block that can be partitioned into four smaller “level 2” blocks in a similar way, and so on. Thus, memory pool blocks can be recursively partitioned into quarters until blocks of the minimum size are obtained, at which point no further partitioning can occur.</p>
<p>A memory pool keeps track of how its buffer space has been partitioned using an array of block set data structures. There is one block set for each partitioning level supported by the pool, or (to put it another way) for each block size. A block set keeps track of all free blocks of its associated size using an array of quad-block status data structures.</p>
<p>When an application issues a request for a memory block, the memory pool first determines the size of the smallest block that will satisfy the request, and examines the corresponding block set. If the block set contains a free block, the block is marked as used and the allocation process is complete. If the block set does not contain a free block, the memory pool attempts to create one automatically by splitting a free block of a larger size or by merging free blocks of smaller sizes; if a suitable block can’t be created, the allocation request fails.</p>
<p>The memory pool’s merging algorithm cannot combine adjacent free blocks of different sizes, nor can it merge adjacent free blocks of the same size if they belong to different parent quad-blocks. As a consequence, memory fragmentation issues can still be encountered when using a memory pool.</p>
<p>When an application releases a previously allocated memory block it is combined synchronously with its three “partner” blocks if possible, and recursively so up through the levels. This is done in constant time, and quickly, so no manual “defragmentation” management is needed.官方文档的一段，比较清楚了</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>memory poll kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-memSlab</title>
    <url>/2019/08/19/zephyr-memSlab/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>memory slab提供了在一个内存块内进行分配内存的手段，只能分配相同大小内存块，连续分配不会造成内存碎片话。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct k_mem_slab &#123;</span><br><span class="line">	_wait_q_t wait_q;</span><br><span class="line">	u32_t num_blocks;</span><br><span class="line">	size_t block_size;</span><br><span class="line">	char *buffer;</span><br><span class="line">	char *free_list;</span><br><span class="line">	u32_t num_used;</span><br><span class="line"></span><br><span class="line">	_OBJECT_TRACING_NEXT_PTR(k_mem_slab)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化实质上是连续分配block_size × num_blocks大小内存，这片内存将是后面alloc和free的内存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void k_mem_slab_init(struct k_mem_slab *slab, void *buffer,</span><br><span class="line">		    size_t block_size, u32_t num_blocks)</span><br><span class="line">&#123;</span><br><span class="line">	slab-&gt;num_blocks = num_blocks;</span><br><span class="line">	slab-&gt;block_size = block_size;</span><br><span class="line">	slab-&gt;buffer = buffer;</span><br><span class="line">	slab-&gt;num_used = 0U;</span><br><span class="line">    /* 创建free_list表，表格为free_list指向可用内存位置，buffer里的内如为每个内存位置里保存上个可用内存地址*/</span><br><span class="line">	create_free_list(slab);</span><br><span class="line">        slab-&gt;free_list = NULL;</span><br><span class="line">	    p = slab-&gt;buffer;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">for</span> (j = 0U; j &lt; slab-&gt;num_blocks; j++) &#123;</span><br><span class="line">	    	*(char **)p = slab-&gt;free_list;</span><br><span class="line">	    	slab-&gt;free_list = p;</span><br><span class="line">	    	p += slab-&gt;block_size;</span><br><span class="line">	    &#125;</span><br><span class="line">    /* 初始化等待队列 */</span><br><span class="line">	z_waitq_init(&amp;slab-&gt;wait_q);</span><br><span class="line">	SYS_TRACING_OBJ_INIT(k_mem_slab, slab);</span><br><span class="line"></span><br><span class="line">	z_object_init(slab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="k-mem-slab-alloc"><a href="#k-mem-slab-alloc" class="headerlink" title="k_mem_slab_alloc"></a>k_mem_slab_alloc</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	k_spinlock_key_t key = k_spin_lock(&amp;lock);</span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab-&gt;free_list != NULL) &#123;</span><br><span class="line">		/* take a free block */</span><br><span class="line">		*mem = slab-&gt;free_list;</span><br><span class="line">		slab-&gt;free_list = *(char **)(slab-&gt;free_list);</span><br><span class="line">		slab-&gt;num_used++;</span><br><span class="line">		result = 0;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == K_NO_WAIT) &#123;</span><br><span class="line">		/* don<span class="string">&#x27;t wait for a free block to become available */</span></span><br><span class="line"><span class="string">		*mem = NULL;</span></span><br><span class="line"><span class="string">		result = -ENOMEM;</span></span><br><span class="line"><span class="string">	&#125; else &#123;</span></span><br><span class="line"><span class="string">        /* 没有可用内存，线程挂起*/</span></span><br><span class="line"><span class="string">		/* wait for a free block or timeout */</span></span><br><span class="line"><span class="string">		result = z_pend_curr(&amp;lock, key, &amp;slab-&gt;wait_q, timeout);</span></span><br><span class="line"><span class="string">		if (result == 0) &#123;</span></span><br><span class="line"><span class="string">			*mem = _current-&gt;base.swap_data;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return result;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	k_spin_unlock(&amp;lock, key);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return result;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="k-mem-slab-free"><a href="#k-mem-slab-free" class="headerlink" title="k_mem_slab_free"></a>k_mem_slab_free</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void k<span class="constructor">_mem_slab_free(<span class="params">struct</span> <span class="params">k_mem_slab</span> <span class="operator">*</span><span class="params">slab</span>, <span class="params">void</span> <span class="operator">**</span><span class="params">mem</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	k_spinlock_key_t key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line">    <span class="comment">/* 查找因没有分配到内存而挂起的线程 */</span></span><br><span class="line">	<span class="keyword">struct</span> k_thread *pending_thread = z<span class="constructor">_unpend_first_thread(&amp;<span class="params">slab</span>-&gt;<span class="params">wait_q</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pending_thread != NULL) &#123;</span><br><span class="line">        <span class="comment">/* 唤起因没有分配到内存而挂起的线程 */</span></span><br><span class="line">		z<span class="constructor">_set_thread_return_value_with_data(<span class="params">pending_thread</span>, 0, <span class="operator">*</span><span class="params">mem</span>)</span>;</span><br><span class="line">		z<span class="constructor">_ready_thread(<span class="params">pending_thread</span>)</span>;</span><br><span class="line">		z<span class="constructor">_reschedule(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		**(<span class="built_in">char</span> ***)mem = slab-&gt;free_list;</span><br><span class="line">		slab-&gt;free_list = *(<span class="built_in">char</span> **)mem;</span><br><span class="line">		slab-&gt;num_used--;</span><br><span class="line">		k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存块在初始化的时候会指定一片区域，并在该区域建立表格，free_list保存整个块的可用内存地址，在分配内存时如果没有可用内存则挂起线程等待有可用内存或到超时时间到为止。内存slab每次分配固定大小，对于需要更灵活的内存分配可用使用mem_poll，可用分配更为随意大小内存</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>memory slab</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-messageQ</title>
    <url>/2019/08/18/zephyr-messageQ/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>消息队列实现了在两个线程之间传递多个数据的通信体制，在 两个线程之间需要数据同步的时候可以选择消息队列这种通信方式。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Message Queue Structure</span><br><span class="line"> */</span><br><span class="line">struct k_msgq &#123;</span><br><span class="line">	_wait_q_t wait_q;</span><br><span class="line">	struct k_spinlock lock;</span><br><span class="line">	size_t msg_size;</span><br><span class="line">	u32_t max_msgs;</span><br><span class="line">	char *buffer_start;</span><br><span class="line">	char *buffer_end;</span><br><span class="line">	char *read_ptr;</span><br><span class="line">	char *write_ptr;</span><br><span class="line">	u32_t used_msgs;</span><br><span class="line"></span><br><span class="line">	_OBJECT_TRACING_NEXT_PTR(k_msgq)</span><br><span class="line">	u8_t flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,</span><br><span class="line">		 u32_t max_msgs)</span><br><span class="line">&#123;</span><br><span class="line">	msgq-&gt;msg_size = msg_size;</span><br><span class="line">	msgq-&gt;max_msgs = max_msgs;</span><br><span class="line">	msgq-&gt;buffer_start = buffer;</span><br><span class="line">	msgq-&gt;buffer_end = buffer + (max_msgs * msg_size);</span><br><span class="line">	msgq-&gt;read_ptr = buffer;</span><br><span class="line">	msgq-&gt;write_ptr = buffer;</span><br><span class="line">	msgq-&gt;used_msgs = 0;</span><br><span class="line">	msgq-&gt;flags = 0;</span><br><span class="line">	z_waitq_init(&amp;msgq-&gt;wait_q);</span><br><span class="line">	msgq-&gt;lock = (struct k_spinlock) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	SYS_TRACING_OBJ_INIT(k_msgq, msgq);</span><br><span class="line"></span><br><span class="line">	z_object_init(msgq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给结构体赋值，初始化链表</p>
<h3 id="写数据到消息队列"><a href="#写数据到消息队列" class="headerlink" title="写数据到消息队列"></a>写数据到消息队列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	__ASSERT(!z_is_in_isr() || timeout == K_NO_WAIT, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	struct k_thread *pending_thread;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	key = k_spin_lock(&amp;msgq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgq-&gt;used_msgs &lt; msgq-&gt;max_msgs) &#123;</span><br><span class="line">		/* message queue isn<span class="string">&#x27;t full */</span></span><br><span class="line"><span class="string">		/* 消息队列不满 */</span></span><br><span class="line"><span class="string">		pending_thread = z_unpend_first_thread(&amp;msgq-&gt;wait_q);</span></span><br><span class="line"><span class="string">		if (pending_thread != NULL) &#123;</span></span><br><span class="line"><span class="string">			/* give message to waiting thread */</span></span><br><span class="line"><span class="string">			(void)memcpy(pending_thread-&gt;base.swap_data, data,</span></span><br><span class="line"><span class="string">			       msgq-&gt;msg_size);</span></span><br><span class="line"><span class="string">			/* wake up waiting thread */</span></span><br><span class="line"><span class="string">			z_set_thread_return_value(pending_thread, 0);</span></span><br><span class="line"><span class="string">			z_ready_thread(pending_thread);</span></span><br><span class="line"><span class="string">			z_reschedule(&amp;msgq-&gt;lock, key);</span></span><br><span class="line"><span class="string">			return 0;</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			/* put message in queue */</span></span><br><span class="line"><span class="string">			(void)memcpy(msgq-&gt;write_ptr, data, msgq-&gt;msg_size);</span></span><br><span class="line"><span class="string">			msgq-&gt;write_ptr += msgq-&gt;msg_size;</span></span><br><span class="line"><span class="string">			if (msgq-&gt;write_ptr == msgq-&gt;buffer_end) &#123;</span></span><br><span class="line"><span class="string">				msgq-&gt;write_ptr = msgq-&gt;buffer_start;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			msgq-&gt;used_msgs++;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		result = 0;</span></span><br><span class="line"><span class="string">	&#125; else if (timeout == K_NO_WAIT) &#123;</span></span><br><span class="line"><span class="string">		/* don&#x27;</span>t <span class="built_in">wait</span> <span class="keyword">for</span> message space to become available */</span><br><span class="line">		result = -ENOMSG;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		/* <span class="built_in">wait</span> <span class="keyword">for</span> put message success, failure, or timeout */</span><br><span class="line">		_current-&gt;base.swap_data = data;</span><br><span class="line">		<span class="built_in">return</span> z_pend_curr(&amp;msgq-&gt;lock, key, &amp;msgq-&gt;wait_q, timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k_spin_unlock(&amp;msgq-&gt;lock, key);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取消息队列的消息"><a href="#读取消息队列的消息" class="headerlink" title="读取消息队列的消息"></a>读取消息队列的消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	__ASSERT(!z_is_in_isr() || timeout == K_NO_WAIT, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line">	struct k_thread *pending_thread;</span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	key = k_spin_lock(&amp;msgq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgq-&gt;used_msgs &gt; 0) &#123;</span><br><span class="line">		/* take first available message from queue */</span><br><span class="line">		(void)memcpy(data, msgq-&gt;read_ptr, msgq-&gt;msg_size);</span><br><span class="line">		msgq-&gt;read_ptr += msgq-&gt;msg_size;</span><br><span class="line">		<span class="keyword">if</span> (msgq-&gt;read_ptr == msgq-&gt;buffer_end) &#123;</span><br><span class="line">			msgq-&gt;read_ptr = msgq-&gt;buffer_start;</span><br><span class="line">		&#125;</span><br><span class="line">		msgq-&gt;used_msgs--;</span><br><span class="line"></span><br><span class="line">		/* handle first thread waiting to write (<span class="keyword">if</span> any) */</span><br><span class="line">		pending_thread = z_unpend_first_thread(&amp;msgq-&gt;wait_q);</span><br><span class="line">		<span class="keyword">if</span> (pending_thread != NULL) &#123;</span><br><span class="line">			/* add thread<span class="string">&#x27;s message to queue */</span></span><br><span class="line"><span class="string">			(void)memcpy(msgq-&gt;write_ptr, pending_thread-&gt;base.swap_data,</span></span><br><span class="line"><span class="string">			       msgq-&gt;msg_size);</span></span><br><span class="line"><span class="string">			msgq-&gt;write_ptr += msgq-&gt;msg_size;</span></span><br><span class="line"><span class="string">			if (msgq-&gt;write_ptr == msgq-&gt;buffer_end) &#123;</span></span><br><span class="line"><span class="string">				msgq-&gt;write_ptr = msgq-&gt;buffer_start;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			msgq-&gt;used_msgs++;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			/* wake up waiting thread */</span></span><br><span class="line"><span class="string">			z_set_thread_return_value(pending_thread, 0);</span></span><br><span class="line"><span class="string">			z_ready_thread(pending_thread);</span></span><br><span class="line"><span class="string">			z_reschedule(&amp;msgq-&gt;lock, key);</span></span><br><span class="line"><span class="string">			return 0;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		result = 0;</span></span><br><span class="line"><span class="string">	&#125; else if (timeout == K_NO_WAIT) &#123;</span></span><br><span class="line"><span class="string">		/* don&#x27;</span>t <span class="built_in">wait</span> <span class="keyword">for</span> a message to become available */</span><br><span class="line">		result = -ENOMSG;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		/* <span class="built_in">wait</span> <span class="keyword">for</span> get message success or timeout */</span><br><span class="line">		_current-&gt;base.swap_data = data;</span><br><span class="line">		<span class="built_in">return</span> z_pend_curr(&amp;msgq-&gt;lock, key, &amp;msgq-&gt;wait_q, timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k_spin_unlock(&amp;msgq-&gt;lock, key);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>messageQ</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-mutexes</title>
    <url>/2019/08/17/zephyr-mutexes/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在信号量一文中介绍了信号量的实现原理以及使用信号量的弊端，而使用互斥锁则可以解决线程间的互锁问题。主要在于互斥锁有一个调整线程间优先级的机制可以让一个线程取得资源执行完再释放资源。</p>
<h3 id="用户接口（API）"><a href="#用户接口（API）" class="headerlink" title="用户接口（API）"></a>用户接口（API）</h3><p>在接口设计上系统调用都是相同的方式这里不再罗列出来了，其结果都是k_mutex_lock调用z_impl_k_mutex_lock；k_mutex_unlock调用z_impl_k_mutex_unlock；k_mutex_init调用z_impl_k_mutex_init；下面看看这几个函数的实现方式：</p>
<h3 id="互斥锁实现"><a href="#互斥锁实现" class="headerlink" title="互斥锁实现"></a>互斥锁实现</h3><p><strong>z_impl_k_mutex_init</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* 与信号量初始化函数比较像 只是互斥锁的值只能是0和1，不能是其他值 */</span></span><br><span class="line">mutex-&gt;owner = NULL;</span><br><span class="line">mutex-&gt;lock_count = <span class="number">0</span>U;</span><br><span class="line"></span><br><span class="line">sys<span class="constructor">_trace_void(SYS_TRACE_ID_MUTEX_INIT)</span>;</span><br><span class="line"></span><br><span class="line">z<span class="constructor">_waitq_init(&amp;<span class="params">mutex</span>-&gt;<span class="params">wait_q</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="constructor">SYS_TRACING_OBJ_INIT(<span class="params">k_mutex</span>, <span class="params">mutex</span>)</span>;</span><br><span class="line">z<span class="constructor">_object_init(<span class="params">mutex</span>)</span>;</span><br><span class="line">sys<span class="constructor">_trace_end_call(SYS_TRACE_ID_MUTEX_INIT)</span>;</span><br></pre></td></tr></table></figure>
<p>定义并初始化k_mutex结构体</p>
<p><strong>z_impl_k_mutex_lock</strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* 关闭调度 */</span></span><br><span class="line">z_sched_lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 这个地方的逻辑有点绕，但是很巧妙，我们想要设置mutex-&gt;owner_orig_prio的优先级， </span></span><br><span class="line"><span class="comment">    * 假如我们可以上锁则owner指向当前线程mutex-&gt;owner_orig_prio = _current-&gt;base.prio;</span></span><br><span class="line"><span class="comment">    * 假如当前线程已经被锁那么owner已经指向当前线程自然不用给mutex-&gt;owner_orig_prio赋值</span></span><br><span class="line"><span class="comment">    * 保存owner的优先级用于在调整优先级后再调整回来</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (likely((mutex-&gt;</span><span class="function"><span class="title">lock_count</span> == 0U) || (mutex-&gt;</span>owner == _current))) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">mutex</span>-&gt;</span><span class="function"><span class="title">owner_orig_prio</span> = (mutex-&gt;</span>lock_count == <span class="number">0</span>U) ?</span><br><span class="line">				_<span class="function"><span class="title">current</span>-&gt;</span>base.prio :</span><br><span class="line">				<span class="function"><span class="title">mutex</span>-&gt;</span>owner_orig_prio;</span><br><span class="line">       <span class="comment">/* 上锁 */</span></span><br><span class="line">	<span class="function"><span class="title">mutex</span>-&gt;</span>lock_count++;</span><br><span class="line">	<span class="function"><span class="title">mutex</span>-&gt;</span>owner = _current;</span><br><span class="line"></span><br><span class="line">	K_DEBUG(<span class="string">&quot;%p took mutex %p, count: %d, orig prio: %d\n&quot;</span>,</span><br><span class="line">		_<span class="function"><span class="title">current</span>, mutex, mutex-&gt;</span>lock_count,</span><br><span class="line">		<span class="function"><span class="title">mutex</span>-&gt;</span>owner_orig_prio);</span><br><span class="line"></span><br><span class="line">	k_sched_unlock();</span><br><span class="line">	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 等待超时如果为不等待 开启调度开关 */</span></span><br><span class="line">   <span class="keyword">if</span> (unlikely(timeout == (s32_t)K_NO_WAIT)) &#123;</span><br><span class="line">	k_sched_unlock();</span><br><span class="line">	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);</span><br><span class="line">	return -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 如果当前已经上锁且超时时间不是K_NO_WAIT 进行如下优先级调整</span></span><br><span class="line"><span class="comment">    * 运行到这里说明mutex-&gt;owner不是当前线程mutex-&gt;owner-&gt;base.prio是另一个线程的优先级</span></span><br><span class="line"><span class="comment">    * 传入当前线程优先级和获得锁的线程优先级来获得一个新优先级以让线程可以得到更好的运行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* 这个new_prio 是当前优先级和获得锁的优先级中较高的那个 */</span></span><br><span class="line">   <span class="function"><span class="title">new_prio</span> = new_prio_for_inheritance(_current-&gt;</span><span class="function"><span class="title">base</span>.prio,mutex-&gt;</span><span class="function"><span class="title">owner</span>-&gt;</span>base.prio);</span><br><span class="line">       int new_prio = z_is_prio_higher(target, limit) ? target : limit;</span><br><span class="line">    new_prio = z_get_new_prio_with_ceiling(new_prio);</span><br><span class="line">    return new_prio;</span><br><span class="line">   <span class="comment">/* 上自旋锁 */</span></span><br><span class="line">key = k_spin_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 如果new_prio高于mutex-&gt;owner-&gt;base.prio则new_prio是当前优先级，</span></span><br><span class="line"><span class="comment">    * 当前优先级高于owner优先级需要等待owner先执行完释放锁因此需要调整优先级</span></span><br><span class="line"><span class="comment">    * 将new_prio优先级设置到owner，以保证owner线程可以得到执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="title">if</span> (z_is_prio_higher(new_prio, mutex-&gt;</span><span class="function"><span class="title">owner</span>-&gt;</span>base.prio)) &#123;</span><br><span class="line">	adjust_owner_prio(mutex, new_prio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 需要等待owner线程执行完成后再执行当前线程，把自己pend起来timeout时间 */</span></span><br><span class="line">   <span class="function"><span class="title">int</span> got_mutex = z_pend_curr(&amp;lock, key, &amp;mutex-&gt;</span>wait_q, timeout);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">/* 线程超时时间到仍然没有获得锁 查找因为获得锁而挂起的线程 */</span></span><br><span class="line">   <span class="function"><span class="title">struct</span> k_thread *waiter = z_waitq_head(&amp;mutex-&gt;</span>wait_q);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在owner线程和其他挂起的线程之间再继续进行相同的优先级调整，将owner线程优先级调整为这些线程中的最高优先级 */</span></span><br><span class="line">   <span class="function"><span class="title">new_prio</span> = mutex-&gt;</span>owner_orig_prio;</span><br><span class="line">new_prio = (waiter != NULL) ?</span><br><span class="line">	<span class="function"><span class="title">new_prio_for_inheritance</span>(waiter-&gt;</span>base.prio, new_prio) :</span><br><span class="line">	new_prio; </span><br><span class="line"></span><br><span class="line">   key = k_spin_lock(&amp;lock);</span><br><span class="line">adjust_owner_prio(mutex, new_prio);</span><br><span class="line">k_spin_unlock(&amp;lock, key);</span><br></pre></td></tr></table></figure>
<p>上锁这个函数相较于之前的信号量要复杂多了，在已经被上锁了的情况下，会将自己以及其他都在要上锁的线程进行优先级继承，使得owner的优先级调整到最高，使其运行完释放锁，其基本原理就是这样，提高mutex的owner的优先级使其优先运行完。</p>
<p><strong>z_impl_k_mutex_unlock</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* 如果锁了多次则减少锁的次数*/</span></span><br><span class="line"><span class="keyword">if</span> (mutex-&gt;lock_count - <span class="number">1</span>U != <span class="number">0</span>U) &#123;</span><br><span class="line">	mutex-&gt;lock_count--;</span><br><span class="line">	goto k_mutex_unlock_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 如果这是最后一个锁则需要恢复之前优先级 */</span></span><br><span class="line">   adjust<span class="constructor">_owner_prio(<span class="params">mutex</span>, <span class="params">mutex</span>-&gt;<span class="params">owner_orig_prio</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将其他请求锁的线程唤醒并将锁的owner指向该线程*/</span></span><br><span class="line">   new_owner = z<span class="constructor">_unpend_first_thread(&amp;<span class="params">mutex</span>-&gt;<span class="params">wait_q</span>)</span>;</span><br><span class="line">mutex-&gt;owner = new_owner;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 执行新的线程 新的线程是经过优先级排序的不需要再进行优先级调整 */</span></span><br><span class="line">   <span class="keyword">if</span> (new_owner != NULL) &#123;</span><br><span class="line">	z<span class="constructor">_ready_thread(<span class="params">new_owner</span>)</span>;</span><br><span class="line"></span><br><span class="line">	k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line"></span><br><span class="line">	z<span class="constructor">_set_thread_return_value(<span class="params">new_owner</span>, 0)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * new owner is already of higher or equal prio than first</span></span><br><span class="line"><span class="comment">	 * waiter since the wait queue is priority-based: no need to</span></span><br><span class="line"><span class="comment">	 * ajust its priority</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex-&gt;owner_orig_prio = new_owner-&gt;base.prio;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>与信号量相比，互斥锁增加了优先级继承机制，即拥有mutex的线程将得到较高优先级优先执行，这样就不会造成线程之间的死锁现象的发生，因此在使用中涉及硬件设备的访问等一些有可能出现死锁的情况下最好使用互斥锁。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>mutexes</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-pipe</title>
    <url>/2019/08/21/zephyr-pipe/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>pipe提供了一种可靠的线程间通讯且通信更为灵活，在两个线程间不必等待消息完全准备好才发送或接受而是，只要有数据便发送或则接收，标记数据传输进度即可。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Pipe Structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_pipe</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>;          <span class="comment">/**&lt; Pipe buffer: may be NULL */</span></span><br><span class="line">	<span class="keyword">size_t</span>         <span class="built_in">size</span>;            <span class="comment">/**&lt; Buffer size */</span></span><br><span class="line">	<span class="keyword">size_t</span>         bytes_used;      <span class="comment">/**&lt; # bytes used in buffer */</span></span><br><span class="line">	<span class="keyword">size_t</span>         read_index;      <span class="comment">/**&lt; Where in buffer to read from */</span></span><br><span class="line">	<span class="keyword">size_t</span>         write_index;     <span class="comment">/**&lt; Where in buffer to write */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_spinlock</span> <span class="title">lock</span>;</span>		<span class="comment">/**&lt; Synchronization lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">_wait_q_t</span>      readers; <span class="comment">/**&lt; Reader wait queue */</span></span><br><span class="line">		<span class="keyword">_wait_q_t</span>      writers; <span class="comment">/**&lt; Writer wait queue */</span></span><br><span class="line">	&#125; wait_q;</span><br><span class="line"></span><br><span class="line">	_OBJECT_TRACING_NEXT_PTR(k_pipe)</span><br><span class="line">	<span class="keyword">u8_t</span>	       flags;		<span class="comment">/**&lt; Flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void k<span class="constructor">_pipe_init(<span class="params">struct</span> <span class="params">k_pipe</span> <span class="operator">*</span><span class="params">pipe</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buffer</span>, <span class="params">size_t</span> <span class="params">size</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	pipe-&gt;buffer = buffer;</span><br><span class="line">	pipe-&gt;size = size;</span><br><span class="line">	pipe-&gt;bytes_used = <span class="number">0</span>;</span><br><span class="line">	pipe-&gt;read_index = <span class="number">0</span>;</span><br><span class="line">	pipe-&gt;write_index = <span class="number">0</span>;</span><br><span class="line">	pipe-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	z<span class="constructor">_waitq_init(&amp;<span class="params">pipe</span>-&gt;<span class="params">wait_q</span>.<span class="params">writers</span>)</span>;</span><br><span class="line">	z<span class="constructor">_waitq_init(&amp;<span class="params">pipe</span>-&gt;<span class="params">wait_q</span>.<span class="params">readers</span>)</span>;</span><br><span class="line">	<span class="constructor">SYS_TRACING_OBJ_INIT(<span class="params">k_pipe</span>, <span class="params">pipe</span>)</span>;</span><br><span class="line">	z<span class="constructor">_object_init(<span class="params">pipe</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对k_pipe结构体赋值初始化wait_q链表</p>
<h3 id="k-pipe-put"><a href="#k-pipe-put" class="headerlink" title="k_pipe_put"></a>k_pipe_put</h3><p>看k_pipe_put之前这里先看一个prepare函数：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Prepare a working set of readers/writers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a list of &quot;working threads&quot; into/from which the data</span></span><br><span class="line"><span class="comment"> * will be directly copied. This list is useful as it is used to ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1. avoid double copying</span></span><br><span class="line"><span class="comment"> *  2. minimize interrupt latency as interrupts are unlocked</span></span><br><span class="line"><span class="comment"> *     while copying data</span></span><br><span class="line"><span class="comment"> *  3. ensure a timeout can not make the request impossible to satisfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The list is populated with previously pended threads that will be ready to</span></span><br><span class="line"><span class="comment"> * run after the pipe call is complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Important things to remember when reading from the pipe ...</span></span><br><span class="line"><span class="comment"> * 1. If there are writers int @a wait_q, then the pipe&#x27;s buffer is full.</span></span><br><span class="line"><span class="comment"> * 2. Conversely if the pipe&#x27;s buffer is not full, there are no writers.</span></span><br><span class="line"><span class="comment"> * 3. The amount of available data in the pipe is the sum the bytes used in</span></span><br><span class="line"><span class="comment"> *    the pipe (@a pipe_space) and all the requests from the waiting writers.</span></span><br><span class="line"><span class="comment"> * 4. Since data is read from the pipe&#x27;s buffer first, the working set must</span></span><br><span class="line"><span class="comment"> *    include writers that will (try to) re-fill the pipe&#x27;s buffer afterwards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Important things to remember when writing to the pipe ...</span></span><br><span class="line"><span class="comment"> * 1. If there are readers in @a wait_q, then the pipe&#x27;s buffer is empty.</span></span><br><span class="line"><span class="comment"> * 2. Conversely if the pipe&#x27;s buffer is not empty, then there are no readers.</span></span><br><span class="line"><span class="comment"> * 3. The amount of space available in the pipe is the sum of the bytes unused</span></span><br><span class="line"><span class="comment"> *    in the pipe (@a pipe_space) and all the requests from the waiting readers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return false if request is unsatisfiable, otherwise true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">bool</span> <span class="built_in">pipe_xfer_prepare</span>(sys_dlist_t      *xfer_list,</span><br><span class="line">			       struct k_thread **waiter,</span><br><span class="line">			       _wait_q_t        *wait_q,</span><br><span class="line">			       size_t            pipe_space,</span><br><span class="line">			       size_t            bytes_to_xfer,</span><br><span class="line">			       size_t            min_xfer,</span><br><span class="line">			       s32_t           timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="type">k_thread</span>  *thread;</span><br><span class="line">	<span class="keyword">struct</span> <span class="type">k_pipe_desc</span> *desc;</span><br><span class="line">	size_t num_bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 不等待 */</span></span><br><span class="line">	<span class="keyword">if</span> (timeout == K_NO_WAIT) &#123;</span><br><span class="line">		<span class="built_in">_WAIT_Q_FOR_EACH</span>(wait_q, thread) &#123;</span><br><span class="line">			<span class="comment">/* 取出read的等待队列的线程 */</span></span><br><span class="line">			desc = (<span class="keyword">struct</span> <span class="type">k_pipe_desc</span> *)thread-&gt;base.swap_data;</span><br><span class="line"></span><br><span class="line">			num_bytes += desc-&gt;bytes_to_xfer;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 如果read等待线程需要读取的数据大于我们想要写入的数据大小 返回*/</span></span><br><span class="line">			<span class="keyword">if</span> (num_bytes &gt;= bytes_to_xfer) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 等待线程需要读取的数据加上pipe剩余空间小于我们要写入的数据，则没有空间可以写入 返回失败 */</span></span><br><span class="line">		<span class="keyword">if</span> (num_bytes + pipe_space &lt; min_xfer) &#123;</span><br><span class="line">			<span class="keyword">return</span> false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Either @a timeout is not K_NO_WAIT (so the thread may pend) or</span></span><br><span class="line"><span class="comment">	 * the entire request can be satisfied. Generate the working list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">sys_dlist_init</span>(xfer_list);</span><br><span class="line">	num_bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((thread = <span class="built_in">z_waitq_head</span>(wait_q)) != <span class="built_in">NULL</span>) &#123;</span><br><span class="line">		desc = (<span class="keyword">struct</span> <span class="type">k_pipe_desc</span> *)thread-&gt;base.swap_data;</span><br><span class="line">		num_bytes += desc-&gt;bytes_to_xfer;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 直到read线程读取的数据大于我们要写入的数据才跳出 */</span></span><br><span class="line">		<span class="keyword">if</span> (num_bytes &gt; bytes_to_xfer) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This request can not be fully satisfied.</span></span><br><span class="line"><span class="comment">			 * Do not remove it from the wait_q.</span></span><br><span class="line"><span class="comment">			 * Do not abort its timeout (if applicable).</span></span><br><span class="line"><span class="comment">			 * Do not add it to the transfer list</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This request can be fully satisfied.</span></span><br><span class="line"><span class="comment">		 * Remove it from the wait_q.</span></span><br><span class="line"><span class="comment">		 * Abort its timeout.</span></span><br><span class="line"><span class="comment">		 * Add it to the transfer list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">z_unpend_thread</span>(thread);</span><br><span class="line">		<span class="built_in">sys_dlist_append</span>(xfer_list, &amp;thread-&gt;base.qnode_dlist);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*waiter = (num_bytes &gt; bytes_to_xfer) ? thread : <span class="built_in">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数先对pipe的空间进行检查，看是否有足够的空间可以put数据，如果没有足够的空间看read队列是否有等待线程读取数据，检查如果读取线程读取的数据大于我们要写入的数据则我们将数据准备好给read线程，再进行写入，再确认pipe的数据是准备好的就可以直接进行拷贝了。下面看k_pipe_put函数，这个函数直接调用z_pipe_put_internal</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Internal API used to send data to a pipe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">int z_pipe_put_internal(struct k_pipe *pipe, struct k_pipe_async *async_desc,</span><br><span class="line">			 unsigned char *<span class="keyword">data</span>, size_t bytes_to_write,</span><br><span class="line">			 size_t *bytes_written, size_t min_xfer,</span><br><span class="line">			 s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	struct k_thread    *reader;</span><br><span class="line">	struct k_pipe_desc *desc;</span><br><span class="line">	sys_dlist_t    xfer_list;</span><br><span class="line">	size_t         num_bytes_written = <span class="number">0</span>;</span><br><span class="line">	size_t         bytes_copied;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> (CONFIG_NUM_PIPE_ASYNC_MSGS == <span class="number">0</span>)</span><br><span class="line">	ARG_UNUSED(async_desc);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">k_spinlock_key_t</span> key = k_spin_lock(&amp;pipe-&gt;</span>lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create a list of &quot;working readers&quot; into which the data will be</span></span><br><span class="line"><span class="comment">	 * directly copied.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 这个是上面的那个函数 检查pipe和等待读取的线程数据 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (!pipe_xfer_prepare(&amp;xfer_list, &amp;reader, &amp;pipe-&gt;</span>wait_q.readers,</span><br><span class="line">				<span class="function"><span class="title">pipe</span>-&gt;</span><span class="function"><span class="title">size</span> - pipe-&gt;</span>bytes_used, bytes_to_write,</span><br><span class="line">				min_xfer, timeout)) &#123;</span><br><span class="line">		<span class="function"><span class="title">k_spin_unlock</span>(&amp;pipe-&gt;</span>lock, key);</span><br><span class="line">		*bytes_written = <span class="number">0</span>;</span><br><span class="line">		return -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z_sched_lock();</span><br><span class="line">	<span class="function"><span class="title">k_spin_unlock</span>(&amp;pipe-&gt;</span>lock, key);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1. &#x27;xfer_list&#x27; currently contains a list of reader threads that can</span></span><br><span class="line"><span class="comment">	 * have their read requests fulfilled by the current call.</span></span><br><span class="line"><span class="comment">	 * 2. &#x27;reader&#x27; if not NULL points to a thread on the reader wait_q</span></span><br><span class="line"><span class="comment">	 * that can get some of its requested data.</span></span><br><span class="line"><span class="comment">	 * 3. Interrupts are unlocked but the scheduler is locked to allow</span></span><br><span class="line"><span class="comment">	 * ticks to be delivered but no scheduling to occur</span></span><br><span class="line"><span class="comment">	 * 4. If &#x27;reader&#x27; times out while we are copying data, not only do we</span></span><br><span class="line"><span class="comment">	 * still have a pointer to it, but it can not execute until this call</span></span><br><span class="line"><span class="comment">	 * is complete so it is still safe to copy data to it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	struct k_thread *thread = (struct k_thread *)</span><br><span class="line">				  sys_dlist_get(&amp;xfer_list);</span><br><span class="line">	<span class="keyword">while</span> (thread != NULL) &#123;</span><br><span class="line">		<span class="function"><span class="title">desc</span> = (struct k_pipe_desc *)thread-&gt;</span>base.swap_data;</span><br><span class="line">		<span class="comment">/* 将要写入的数据直接拷贝到等待读取的线程，并更新读写信息，直到读取线程完或要写入的数据完  */</span></span><br><span class="line">		<span class="function"><span class="title">bytes_copied</span> = pipe_xfer(desc-&gt;</span><span class="function"><span class="title">buffer</span>, desc-&gt;</span>bytes_to_xfer,</span><br><span class="line">					  <span class="keyword">data</span> + num_bytes_written,</span><br><span class="line">					  bytes_to_write - num_bytes_written);</span><br><span class="line"></span><br><span class="line">		num_bytes_written   += bytes_copied;</span><br><span class="line">		<span class="function"><span class="title">desc</span>-&gt;</span>buffer        += bytes_copied;</span><br><span class="line">		<span class="function"><span class="title">desc</span>-&gt;</span>bytes_to_xfer -= bytes_copied;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* The thread&#x27;s read request has been satisfied. Ready it. */</span></span><br><span class="line">		z_ready_thread(thread);</span><br><span class="line"></span><br><span class="line">		thread = (struct k_thread *)sys_dlist_get(&amp;xfer_list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy any data to the reader that we left on the wait_q.</span></span><br><span class="line"><span class="comment">	 * It is possible no data will be copied.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/* 拷贝读取数据大于需要写入的数据，不一定会有 */</span></span><br><span class="line">	<span class="keyword">if</span> (reader != NULL) &#123;</span><br><span class="line">		<span class="function"><span class="title">desc</span> = (struct k_pipe_desc *)reader-&gt;</span>base.swap_data;</span><br><span class="line">		<span class="function"><span class="title">bytes_copied</span> = pipe_xfer(desc-&gt;</span><span class="function"><span class="title">buffer</span>, desc-&gt;</span>bytes_to_xfer,</span><br><span class="line">					  <span class="keyword">data</span> + num_bytes_written,</span><br><span class="line">					  bytes_to_write - num_bytes_written);</span><br><span class="line"></span><br><span class="line">		num_bytes_written   += bytes_copied;</span><br><span class="line">		<span class="function"><span class="title">desc</span>-&gt;</span>buffer        += bytes_copied;</span><br><span class="line">		<span class="function"><span class="title">desc</span>-&gt;</span>bytes_to_xfer -= bytes_copied;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As much data as possible has been directly copied to any waiting</span></span><br><span class="line"><span class="comment">	 * readers. Add as much as possible to the pipe&#x27;s circular buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 还有数据的话，将数据写入pipe */</span></span><br><span class="line">	num_bytes_written +=</span><br><span class="line">		pipe_buffer_put(pipe, <span class="keyword">data</span> + num_bytes_written,</span><br><span class="line">				 bytes_to_write - num_bytes_written);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num_bytes_written == bytes_to_write) &#123;</span><br><span class="line">		*bytes_written = num_bytes_written;</span><br><span class="line">#<span class="keyword">if</span> (CONFIG_NUM_PIPE_ASYNC_MSGS &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (async_desc != NULL) &#123;</span><br><span class="line">			pipe_async_finish(async_desc);</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">		k_sched_unlock();</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not all data was copied. */</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	struct k_pipe_desc  pipe_desc;</span><br><span class="line"></span><br><span class="line">	pipe_desc.buffer         = <span class="keyword">data</span> + num_bytes_written;</span><br><span class="line">	pipe_desc.bytes_to_xfer  = bytes_to_write - num_bytes_written;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pipe是满的 且time不为K_NO_WAIT将数据放到线程swap_data里，挂起当前线程 */</span></span><br><span class="line">	<span class="keyword">if</span> (timeout != K_NO_WAIT) &#123;</span><br><span class="line">		_<span class="function"><span class="title">current</span>-&gt;</span>base.swap_data = &amp;pipe_desc;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lock interrupts and unlock the scheduler before</span></span><br><span class="line"><span class="comment">		 * manipulating the writers wait_q.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="title">k_spinlock_key_t</span> key = k_spin_lock(&amp;pipe-&gt;</span>lock);</span><br><span class="line">		z_sched_unlock_no_reschedule();</span><br><span class="line">		(<span class="function"><span class="title">void</span>)z_pend_curr(&amp;pipe-&gt;</span>lock, key,</span><br><span class="line">				 &amp;<span class="function"><span class="title">pipe</span>-&gt;</span>wait_q.writers, timeout);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		k_sched_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*bytes_written = bytes_to_write - pipe_desc.bytes_to_xfer;</span><br><span class="line"></span><br><span class="line">	return pipe_return_code(min_xfer, pipe_desc.bytes_to_xfer,</span><br><span class="line">				 bytes_to_write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取数据和写入 数据的流程大致类似这里就不再详细列出了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用pipe在线程间传递数据，需要先对pipe和等待线程的信息进行统计，判断当前pipe是否可用，在有读取等待队列线程说明pipe是空的在等待其他线程写入数据，同样有写入线程在等待说明pipe是满的需要其他线程读取，在接近满和接近空的情况下还要对pipe剩余空间或已有数据空间与等待线程数据信息以及要写入数据信息进行比较，可以实现写入部分数据而不是完整的数据，每次都尽可能的读取或写入尽可能多的数据即使不是完整的，但是数据结构维持对读写进度的保存。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>pipe</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-poll</title>
    <url>/2019/08/19/zephyr-poll/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>poll是一种轮循机制，可以实现轮循不同的消息。在一个线程需要同时与其他多个线程通信的时候可以通过poll机制轮循检查是否有消息并进行处理。</p>
<h3 id="poll-event初始化"><a href="#poll-event初始化" class="headerlink" title="poll_event初始化"></a>poll_event初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_poll_event</span> &#123;</span></span><br><span class="line">	<span class="comment">/* PRIVATE - DO NOT TOUCH */</span></span><br><span class="line">	<span class="keyword">sys_dnode_t</span> _node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PRIVATE - DO NOT TOUCH */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">poller</span> *<span class="title">poller</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* optional user-specified tag, opaque, untouched by the API */</span></span><br><span class="line">	<span class="keyword">u32_t</span> tag:<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bitfield of event types (bitwise-ORed K_POLL_TYPE_xxx values) */</span></span><br><span class="line">	<span class="keyword">u32_t</span> type:_POLL_NUM_TYPES;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bitfield of event states (bitwise-ORed K_POLL_STATE_xxx values) */</span></span><br><span class="line">	<span class="keyword">u32_t</span> state:_POLL_NUM_STATES;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mode of operation, from enum k_poll_modes */</span></span><br><span class="line">	<span class="keyword">u32_t</span> mode:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* unused bits in 32-bit word */</span></span><br><span class="line">	<span class="keyword">u32_t</span> unused:_POLL_EVENT_NUM_UNUSED_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里是union，对应的实际内存只有一块，一个线程同时只能poll fifo或sem或queue或signal中的一个，在初始化的时候就需要指定具体用那个但是一个线程可以同时轮循多个event的事件 */</span></span><br><span class="line">	<span class="comment">/* per-type data */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">void</span> *obj;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">k_poll_signal</span> *<span class="title">signal</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">k_sem</span> *<span class="title">sem</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">k_fifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">k_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_poll_event_init</span><span class="params">(struct k_poll_event *event, <span class="keyword">u32_t</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> mode, <span class="keyword">void</span> *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,</span><br><span class="line">		 <span class="string">&quot;only NOTIFY_ONLY mode is supported\n&quot;</span>);</span><br><span class="line">	__ASSERT(type &lt; (BIT(_POLL_NUM_TYPES)), <span class="string">&quot;invalid type\n&quot;</span>);</span><br><span class="line">	__ASSERT(obj != <span class="literal">NULL</span>, <span class="string">&quot;must provide an object\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	event-&gt;poller = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* event-&gt;tag is left uninitialized: the user will set it if needed */</span></span><br><span class="line">	event-&gt;type = type;</span><br><span class="line">	event-&gt;state = K_POLL_STATE_NOT_READY;</span><br><span class="line">	event-&gt;mode = mode;</span><br><span class="line">	event-&gt;unused = <span class="number">0U</span>;</span><br><span class="line">	event-&gt;obj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> z<span class="constructor">_impl_k_poll(<span class="params">struct</span> <span class="params">k_poll_event</span> <span class="operator">*</span><span class="params">events</span>, <span class="params">int</span> <span class="params">num_events</span>, <span class="params">s32_t</span> <span class="params">timeout</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="constructor">__ASSERT(!<span class="params">z_is_in_isr</span>()</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="constructor">__ASSERT(<span class="params">events</span> != NULL, <span class="string">&quot;NULL events\n&quot;</span>)</span>;</span><br><span class="line">	<span class="constructor">__ASSERT(<span class="params">num_events</span> &gt; 0, <span class="string">&quot;zero events\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> last_registered = -<span class="number">1</span>, rc;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> _poller poller = &#123; .thread = _current, .is_polling = <span class="literal">true</span>, &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find events whose condition is already fulfilled */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> ii = <span class="number">0</span>; ii &lt; num_events; ii++) &#123;</span><br><span class="line">		u32_t state;</span><br><span class="line"></span><br><span class="line">		key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line">        <span class="comment">/* 根据类型判断是否有事件发生。如果有设置state标志返回 */</span></span><br><span class="line">		<span class="keyword">if</span> (is<span class="constructor">_condition_met(&amp;<span class="params">events</span>[<span class="params">ii</span>], &amp;<span class="params">state</span>)</span>) &#123;</span><br><span class="line">			set<span class="constructor">_event_ready(&amp;<span class="params">events</span>[<span class="params">ii</span>], <span class="params">state</span>)</span>;</span><br><span class="line">			poller.is_polling = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* 如果没有事件发生，超时为不等待且处在轮循状态将当前事件加入到event-&gt;single-&gt;poll_event队列中去 */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout != K_NO_WAIT<span class="operator"> &amp;&amp; </span>poller.is_polling) &#123;</span><br><span class="line">			rc = register<span class="constructor">_event(&amp;<span class="params">events</span>[<span class="params">ii</span>], &amp;<span class="params">poller</span>)</span>;</span><br><span class="line">			<span class="keyword">if</span> (rc<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">				++last_registered;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="constructor">__ASSERT(<span class="params">false</span>, <span class="string">&quot;unexpected return code\n&quot;</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re not polling anymore, it means that at least one event</span></span><br><span class="line"><span class="comment">	 * condition is met, either when looping through the events here or</span></span><br><span class="line"><span class="comment">	 * because one of the events registered has had its state changed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">/* 不需要再polling 将之前的event从events-&gt;sem-&gt;poll_event中删除*/</span></span><br><span class="line">	<span class="keyword">if</span> (!poller.is_polling) &#123;</span><br><span class="line">		clear<span class="constructor">_event_registrations(<span class="params">events</span>, <span class="params">last_registered</span>, <span class="params">key</span>)</span>;</span><br><span class="line">		k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poller.is_polling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不等待，直接返回 */</span></span><br><span class="line">	<span class="keyword">if</span> (timeout<span class="operator"> == </span>K_NO_WAIT) &#123;</span><br><span class="line">		k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">		return -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_wait_q_t wait_q = <span class="constructor">Z_WAIT_Q_INIT(&amp;<span class="params">wait_q</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待事件发生直到超时时间到为止*/</span></span><br><span class="line">	<span class="built_in">int</span> swap_rc = z<span class="constructor">_pend_curr(&amp;<span class="params">lock</span>, <span class="params">key</span>, &amp;<span class="params">wait_q</span>, <span class="params">timeout</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear all event registrations. If events happen while we&#x27;re in this</span></span><br><span class="line"><span class="comment">	 * loop, and we already had one that triggered, that&#x27;s OK: they will</span></span><br><span class="line"><span class="comment">	 * end up in the list of events that are ready; if we timed out, and</span></span><br><span class="line"><span class="comment">	 * events happen while we&#x27;re in this loop, that is OK as well since</span></span><br><span class="line"><span class="comment">	 * we&#x27;ve already know the return code (-EAGAIN), and even if they are</span></span><br><span class="line"><span class="comment">	 * added to the list of events that occurred, the user has to check the</span></span><br><span class="line"><span class="comment">	 * return code first, which invalidates the whole list of event states.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* 不需要再polling 将之前的event从events-&gt;sem-&gt;poll_event中删除*/</span></span><br><span class="line">	key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line">	clear<span class="constructor">_event_registrations(<span class="params">events</span>, <span class="params">last_registered</span>, <span class="params">key</span>)</span>;</span><br><span class="line">	k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line"></span><br><span class="line">	return swap_rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">k_spinlock_key_t key = k_spin_lock(&amp;lock);</span><br><span class="line">struct k_poll_event *poll_event;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 生成信号 */</span></span><br><span class="line"><span class="function"><span class="title">signal</span>-&gt;</span>result = result;</span><br><span class="line"><span class="function"><span class="title">signal</span>-&gt;</span>signaled = <span class="number">1</span>U;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 查找在请求该信号的线程，如果没有则返回，如果有则进行处理 */</span></span><br><span class="line"><span class="function"><span class="title">poll_event</span> = (struct k_poll_event *)sys_dlist_get(&amp;signal-&gt;</span>poll_events);</span><br><span class="line"><span class="keyword">if</span> (poll_event == NULL) &#123;</span><br><span class="line">	k_spin_unlock(&amp;lock, key);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 对event线程做判断及处理 */</span></span><br><span class="line">int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);</span><br><span class="line">       <span class="comment">/* 没有注册 */</span></span><br><span class="line">       <span class="function"><span class="title">if</span> (!event-&gt;</span>poller) &#123;</span><br><span class="line">	    goto ready_event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="title">struct</span> k_thread *thread = event-&gt;</span><span class="function"><span class="title">poller</span>-&gt;</span>thread;</span><br><span class="line"></span><br><span class="line">       __ASSERT(<span class="function"><span class="title">event</span>-&gt;</span><span class="function"><span class="title">poller</span>-&gt;</span>thread != NULL,</span><br><span class="line">           <span class="string">&quot;poller should have a thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="title">event</span>-&gt;</span><span class="function"><span class="title">poller</span>-&gt;</span>is_polling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 线程没在挂起状态 */</span></span><br><span class="line">       <span class="keyword">if</span> (!z_is_thread_pending(thread)) &#123;</span><br><span class="line">           goto ready_event;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 线程已经到超时时间 */</span></span><br><span class="line">       <span class="keyword">if</span> (z_is_thread_timeout_expired(thread)) &#123;</span><br><span class="line">           return -EAGAIN;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 线程还在挂起态，唤醒 */</span></span><br><span class="line">       z_unpend_thread(thread);</span><br><span class="line">       z_set_thread_return_value(thread,</span><br><span class="line">                   state == K_POLL_STATE_CANCELLED ? -EINTR : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!z_is_thread_ready(thread)) &#123;</span><br><span class="line">           goto ready_event;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       z_ready_thread(thread);</span><br><span class="line"></span><br><span class="line">   ready_event:</span><br><span class="line">       set_event_ready(event, state);</span><br><span class="line">       return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 执行线程调度 */</span></span><br><span class="line">z_reschedule(&amp;lock, key);</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用poll可以在一个线程同时监视不同线程的不同消息，例如信号量，消息，fifo等。对于线程间消息通信比较多的情况可以使用这种方式，以避免每个消息都单独使用自己的一套而导致程序比较混乱。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>poll</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-semaphores</title>
    <url>/2018/08/30/zephyr-semaohores/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>zephyr系统调用实现在uart串口实例分析中做过分析，编程接口和实现函数之间的关联是通过一些脚本gen_syscall.py和gen_syscall_header.py两个脚本文件生成一系列头文件，在头文件中将编程API与实际实现函数关联起来，这是系统调用的实现方式，下面主要分析几个内核服务的实现方式。</p>
<h3 id="sem实现"><a href="#sem实现" class="headerlink" title="sem实现"></a>sem实现</h3><p>先交代下编程API与实现函数，在编译前会生成一系列头文件，syscall_macros.h文件里有sem接口调用函数，如下：</p>
<figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line">#if !defined(CONFIG_USERSPACE) || defined(__ZEPHYR_SUPERVISOR__)</span><br><span class="line">#define K_SYSCALL_DECLARE3_VOID(id, name, t0, p0, t1, p1, t2, p2) \</span><br><span class="line">	extern void z_impl_<span class="function"><span class="keyword">##</span><span class="title">name</span><span class="params">(<span class="variable">t0</span> <span class="variable">p0</span>, <span class="variable">t1</span> <span class="variable">p1</span>, <span class="variable">t2</span> <span class="variable">p2</span>)</span></span>; \</span><br><span class="line">	static inline void name(t0 p0, t1 p1, t2 p2) \</span><br><span class="line">	&#123; \</span><br><span class="line">		z_impl_<span class="function"><span class="keyword">##</span><span class="title">name</span><span class="params">(<span class="variable">p0</span>, <span class="variable">p1</span>, <span class="variable">p2</span>)</span></span>; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在kernel.h文件中引用了这些宏如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, <span class="params">k_sem_init</span>, <span class="params">struct</span> <span class="params">k_sem</span> <span class="operator">*</span>, <span class="params">sem</span>, <span class="params">unsigned</span> <span class="params">int</span>, <span class="params">initial_count</span>, <span class="params">unsigned</span> <span class="params">int</span>, <span class="params">limit</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, <span class="params">k_sem_take</span>, <span class="params">int</span>, <span class="params">struct</span> <span class="params">k_sem</span> <span class="operator">*</span>, <span class="params">sem</span>, <span class="params">s32_t</span>, <span class="params">timeout</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, <span class="params">k_sem_give</span>, <span class="params">struct</span> <span class="params">k_sem</span> <span class="operator">*</span>, <span class="params">sem</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_RESET, <span class="params">k_sem_reset</span>, <span class="params">struct</span> <span class="params">k_sem</span> <span class="operator">*</span>, <span class="params">sem</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">K_SYSCALL_DECLARE1(K_SYSCALL_K_SEM_COUNT_GET, <span class="params">k_sem_count_get</span>, <span class="params">unsigned</span> <span class="params">int</span>, <span class="params">struct</span> <span class="params">k_sem</span> <span class="operator">*</span>, <span class="params">sem</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_ALLOC_INIT, <span class="params">k_msgq_alloc_init</span>, <span class="params">int</span>, <span class="params">struct</span> <span class="params">k_msgq</span> <span class="operator">*</span>, <span class="params">q</span>, <span class="params">size_t</span>, <span class="params">msg_size</span>, <span class="params">u32_t</span>, <span class="params">max_msgs</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以看到实际k_sem_init调用z_impl_k_sem_init，下面主要看下sem.c文件里的几个关键函数</p>
<p><strong>z_impl_k_sem_init</strong><br>该函数主要给struct k_sem结构体赋值，其中重点关注下z_waitq_init函数调用sys_dlist_init(&amp;w-&gt;waitq);初始化一个链表，该链表以后将会insert或delete进线程，当获取不到信号量的时候会将当前线程加入该链表并supend线程，后面会有相关处理</p>
<p><strong>z_impl_k_sem_take</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不能在中断或不等待信号量 */</span></span><br><span class="line"><span class="constructor">__ASSERT(((<span class="params">z_is_in_isr</span>()</span><span class="operator"> == </span><span class="literal">false</span>)<span class="operator"> || </span>(timeout<span class="operator"> == </span>K_NO_WAIT)), <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">/* 枷锁 */</span></span><br><span class="line">k_spinlock_key_t key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">/* 如果信号量值大于0 则减信号量值*/</span></span><br><span class="line"><span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>U)) &#123;</span><br><span class="line">	sem-&gt;count--;</span><br><span class="line">	<span class="comment">/* 释放锁 */</span></span><br><span class="line">	k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">	sys<span class="constructor">_trace_end_call(SYS_TRACE_ID_SEMA_TAKE)</span>;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果超时时间是不等待，当前没有信号量可以获得则释放锁后返回 */</span></span><br><span class="line"><span class="keyword">if</span> (timeout<span class="operator"> == </span>K_NO_WAIT) &#123;</span><br><span class="line">	k<span class="constructor">_spin_unlock(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br><span class="line">	sys<span class="constructor">_trace_end_call(SYS_TRACE_ID_SEMA_TAKE)</span>;</span><br><span class="line">	return -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 超时时间不为0且没有获得信号量而将当前线程加入到wait_q链表里并挂起当前线程，在获得信号量或超时时间到达后唤醒线程 */</span></span><br><span class="line"><span class="built_in">int</span> ret = z<span class="constructor">_pend_curr(&amp;<span class="params">lock</span>, <span class="params">key</span>, &amp;<span class="params">sem</span>-&gt;<span class="params">wait_q</span>, <span class="params">timeout</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的注释中已经说明了各个函数的功能，下面列出z_pend_curr函数内容，包括其子函数调用用缩进代表调用关系</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">z_pend_curr</span><br><span class="line">	pend(_current, wait_q, timeout);</span><br><span class="line">		z_remove_thread_from_ready_q(<span class="keyword">thread</span>);</span><br><span class="line">		z_mark_thread_as_pending(<span class="keyword">thread</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (wait_q != <span class="built_in">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">thread</span>-&gt;base.pended_on = wait_q;</span><br><span class="line">			z_priq_wait_add(&amp;wait_q-&gt;waitq, <span class="keyword">thread</span>);</span><br><span class="line">				SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) &#123;</span><br><span class="line">					<span class="comment">/* 根据优先级将thread插入到链表的合适位置*/</span></span><br><span class="line">					<span class="keyword">if</span> (z_is_t1_higher_prio_than_t2(<span class="keyword">thread</span>, t)) &#123;</span><br><span class="line">					sys_dlist_insert(&amp;t-&gt;base.qnode_dlist,</span><br><span class="line">					 &amp;<span class="keyword">thread</span>-&gt;base.qnode_dlist);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				sys_dlist_append(pq, &amp;<span class="keyword">thread</span>-&gt;base.qnode_dlist);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> z_swap(lock, key);</span><br></pre></td></tr></table></figure>
<p>获取信号量时需要判断信号量的值，如果没有获得信号量则需要挂起当前线程直到获得信号量或超时时间到。</p>
<p><strong>z_impl_k_sem_give</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 禁止调度 */</span></span><br><span class="line">k_spinlock_key_t key = k<span class="constructor">_spin_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">sys<span class="constructor">_trace_void(SYS_TRACE_ID_SEMA_GIVE)</span>;</span><br><span class="line"><span class="keyword">do</span><span class="constructor">_sem_give(<span class="params">sem</span>)</span>;</span><br><span class="line">	<span class="comment">/* 获取没在挂起态的等待信号量的线程 */</span></span><br><span class="line">	<span class="keyword">struct</span> k_thread *thread = z<span class="constructor">_unpend_first_thread(&amp;<span class="params">sem</span>-&gt;<span class="params">wait_q</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (thread != NULL) &#123;</span><br><span class="line">		<span class="comment">/* 有等待该信号量的线程，将该线程设置为就绪态，加入就绪队列中 */</span></span><br><span class="line">		z<span class="constructor">_ready_thread(<span class="params">thread</span>)</span>;</span><br><span class="line">		<span class="comment">/* 设置返回值为0 线程获得执行相当于take了一次信号量，则信号量不需要再加一次，要紧、要紧、*/</span></span><br><span class="line">		z<span class="constructor">_set_thread_return_value(<span class="params">thread</span>, 0)</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*没有等待信号量而挂起的任务，则增加信号量值 */</span></span><br><span class="line">		increment<span class="constructor">_count_up_to_limit(<span class="params">sem</span>)</span>;</span><br><span class="line">		handle<span class="constructor">_poll_events(<span class="params">sem</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">sys<span class="constructor">_trace_end_call(SYS_TRACE_ID_SEMA_GIVE)</span>;</span><br><span class="line"><span class="comment">/* 恢复调度*/</span></span><br><span class="line">z<span class="constructor">_reschedule(&amp;<span class="params">lock</span>, <span class="params">key</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在增加信号量时需要注意在有等待该信号量的没有挂起的线程时直接将线程放入就绪队列中，则之前请求该信号量的线程将获得调度执行，此时不需要再对信号量进行增加。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>信号量可以实现两个线程的同步或者对共享资源的访问，里面涉及将线程挂起或恢复等操作。在使用时要特别注意，因为多个共享在两个或多个线程之间进行争夺资源时有可能会出现互锁的情况而导致两个线程都轮循调度却得不到执行，例如当线程A获得信号量A而线程B获得信号量B此时线程A需要获得B信号量线程B需要获得A信号量则两个线程都占据这资源请求其他资源，请求不到其他资源，自己获得的资源也得不到释放而导致两个线程僵死。对于信号量值limit为1的情况建议使用互斥锁，互斥锁有避免出现这种情况的机制。</p>
<p>o(￣▽￣)o！！！</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>zephyr semaphores</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-shell</title>
    <url>/2018/08/13/zephyr-shell/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在shell里主要完成命令读取，并匹配相应函数去执行，通过shell可以方便我们快速调试程序是个非常好用的工具，对此我们将在zephyr的子系统中去查看shell的具体实现。</p>
<h3 id="应用程序创建和注册"><a href="#应用程序创建和注册" class="headerlink" title="应用程序创建和注册"></a>应用程序创建和注册</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL_STATIC_SUBCMD_SET_CREATE(</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">sub_cmd,</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">SHELL_CMD(cmd, </span>NULL, <span class="string">&quot;cmd shell.&quot;</span>, <span class="keyword">shell_cmd),</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">SHELL_SUBCMD_SET_END </span><span class="comment">/* Array terminated. */</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SHELL_CMD_REGISTER(cmd_module, </span>&amp;<span class="keyword">sub_cmd, </span><span class="string">&quot;test commands&quot;</span>, NULL);</span><br></pre></td></tr></table></figure>
<p>上面两个宏完成cmd创建和注册.下面分析这两个宏定义</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define SHELL_STATIC_SUBCMD_SET_CREATE(name, ...)			\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell_static_entry shell_<span class="comment">##name[] = &#123;	\</span></span><br><span class="line">		__VA_ARGS__						<span class="string">\</span></span><br><span class="line">	&#125;;								<span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell_cmd_entry name = &#123;			<span class="string">\</span></span><br><span class="line">		.is_dynamic = <span class="literal">false</span>,					<span class="string">\</span></span><br><span class="line">		.u = &#123; .entry = shell_<span class="comment">##name &#125;				\</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个宏主要定义两个结构体并初始化他们，这里看下这两个结构图成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Shell command handler prototype.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param shell Shell instance.</span></span><br><span class="line"><span class="comment"> * @param argc  Arguments count.</span></span><br><span class="line"><span class="comment"> * @param argv  Arguments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @retval 0 Successful command execution.</span></span><br><span class="line"><span class="comment"> * @retval 1 Help printed and command not executed.</span></span><br><span class="line"><span class="comment"> * @retval -EINVAL Argument validation failed.</span></span><br><span class="line"><span class="comment"> * @retval -ENOEXEC Command not executed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*shell_cmd_handler)</span><span class="params">(<span class="keyword">const</span> struct shell *shell,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">size_t</span> argc, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief Shell static command descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shell_static_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *syntax;			<span class="comment">/*!&lt; Command syntax strings. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *help;			<span class="comment">/*!&lt; Command help string. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">shell_cmd_entry</span> *<span class="title">subcmd</span>;</span>	<span class="comment">/*!&lt; Pointer to subcommand. */</span></span><br><span class="line">	shell_cmd_handler handler;		<span class="comment">/*!&lt; Command handler. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shell_static_args</span> <span class="title">args</span>;</span>		<span class="comment">/*!&lt; Command arguments. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Shell dynamic command descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @details Function shall fill the received shell_static_entry structure</span></span><br><span class="line"><span class="comment"> * with requested (idx) dynamic subcommand data. If there is more than</span></span><br><span class="line"><span class="comment"> * one dynamic subcommand available, the function shall ensure that the</span></span><br><span class="line"><span class="comment"> * returned commands: entry-&gt;syntax are sorted in alphabetical order.</span></span><br><span class="line"><span class="comment"> * If idx exceeds the available dynamic subcommands, the function must</span></span><br><span class="line"><span class="comment"> * write to entry-&gt;syntax NULL value. This will indicate to the shell</span></span><br><span class="line"><span class="comment"> * module that there are no more dynamic commands to read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*shell_dynamic_get)</span><span class="params">(<span class="keyword">size_t</span> idx,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct shell_static_entry *entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Shell command descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shell_cmd_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> is_dynamic;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">union_cmd_entry</span> &#123;</span></span><br><span class="line">		<span class="comment">/*!&lt; Pointer to function returning dynamic commands.*/</span></span><br><span class="line">		shell_dynamic_get dynamic_get;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*!&lt; Pointer to array of static commands. */</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">shell_static_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line">	&#125; u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看SHELL_CMS宏</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Initializes a shell command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] _syntax	Command syntax (for example: history).</span></span><br><span class="line"><span class="comment"> * @param[in] _subcmd	Pointer to a subcommands array.</span></span><br><span class="line"><span class="comment"> * @param[in] _help	Pointer to a command help string.</span></span><br><span class="line"><span class="comment"> * @param[in] _handler	Pointer to a function handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">#define SHELL_CMD(_syntax, _subcmd, _help, _handler) \</span></span><br><span class="line">	SHELL_CMD_ARG(_syntax, _subcmd, _help, _handler, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#define SHELL_CMD_ARG(syntax, subcmd, help, handler, mand, opt) \</span></span><br><span class="line">	SHELL_EXPR_CMD_ARG(<span class="number">1</span>, syntax, subcmd, help, handler, mand, opt)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define SHELL_EXPR_CMD_ARG(_expr, _syntax, _subcmd, _help, _handler, \</span></span><br><span class="line">			   _mand, _opt) <span class="string">\</span></span><br><span class="line">	&#123; <span class="string">\</span></span><br><span class="line">		.syntax = (_expr) ? (<span class="keyword">const</span> char *)STRINGIFY(_syntax) : <span class="string">&quot;&quot;</span>, <span class="string">\</span></span><br><span class="line">		.help  = (_expr) ? (<span class="keyword">const</span> char *)_help : NULL, <span class="string">\</span></span><br><span class="line">		.subcmd = (<span class="keyword">const</span> struct shell_cmd_entry *)((_expr) ? <span class="string">\</span></span><br><span class="line">				_subcmd : NULL), <span class="string">\</span></span><br><span class="line">		.handler = (shell_cmd_handler)((_expr) ? _handler : NULL), <span class="string">\</span></span><br><span class="line">		.args = &#123; .mandatory = _mand, .optional = _opt&#125; <span class="string">\</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">#define SHELL_SUBCMD_SET_END &#123;NULL&#125;</span></span><br></pre></td></tr></table></figure>
<p>其成员刚好吻合struct shell_static_entry结构体的成员，因此第一个宏就是定义这两个结构体，里面包含shell 名称，函数句柄以及要传递的参数<br>下面看注册宏</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define SHELL_CMD_REGISTER(syntax, subcmd, help, handler) \</span></span><br><span class="line">	SHELL_CMD_ARG_REGISTER(syntax, subcmd, help, handler, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Macro for defining and adding a root command (level 0) with required</span></span><br><span class="line"><span class="comment"> * number of arguments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note Each root command shall have unique syntax. If a command will be called</span></span><br><span class="line"><span class="comment"> * with wrong number of arguments shell will print an error message and command</span></span><br><span class="line"><span class="comment"> * handler will not be called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] syntax	Command syntax (for example: history).</span></span><br><span class="line"><span class="comment"> * @param[in] subcmd	Pointer to a subcommands array.</span></span><br><span class="line"><span class="comment"> * @param[in] help	Pointer to a command help string.</span></span><br><span class="line"><span class="comment"> * @param[in] handler	Pointer to a function handler.</span></span><br><span class="line"><span class="comment"> * @param[in] mandatory	Number of mandatory arguments.</span></span><br><span class="line"><span class="comment"> * @param[in] optional	Number of optional arguments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">#define SHELL_CMD_ARG_REGISTER(syntax, subcmd, help, handler,		   \</span></span><br><span class="line">			       mandatory, optional)			   <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell_static_entry UTIL_CAT(_shell_, syntax) = <span class="string">\</span></span><br><span class="line">	SHELL_CMD_ARG(syntax, subcmd, help, handler, mandatory, optional); <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell_cmd_entry UTIL_CAT(shell_cmd_, syntax)   <span class="string">\</span></span><br><span class="line">	__attribute__ ((section(<span class="string">&quot;.&quot;</span>					   <span class="string">\</span></span><br><span class="line">			STRINGIFY(UTIL_CAT(shell_root_cmd_, syntax)))))	   <span class="string">\</span></span><br><span class="line">	__attribute__((used)) = &#123;					   <span class="string">\</span></span><br><span class="line">		.is_dynamic = <span class="literal">false</span>,					   <span class="string">\</span></span><br><span class="line">		.u = &#123;.entry = &amp;UTIL_CAT(_shell_, syntax)&#125;		   <span class="string">\</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>SHELL_CMD_ARG_REGISTER这个宏可以定义单独命令而不是模块</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Macro for defining and adding a root command (level 0) with required</span></span><br><span class="line"><span class="comment"> * number of arguments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note Each root command shall have unique syntax. If a command will be called</span></span><br><span class="line"><span class="comment"> * with wrong number of arguments shell will print an error message and command</span></span><br><span class="line"><span class="comment"> * handler will not be called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] syntax	Command syntax (for example: history).</span></span><br><span class="line"><span class="comment"> * @param[in] subcmd	Pointer to a subcommands array.</span></span><br><span class="line"><span class="comment"> * @param[in] help	Pointer to a command help string.</span></span><br><span class="line"><span class="comment"> * @param[in] handler	Pointer to a function handler.</span></span><br><span class="line"><span class="comment"> * @param[in] mandatory	Number of mandatory arguments.</span></span><br><span class="line"><span class="comment"> * @param[in] optional	Number of optional arguments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">#define SHELL_CMD_ARG_REGISTER(syntax, subcmd, help, handler,		   \</span></span><br><span class="line">			       mandatory, optional)			   <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell_static_entry UTIL_CAT(_shell_, syntax) = <span class="string">\</span></span><br><span class="line">	SHELL_CMD_ARG(syntax, subcmd, help, handler, mandatory, optional); <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell_cmd_entry UTIL_CAT(shell_cmd_, syntax)   <span class="string">\</span></span><br><span class="line">	__attribute__ ((section(<span class="string">&quot;.&quot;</span>					   <span class="string">\</span></span><br><span class="line">			STRINGIFY(UTIL_CAT(shell_root_cmd_, syntax)))))	   <span class="string">\</span></span><br><span class="line">	__attribute__((used)) = &#123;					   <span class="string">\</span></span><br><span class="line">		.is_dynamic = <span class="literal">false</span>,					   <span class="string">\</span></span><br><span class="line">		.u = &#123;.entry = &amp;UTIL_CAT(_shell_, syntax)&#125;		   <span class="string">\</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>同样是定义两个结构体并将其放入指定段中，这里看到两者的关系，SHELL_STATIC_SUBCMD_SET_CREATE创建了两个结构体，结构图成员是具体命令相关的成员，包括命令名称，帮助信息，函数句柄和参数列表，而SHELL_CMD_REGISTER同样创建两个结构图，这两个结构体引用SHELL_STATIC_SUBCMD_SET_CREATE定义的结构体且SHELL_CMD_REGISTER定义的结构体放入指定段中，在这段地址中将有这些子命令的入口。</p>
<h3 id="shell-thread"><a href="#shell-thread" class="headerlink" title="shell thread"></a>shell thread</h3><p>本文分析以uart输入为例进行分析，来看shell从获取命令、匹配命令和执行的流程是怎样的。<br>shell_uart.c是函数初始化的入口从这里开始看起，SYS_INIT(enable_shell_uart, POST_KERNEL, 0);开端。<br>SYS_INIT这个宏定义就是DEVICE_AND_API_INIT这个宏，在其他文章中有分析这个宏，就是在某个初始化阶段执行enable_shell_uart函数进行初始化。<br>在看enable_shell_uart之前先看两个宏</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">SHELL_UART_DEFINE(shell_transport_uart,</span><br><span class="line"><span class="built_in">		  CONFIG_SHELL_BACKEND_SERIAL_TX_RING_BUFFER_SIZE,</span></span><br><span class="line">		  CONFIG_SHELL_BACKEND_SERIAL_RX_RING_BUFFER_SIZE)<span class="comment">;</span></span><br><span class="line">SHELL_DEFINE(shell_uart, CONFIG_SHELL_PROMPT_UART, &amp;shell_transport_uart,</span><br><span class="line"><span class="built_in">	     CONFIG_SHELL_BACKEND_SERIAL_LOG_MESSAGE_QUEUE_SIZE,</span></span><br><span class="line"><span class="built_in">	     CONFIG_SHELL_BACKEND_SERIAL_LOG_MESSAGE_QUEUE_TIMEOUT,</span></span><br><span class="line">	     SHELL_FLAG_OLF_CRLF)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>第一个宏SHELL_UART_DEFINE</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief Macro for creating shell UART transport instance. */</span></span><br><span class="line">#define <span class="constructor">SHELL_UART_DEFINE(<span class="params">_name</span>, <span class="params">_tx_ringbuf_size</span>, <span class="params">_rx_ringbuf_size</span>)</span>	\</span><br><span class="line">	static <span class="keyword">struct</span> shell_uart_ctrl_blk _name##_ctrl_blk;		\</span><br><span class="line">	<span class="constructor">UART_SHELL_RX_TIMER_DECLARE(<span class="params">_name</span>)</span>;				\</span><br><span class="line">	<span class="constructor">UART_SHELL_TX_RINGBUF_DECLARE(<span class="params">_name</span>, <span class="params">_tx_ringbuf_size</span>)</span>;		\</span><br><span class="line">	<span class="constructor">RING_BUF_DECLARE(<span class="params">_name</span>##<span class="params">_rx_ringbuf</span>, <span class="params">_rx_ringbuf_size</span>)</span>;		\</span><br><span class="line">	static const <span class="keyword">struct</span> shell_uart _name##_shell_uart = &#123;		\</span><br><span class="line">		.ctrl_blk = &amp;_name##_ctrl_blk,				\</span><br><span class="line">		.timer = <span class="constructor">UART_SHELL_RX_TIMER_PTR(<span class="params">_name</span>)</span>,		\</span><br><span class="line">		.tx_ringbuf = <span class="constructor">UART_SHELL_TX_RINGBUF_PTR(<span class="params">_name</span>)</span>,		\</span><br><span class="line">		.rx_ringbuf = &amp;_name##_rx_ringbuf,			\</span><br><span class="line">	&#125;;								\</span><br><span class="line">	<span class="keyword">struct</span> shell_transport _name = &#123;				\</span><br><span class="line">		.api = &amp;shell_uart_transport_api,			\</span><br><span class="line">		.ctx = (<span class="keyword">struct</span> shell_uart *)&amp;_name##_shell_uart		\</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>定义两个结构体并初始化他们struct shell_uart和struct shell_transport，其中shell_uart_transport_api的内容如下</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">shell_transport_api</span> <span class="title">shell_uart_transport_api</span> =</span> &#123;</span><br><span class="line">	.init = init,</span><br><span class="line">	.uninit = uninit,</span><br><span class="line">	.enable = enable,</span><br><span class="line">	.<span class="built_in">write</span> = <span class="built_in">write</span>,</span><br><span class="line">	.<span class="built_in">read</span> = <span class="built_in">read</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MCUMGR_SMP_SHELL</span></span><br><span class="line">	.update = update,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_MCUMGR_SMP_SHELL */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>是通过串口进行数据读取写入的一系列函数指针<br>下面看另一个宏SHELL_DEFINE</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Macro for defining a shell instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] _name		Instance name.</span></span><br><span class="line"><span class="comment"> * @param[in] _prompt		Shell default prompt string.</span></span><br><span class="line"><span class="comment"> * @param[in] _transport_iface	Pointer to the transport interface.</span></span><br><span class="line"><span class="comment"> * @param[in] _log_queue_size	Logger processing queue size.</span></span><br><span class="line"><span class="comment"> * @param[in] _log_timeout	Logger thread timeout in milliseconds on full</span></span><br><span class="line"><span class="comment"> *				log queue. If queue is full logger thread is</span></span><br><span class="line"><span class="comment"> *				blocked for given amount of time before log</span></span><br><span class="line"><span class="comment"> *				message is dropped.</span></span><br><span class="line"><span class="comment"> * @param[in] _shell_flag	Shell output newline sequence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">#define SHELL_DEFINE(_name, _prompt, _transport_iface,			      \</span></span><br><span class="line">		     _log_queue_size, _log_timeout, _shell_flag)	      <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell _name;				      <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> struct shell_ctx UTIL_CAT(_name, _ctx);			      <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> u8_t _name<span class="comment">##_out_buffer[CONFIG_SHELL_PRINTF_BUFF_SIZE];	      \</span></span><br><span class="line">	SHELL_LOG_BACKEND_DEFINE(_name, _name<span class="comment">##_out_buffer,		      \</span></span><br><span class="line">				 CONFIG_SHELL_PRINTF_BUFF_SIZE,		      <span class="string">\</span></span><br><span class="line">				 _log_queue_size, _log_timeout);	      <span class="string">\</span></span><br><span class="line">	SHELL_HISTORY_DEFINE(_name<span class="comment">##_history, CONFIG_SHELL_HISTORY_BUFFER);   \</span></span><br><span class="line">	SHELL_FPRINTF_DEFINE(_name<span class="comment">##_fprintf, &amp;_name, _name##_out_buffer,     \</span></span><br><span class="line">			     CONFIG_SHELL_PRINTF_BUFF_SIZE,		      <span class="string">\</span></span><br><span class="line">			     <span class="literal">true</span>, shell_print_stream);			      <span class="string">\</span></span><br><span class="line">	LOG_INSTANCE_REGISTER(shell, _name, CONFIG_SHELL_LOG_LEVEL);	      <span class="string">\</span></span><br><span class="line">	SHELL_STATS_DEFINE(_name);					      <span class="string">\</span></span><br><span class="line">	<span class="keyword">static</span> K_THREAD_STACK_DEFINE(_name<span class="comment">##_stack, CONFIG_SHELL_STACK_SIZE); \</span></span><br><span class="line">	<span class="keyword">static</span> struct k_thread _name<span class="comment">##_thread;				      \</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> struct shell _name = &#123;				      <span class="string">\</span></span><br><span class="line">		.default_prompt = _prompt,				      <span class="string">\</span></span><br><span class="line">		.iface = _transport_iface,				      <span class="string">\</span></span><br><span class="line">		.ctx = &amp;UTIL_CAT(_name, _ctx),				      <span class="string">\</span></span><br><span class="line">		.history = IS_ENABLED(CONFIG_SHELL_HISTORY) ?		      <span class="string">\</span></span><br><span class="line">				&amp;_name<span class="comment">##_history : NULL,		      \</span></span><br><span class="line">		.shell_flag = _shell_flag,				      <span class="string">\</span></span><br><span class="line">		.fprintf_ctx = &amp;_name<span class="comment">##_fprintf,			      \</span></span><br><span class="line">		.stats = SHELL_STATS_PTR(_name),			      <span class="string">\</span></span><br><span class="line">		.log_backend = SHELL_LOG_BACKEND_PTR(_name),		      <span class="string">\</span></span><br><span class="line">		LOG_INSTANCE_PTR_INIT(log, shell, _name)		      <span class="string">\</span></span><br><span class="line">		.thread_name = STRINGIFY(_name),			      <span class="string">\</span></span><br><span class="line">		.thread = &amp;_name<span class="comment">##_thread,				      \</span></span><br><span class="line">		.stack = _name<span class="comment">##_stack					      \</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个shell instance并初始化该实例该实例为shell_uart。注意下.iface = _transport_iface,就好了，将两个结构体联系起来了。下面看enable_shell_uart这个函数（初始化）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *dev =</span><br><span class="line">		device<span class="constructor">_get_binding(CONFIG_UART_SHELL_ON_DEV_NAME)</span>;</span><br><span class="line"><span class="built_in">bool</span> log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL &gt; <span class="number">0</span>;</span><br><span class="line">u32_t level =</span><br><span class="line">	(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL &gt; LOG_LEVEL_DBG) ?</span><br><span class="line">	CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;</span><br><span class="line"></span><br><span class="line">shell<span class="constructor">_init(&amp;<span class="params">shell_uart</span>, <span class="params">dev</span>, <span class="params">true</span>, <span class="params">log_backend</span>, <span class="params">level</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>CONFIG_UART_SHELL_ON_DEV_NAME是串口名称这个可以通过配置进行修改，即shell使用的串口；shell_init完成对shell的一系列初始化，如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int err = instance_init(<span class="keyword">shell</span><span class="bash">, transport_config, use_colors);</span></span><br><span class="line"></span><br><span class="line">if (err != <span class="number">0</span>) &#123;</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k_tid_t tid = k_thread_create(<span class="keyword">shell</span><span class="bash">-&gt;thread,</span></span><br><span class="line">		      <span class="keyword">shell</span><span class="bash">-&gt;stack, CONFIG_SHELL_STACK_SIZE,</span></span><br><span class="line">		      shell_thread, (void *)<span class="keyword">shell</span><span class="bash">, (void *)log_backend,</span></span><br><span class="line">		      UINT_TO_POINTER(init_log_level),</span><br><span class="line">		      K_LOWEST_APPLICATION_THREAD_PRIO, <span class="number">0</span>, K_NO_WAIT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">shell</span><span class="bash">-&gt;ctx-&gt;tid = tid;</span></span><br><span class="line">k_thread_name_set(tid, <span class="keyword">shell</span><span class="bash">-&gt;thread_name);</span></span><br></pre></td></tr></table></figure>
<p>展开instance_init</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* 完成对串口相关配置和初始化 */</span></span><br><span class="line">	<span class="function"><span class="title">int</span> err = shell-&gt;</span><span class="function"><span class="title">iface</span>-&gt;</span><span class="function"><span class="title">api</span>-&gt;</span><span class="function"><span class="title">init</span>(shell-&gt;</span>iface, p_config,</span><br><span class="line">					  transport_evt_handler,</span><br><span class="line">					  (void *) shell);</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* 完成对history的初始化，使用链表存储history 也就是初始化链表 */</span></span><br><span class="line">	history_init(shell);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化互斥锁 */</span></span><br><span class="line">	<span class="function"><span class="title">k_mutex_init</span>(&amp;shell-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>wr_mtx);</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* 初始化single和event */</span></span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; SHELL_SIGNALS; i++) &#123;</span><br><span class="line">		<span class="function"><span class="title">k_poll_signal_init</span>(&amp;shell-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>signals[i]);</span><br><span class="line">		<span class="function"><span class="title">k_poll_event_init</span>(&amp;shell-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>events[i],</span><br><span class="line">				  K_POLL_TYPE_SIGNAL,</span><br><span class="line">				  K_POLL_MODE_NOTIFY_ONLY,</span><br><span class="line">				  &amp;<span class="function"><span class="title">shell</span>-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>signals[i]);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* 其他初始化设置 主要是设置一些标志位 flag_tx_rdy, flag_echo,flag_use_colors_set etc. */</span></span><br></pre></td></tr></table></figure>
<p>k_thread_create创建一个线程去处理shell相关任务，线程为shell_thread，如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 调用shall_uart的enable函数 */</span></span><br><span class="line"><span class="function"><span class="title">shell</span>-&gt;</span><span class="function"><span class="title">iface</span>-&gt;</span><span class="function"><span class="title">api</span>-&gt;</span><span class="function"><span class="title">enable</span>(shell-&gt;</span>iface, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断log是否开启，如果开启则初始化先关内容 */</span></span><br><span class="line"><span class="keyword">if</span> (log_backend &amp;&amp; IS_ENABLED(CONFIG_LOG)) &#123;</span><br><span class="line">	<span class="function"><span class="title">shell_log_backend_enable</span>(shell-&gt;</span>log_backend, (void *)shell,</span><br><span class="line">				 log_level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置SHELL_STATE_ACTIVE */</span></span><br><span class="line">shell_start(shell);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一直等待single，events 并处理相关single*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="comment">/* waiting for all signals except SHELL_SIGNAL_TXDONE */</span></span><br><span class="line">	<span class="function"><span class="title">err</span> = k_poll(shell-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>events, SHELL_SIGNAL_TXDONE,</span><br><span class="line">		     K_FOREVER);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">k_mutex_lock</span>(&amp;shell-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>wr_mtx, K_FOREVER);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		shell_internal_fprintf(shell, SHELL_ERROR,</span><br><span class="line">				       <span class="string">&quot;Shell thread error: %d&quot;</span>, err);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (shell-&gt;</span><span class="function"><span class="title">iface</span>-&gt;</span><span class="function"><span class="title">api</span>-&gt;</span>update) &#123;</span><br><span class="line">		<span class="function"><span class="title">shell</span>-&gt;</span><span class="function"><span class="title">iface</span>-&gt;</span><span class="function"><span class="title">api</span>-&gt;</span><span class="function"><span class="title">update</span>(shell-&gt;</span>iface);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);</span><br><span class="line">	shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_LOG)) &#123;</span><br><span class="line">		shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,</span><br><span class="line">				    shell_log_process);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">k_mutex_unlock</span>(&amp;shell-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>wr_mtx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);如果收到这个信号则进行shell_process处理。这个信号是哪里发送的呢，我们可以想象这个信号应该是在接收完命令或者发送命令的时候发送的，回到instance_init这个函数，shell-&gt;iface-&gt;api-&gt;init(shell-&gt;iface, p_config，transport_evt_handler,（void*)shell);执行shell_uart.c里的init函数将transport_evt_handler这个函数指针传递过去，而transport_evt_handler这个函数恰好是产生single的函数，不信我们看下内容</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shell</span></span> *shell = (<span class="class"><span class="keyword">struct</span> <span class="title">shell</span></span> *)ctx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_poll_signal</span></span> *signal;</span><br><span class="line"></span><br><span class="line">signal = (evt_type == SHELL_TRANSPORT_EVT_RX_RDY) ?</span><br><span class="line">		&amp;shell-&gt;ctx-&gt;signals[SHELL_SIGNAL_RXRDY] :</span><br><span class="line">		&amp;shell-&gt;ctx-&gt;signals[SHELL_SIGNAL_TXDONE];</span><br><span class="line">k_poll_signal_raise(signal, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>回到init函数，</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">sh_uart</span>-&gt;</span><span class="function"><span class="title">ctrl_blk</span>-&gt;</span>handler = evt_handler;</span><br></pre></td></tr></table></figure>
<p>将该函数指针赋值给sh_uart-&gt;ctrl_blk-&gt;handler，我们看串口接收回调函数和发送函数便可一目了然了uart_rx_handle如下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (new_data) &#123;</span><br><span class="line">		<span class="function"><span class="title">sh_uart</span>-&gt;</span><span class="function"><span class="title">ctrl_blk</span>-&gt;</span>handler(SHELL_TRANSPORT_EVT_RX_RDY,</span><br><span class="line">					   <span class="function"><span class="title">sh_uart</span>-&gt;</span><span class="function"><span class="title">ctrl_blk</span>-&gt;</span>context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果有新数据则调用handler，产生SHELL_TRANSPORT_EVT_RX_RDY single。同样uart_tx_handle也会调用handler产生SHELL_TRANSPORT_EVT_TX_RDY信号。现在信号的产生都清楚了，下面看看对SHELL_SIGNAL_RXRDY信号的处理函数shell_process，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">/* 根据<span class="keyword">shell</span><span class="bash">状态做出不同处理 如果为SHELL_STATE_ACTIVE则进行如下处理 */</span></span><br><span class="line">case SHELL_STATE_ACTIVE:</span><br><span class="line">	state_collect(<span class="keyword">shell</span><span class="bash">);</span></span><br><span class="line">	break;</span><br></pre></td></tr></table></figure>
<p>进入state_collect如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* 调用串口读数据，获得shell命令参数 */</span></span><br><span class="line">	<span class="function"><span class="title">shell</span>-&gt;</span><span class="function"><span class="title">iface</span>-&gt;</span><span class="function"><span class="title">api</span>-&gt;</span><span class="function"><span class="title">read</span>(shell-&gt;</span>iface, &amp;<span class="keyword">data</span>,sizeof(<span class="keyword">data</span>), &amp;count);</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* Command execution */</span></span><br><span class="line">	execute(shell)</span><br></pre></td></tr></table></figure>
<p>进入execute函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* 清空active_cmd */</span></span><br><span class="line">	memset(&amp;shell-&gt;ctx-&gt;active_cmd, <span class="number">0</span>, sizeof(shell-&gt;ctx-&gt;active_cmd));</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* 在之前通过宏定义的那些结构体存放的地址中取出每一个entry放入p_static_entry，后面紧跟的三行是下面函数内容缩进表调用关系 */</span></span><br><span class="line">	shell<span class="constructor">_cmd_get(<span class="params">shell</span>, <span class="params">p_cmd</span>, <span class="params">cmd_lvl</span>, <span class="params">cmd_idx</span><span class="operator">++</span>, &amp;<span class="params">p_static_entry</span>,&amp;<span class="params">d_entry</span>)</span>;</span><br><span class="line">			cmd = shell<span class="constructor">_root_cmd_get(<span class="params">idx</span>)</span>;</span><br><span class="line">				return &amp;__shell_root_cmds_start<span class="literal">[<span class="identifier">id</span>]</span>;</span><br><span class="line">			*entry = cmd-&gt;u.entry;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* 匹配argv和p_static_entry是否相同 */</span></span><br><span class="line">	<span class="keyword">if</span> (strcmp(argv<span class="literal">[<span class="identifier">cmd_lvl</span>]</span>, p_static_entry-&gt;syntax)<span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* 调用 handler 即用户自定义的那些命令 */</span></span><br><span class="line">	return exec<span class="constructor">_cmd(<span class="params">shell</span>, <span class="params">argc</span> - <span class="params">cmd_with_handler_lvl</span>,&amp;<span class="params">argv</span>[<span class="params">cmd_with_handler_lvl</span>], &amp;<span class="params">help_entry</span>)</span>;</span><br><span class="line">		ret_val = shell-&gt;ctx-&gt;active_cmd.handler(shell, argc, argv);</span><br></pre></td></tr></table></figure>
<p>到此就是shell模块静态命令的执行过程，动态命令也是在这个流程里执行的，这里面有很多条件判断没有进行分析，log的输出也在这其中，整个调用过程较为复杂，函数调用层次较深。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>我们在自定义shell命令的时候通过SHELL_CMD_ARG_REGISTER注册单独命令，通过SHELL_STATIC_SUBCMD_SET_CREATE和SHELL_CMD_REGISTER注册模块命令，即select命令，这两个宏实际上是定义并初始化几个结构体，并将其放入指定的段中，</li>
<li>shell通过开辟一个单独的线程实现shell命令解析和执行，shell需要一个交互通信协议，可选的有serial和telnet，本文分析了serial的方式，包括serial初始化以及其他配置，然后进行shell_init初始化，创建线程，线程里等到single进行处理，当串口接收到一行数据时发出single此时线程根据不同single做出不同的处理，对SHELL_SIGNAL_RXRDY信号执行shell_process，主要完成命令的匹配在指定段内遍历结构图找到命令entry然后调用handler，handler指向第一步创建的结构体的自定义命令函数，从而实现通过命令调用对应函数实体。<br>o(￣▽￣)d have fun</li>
</ol>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-stack</title>
    <url>/2019/08/18/zephyr-stack/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>stack是最要的数据结构之一，栈提供push和pop操作后入先出，先进后出的特性.</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct k_stack &#123;</span><br><span class="line">	_wait_q_t wait_q;</span><br><span class="line">	struct k_spinlock lock;</span><br><span class="line">	stack_data_t *base, *next, *top;</span><br><span class="line"></span><br><span class="line">	_OBJECT_TRACING_NEXT_PTR(k_stack)</span><br><span class="line">	u8_t flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_stack_init</span><span class="params">(struct k_stack *<span class="built_in">stack</span>, <span class="keyword">stack_data_t</span> *<span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">		  <span class="keyword">u32_t</span> num_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化等待队列*/</span></span><br><span class="line">	z_waitq_init(&amp;<span class="built_in">stack</span>-&gt;wait_q);</span><br><span class="line">	<span class="built_in">stack</span>-&gt;lock = (struct k_spinlock) &#123;&#125;;</span><br><span class="line">    <span class="comment">/* 给栈低，栈指针，栈顶赋值 */</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;next = <span class="built_in">stack</span>-&gt;base = <span class="built_in">buffer</span>;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;base + num_entries;</span><br><span class="line"></span><br><span class="line">	SYS_TRACING_OBJ_INIT(k_stack, <span class="built_in">stack</span>);</span><br><span class="line">	z_object_init(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void z_impl_k_stack_push(struct k_stack *stack, stack_data_t data)</span><br><span class="line">&#123;</span><br><span class="line">	struct k_thread *first_pending_thread;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line"></span><br><span class="line">	__ASSERT(stack-&gt;next != stack-&gt;top, <span class="string">&quot;stack is full&quot;</span>);</span><br><span class="line"></span><br><span class="line">	key = k_spin_lock(&amp;stack-&gt;lock);</span><br><span class="line"></span><br><span class="line">	first_pending_thread = z_unpend_first_thread(&amp;stack-&gt;wait_q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (first_pending_thread != NULL) &#123;</span><br><span class="line">        /* 如果资源被占用则执行任务调度 */</span><br><span class="line">		z_ready_thread(first_pending_thread);</span><br><span class="line"></span><br><span class="line">		z_set_thread_return_value_with_data(first_pending_thread, 0, (void *)data);</span><br><span class="line">            /* 将数据放入请求线程的swap_data里*/</span><br><span class="line">            z_set_thread_return_value(thread, value);</span><br><span class="line">	        thread-&gt;base.swap_data = data;</span><br><span class="line">		z_reschedule(&amp;stack-&gt;lock, key);</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /* 资源可用，将数据放入stack中 */</span><br><span class="line">		*(stack-&gt;next) = data;</span><br><span class="line">		stack-&gt;next++;</span><br><span class="line">		k_spin_unlock(&amp;stack-&gt;lock, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int z_impl_k_stack_pop(struct k_stack *stack, stack_data_t *data, s32_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	k_spinlock_key_t key;</span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	key = k_spin_lock(&amp;stack-&gt;lock);</span><br><span class="line"></span><br><span class="line">    /* 有数据，取出数据 */</span><br><span class="line">	<span class="keyword">if</span> (likely(stack-&gt;next &gt; stack-&gt;base)) &#123;</span><br><span class="line">		stack-&gt;next--;</span><br><span class="line">		*data = *(stack-&gt;next);</span><br><span class="line">		k_spin_unlock(&amp;stack-&gt;lock, key);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 没有数据且不等待，直接返回 */</span><br><span class="line">	<span class="keyword">if</span> (timeout == K_NO_WAIT) &#123;</span><br><span class="line">		k_spin_unlock(&amp;stack-&gt;lock, key);</span><br><span class="line">		<span class="built_in">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 没有数据，等待数据，将自家pend起来*/</span><br><span class="line">	result = z_pend_curr(&amp;stack-&gt;lock, key, &amp;stack-&gt;wait_q, timeout);</span><br><span class="line">	<span class="keyword">if</span> (result == -EAGAIN) &#123;</span><br><span class="line">		<span class="built_in">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 栈为空，push函数发现有线程请求数据，则将数据放入请求线程的swap_data里，取出数据*/</span><br><span class="line">	*data = (stack_data_t)_current-&gt;base.swap_data;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-start</title>
    <url>/2018/08/26/zephyr-start/</url>
    <content><![CDATA[<h3 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h3><p>我们知道芯片上电后会自动复位即跳到reset处运行，这就是芯片启动分析的入口，找到reset标号</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">SECTION_SUBSEC_FUNC</span>(TEXT,_reset_section,__start)</span><br><span class="line"></span><br><span class="line"><span class="comment">#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)</span></span><br><span class="line">    <span class="keyword">bl</span> _PlatformInit</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock interrupts: will get unlocked when switch to main task */</span></span><br><span class="line"><span class="comment">#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)</span></span><br><span class="line">    <span class="keyword">cpsid</span> i</span><br><span class="line"><span class="comment">#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)</span></span><br><span class="line">    movs.n <span class="built_in">r0</span>, <span class="symbol">#_EXC_IRQ_DEFAULT_PRIO</span></span><br><span class="line">    <span class="keyword">msr</span> BASEPRI, <span class="built_in">r0</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#error Unknown ARM architecture</span></span><br><span class="line"><span class="comment">#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_WDOG_INIT</span></span><br><span class="line">    <span class="comment">/* board-specific watchdog initialization is necessary */</span></span><br><span class="line">    <span class="keyword">bl</span> _WdogInit</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_INIT_STACKS</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="symbol">=_interrupt_stack</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, <span class="number">=0xaa</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, <span class="symbol">=CONFIG_ISR_STACK_SIZE</span></span><br><span class="line">    <span class="keyword">bl</span> memset</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set PSP and use it to boot without using MSP, so that it</span></span><br><span class="line"><span class="comment">     * gets set to _interrupt_stack during initialisation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="symbol">=_interrupt_stack</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, <span class="symbol">=CONFIG_ISR_STACK_SIZE</span></span><br><span class="line">    <span class="keyword">adds</span> <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">msr</span> PSP, <span class="built_in">r0</span></span><br><span class="line">    movs.n <span class="built_in">r0</span>, <span class="number">#2</span>	<span class="comment">/* switch to using PSP (bit1 of CONTROL reg) */</span></span><br><span class="line">    <span class="keyword">msr</span> CONTROL, <span class="built_in">r0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When changing the stack pointer, software must use an ISB instruction</span></span><br><span class="line"><span class="comment">     * immediately after the MSR instruction. This ensures that instructions</span></span><br><span class="line"><span class="comment">     * after the ISB instruction execute using the new stack pointer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    <span class="keyword">b</span> _PrepC</span><br></pre></td></tr></table></figure>
<p>函数流程如下：<br>1、一系列条件编译，有可能会有平台初始化，看门狗初始化<br>2、关中断<br>3、设置psp为栈指针，不使用msp<br>4、跳转到_PrepC运行<br>设置好sp指针之后就到了c环境下运行了</p>
<h3 id="C阶段"><a href="#C阶段" class="headerlink" title="C阶段"></a>C阶段</h3><p>PrepC函数就在PrepC_c.c文件内，其函数内容如下：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void <span class="variable">_PrepC</span>(void)</span><br><span class="line">&#123;</span><br><span class="line">	relocate_vector_table();</span><br><span class="line">	enable_floating_point();</span><br><span class="line">	<span class="variable">_bss_zero</span>();</span><br><span class="line">	<span class="variable">_data_copy</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOOT_TIME_MEASUREMENT</span></span><br><span class="line">	<span class="variable">__start_time_stamp</span> = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="variable">_Cstart</span>();</span><br><span class="line">	CODE_UNREACHABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数流程如下<br>1、重定位向量表<br>2、使能浮点运算<br>3、bss段清零<br>4、数据拷贝<br>5、执行Cstart函数</p>
<p>下面是Cstart函数内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FUNC_NORETURN <span class="keyword">void</span> _Cstart(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> *<span class="title">dummy_thread</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* Normally, kernel objects are not allowed on the stack, special case</span></span><br><span class="line"><span class="comment">	 * here since this is just being used to bootstrap the first _Swap()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> dummy_thread_memory[<span class="keyword">sizeof</span>(struct k_thread)];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> *<span class="title">dummy_thread</span> =</span> (struct k_thread *)&amp;dummy_thread_memory;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(dummy_thread_memory, <span class="number">0</span>, <span class="keyword">sizeof</span>(dummy_thread_memory));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The interrupt library needs to be initialized early since a series</span></span><br><span class="line"><span class="comment">	 * of handlers are installed into the interrupt table to catch</span></span><br><span class="line"><span class="comment">	 * spurious interrupts. This must be performed before other kernel</span></span><br><span class="line"><span class="comment">	 * subsystems install bonafide handlers, or before hardware device</span></span><br><span class="line"><span class="comment">	 * drivers are initialized.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	_IntLibInit();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* perform any architecture-specific initialization */</span></span><br><span class="line">	kernel_arch_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* perform basic hardware initialization */</span></span><br><span class="line">	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);</span><br><span class="line">	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACK_CANARIES</span></span><br><span class="line">	__stack_chk_guard = z_early_boot_rand32_get();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	prepare_multithreading(dummy_thread);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* display boot banner */</span></span><br><span class="line"></span><br><span class="line">	switch_to_main_thread();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Compiler can&#x27;t tell that the above routines won&#x27;t return and issues</span></span><br><span class="line"><span class="comment">	 * a warning unless we explicitly tell it that control never gets this</span></span><br><span class="line"><span class="comment">	 * far.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	CODE_UNREACHABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、分配一个线程空间<br>2、初始化库<br>3、初始化一部分设备根据优先级<br>4、准备多线程环境<br>5、切换到main thread运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">switch_to_main_thread</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN</span></span><br><span class="line">	_arch_switch_to_main_thread(_main_thread, _main_stack, MAIN_STACK_SIZE,</span><br><span class="line">				    bg_thread_main);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Context switch to main task (entry function is _main()): the</span></span><br><span class="line"><span class="comment">	 * current fake thread is not on a wait queue or ready queue, so it</span></span><br><span class="line"><span class="comment">	 * will never be rescheduled in.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	_Swap(irq_lock());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bg_thread_main</span><span class="params">(<span class="keyword">void</span> *unused1, <span class="keyword">void</span> *unused2, <span class="keyword">void</span> *unused3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ARG_UNUSED(unused1);</span><br><span class="line">	ARG_UNUSED(unused2);</span><br><span class="line">	ARG_UNUSED(unused3);</span><br><span class="line"></span><br><span class="line">	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_STACK_POINTER_RANDOM</span></span><br><span class="line">	z_stack_adjust_initialized = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (boot_delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;***** delaying boot &quot;</span> STRINGIFY(CONFIG_BOOT_DELAY)</span><br><span class="line">		       <span class="string">&quot;ms (per build configuration) *****\n&quot;</span>);</span><br><span class="line">		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);</span><br><span class="line">	&#125;</span><br><span class="line">	PRINT_BOOT_BANNER();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Final init level before app starts */</span></span><br><span class="line">	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPLUSPLUS</span></span><br><span class="line">	<span class="comment">/* Process the .ctors and .init_array sections */</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">void</span> __do_global_ctors_aux(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">void</span> __do_init_array_aux(<span class="keyword">void</span>);</span><br><span class="line">	__do_global_ctors_aux();</span><br><span class="line">	__do_init_array_aux();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	_init_static_threads();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	smp_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOOT_TIME_MEASUREMENT</span></span><br><span class="line">	<span class="comment">/* record timestamp for kernel&#x27;s _main() function */</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">u64_t</span> __main_time_stamp;</span><br><span class="line"></span><br><span class="line">	__main_time_stamp = (<span class="keyword">u64_t</span>)k_cycle_get_32();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	main();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Terminate thread normally since it has no more work to do */</span></span><br><span class="line">	_main_thread-&gt;base.user_options &amp;= ~K_ESSENTIAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、通过一系列函数跳转到bg_thread_main<br>2、配置初始化一部分设备<br>3、继续初始化设备，完成所有设备初始化<br>4、初始化静态线程<br>5、执行main函数<br>到这里就运行到main()函数了，可以看到main函数也是一个线程，该线程可以创建其他线程。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>zephyr</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-thread</title>
    <url>/2019/08/17/zephyr-thread/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Thread或Task是操作系统最重要的概念了，在zephyr中为thread本质上和task一样，实现多任务的并行运行，这个实际上是在多个任务之间轮循执行只是他们之间的切换很快看上去是并行执行的，那么要完成在多个任务之间的切换调度就需要在切换时保存运行环境以在调度回来时可以继续运行，这就是需要为线程开辟自己的栈空间，多任务之间的重要程度不同就是优先级，对于重要任务需要优先执行，这就是thread的优先级，另外thread处在运行中还是挂起等待运行中等需要有任务运行状态，同时任务之间可能有事件的发生还需要任务之间可以通讯传输数据。这些是thread最基本的需要有的，下面看下zephyr系统下的实现：</p>
<p><strong>z_impl_k_thread_create</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   __ASSERT(!z_is_in_isr(), <span class="string">&quot;Threads may not be created in ISRs&quot;</span>);</span><br><span class="line">z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,prio, options, NULL);</span><br><span class="line">       stack_size = adjust_stack_size(stack_size);</span><br><span class="line">       /* 由于线程数据与具体cpu相关，因此需要进入具体架构目录下 */</span><br><span class="line">       z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,prio, options);</span><br><span class="line"></span><br><span class="line">   /* thread delay不是无限等待则执行线程调度 */</span><br><span class="line">   <span class="keyword">if</span> (delay != K_FOREVER) &#123;</span><br><span class="line">	schedule_new_thread(new_thread, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文以cortex-m4为例进行分析进入arch/arm/core/thread.c文件中进行创建线程，函数如下<br><strong>z_new_thread</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   struct __esf *pInitCtx;</span><br><span class="line">	/* ARM GPRs are often designated by two different names */</span><br><span class="line">	<span class="comment">#define sys_define_gpr_with_alias(name1, name2) union &#123; u32_t name1, name2; &#125;</span></span><br><span class="line">	struct __esf &#123;</span><br><span class="line">		struct __basic_sf &#123;</span><br><span class="line">			sys_define_gpr_with_alias(a1, r0);</span><br><span class="line">			sys_define_gpr_with_alias(a2, r1);</span><br><span class="line">			sys_define_gpr_with_alias(a3, r2);</span><br><span class="line">			sys_define_gpr_with_alias(a4, r3);</span><br><span class="line">			sys_define_gpr_with_alias(ip, r12);</span><br><span class="line">			sys_define_gpr_with_alias(lr, r14);</span><br><span class="line">			sys_define_gpr_with_alias(pc, r15);</span><br><span class="line">			u32_t xpsr;</span><br><span class="line">		&#125; basic;</span><br><span class="line">	<span class="comment">#if defined(CONFIG_FLOAT) &amp;&amp; defined(CONFIG_FP_SHARING)</span></span><br><span class="line">		<span class="built_in">float</span> s[16];</span><br><span class="line">		u32_t fpscr;</span><br><span class="line">		u32_t undefined;</span><br><span class="line">	<span class="comment">#endif</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">z_new_thread_init(thread, pStackMem, stackSize, priority, options);</span><br><span class="line">	/* 清空栈空间 */</span><br><span class="line">	<span class="comment">#ifdef CONFIG_INIT_STACKS</span></span><br><span class="line">		memset(pStack, 0xaa, stackSize);</span><br><span class="line">	<span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* 设置线程标志，如果不存在这个标志则终止线程 */</span><br><span class="line">	/* Put the stack sentinel at the lowest 4 bytes of the stack area.</span><br><span class="line">	 * We periodically check that it<span class="string">&#x27;s still present and kill the thread</span></span><br><span class="line"><span class="string">	 * if it isn&#x27;</span>t.</span><br><span class="line">	 */</span><br><span class="line">	*((u32_t *)pStack) = STACK_SENTINEL;</span><br><span class="line"></span><br><span class="line">	/* static threads overwrite it afterwards with real value */</span><br><span class="line">	thread-&gt;init_data = NULL;</span><br><span class="line">	thread-&gt;fn_abort = NULL;</span><br><span class="line"></span><br><span class="line">	/* 设置栈信息 */</span><br><span class="line">	<span class="comment">#if defined(CONFIG_THREAD_STACK_INFO)</span></span><br><span class="line">		thread-&gt;stack_info.start = (uintptr_t)pStack;</span><br><span class="line">		thread-&gt;stack_info.size = (u32_t)stackSize;</span><br><span class="line">	<span class="comment">#endif /* CONFIG_THREAD_STACK_INFO */		</span></span><br><span class="line"></span><br><span class="line">   /* Carve the thread entry struct from the <span class="string">&quot;base&quot;</span> of the stack</span><br><span class="line"> *</span><br><span class="line"> * The initial carved stack frame only needs to contain the basic</span><br><span class="line"> * stack frame (state context), because no FP operations have been</span><br><span class="line"> * performed yet <span class="keyword">for</span> this thread.</span><br><span class="line"> */</span><br><span class="line">    /* 在栈底留出一块区域专门用于保存pInitCtx */</span><br><span class="line">pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -</span><br><span class="line">	(char *)top_of_stack_offset - sizeof(struct __basic_sf)));</span><br><span class="line"></span><br><span class="line">/* 这段代码非常重要，告诉了我们函数入口为z_thread_entry 且a1,a2,a3,a4是其参数，在后面进行任务切换的时候就是将这几个值恢复到寄存器中运行，跟踪发现最终调用*pEntry指向的函数，就是我们自己实现的thread函数 */</span><br><span class="line"><span class="comment">#if defined(CONFIG_USERSPACE)</span></span><br><span class="line">	<span class="keyword">if</span> ((options &amp; K_USER) != 0) &#123;</span><br><span class="line">		pInitCtx-&gt;basic.pc = (u32_t)z_arch_user_mode_enter;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pInitCtx-&gt;basic.pc = (u32_t)z_thread_entry;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	pInitCtx-&gt;basic.pc = (u32_t)z_thread_entry;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">   /* force ARM mode by clearing LSB of address */</span><br><span class="line">pInitCtx-&gt;basic.pc &amp;= 0xfffffffe;</span><br><span class="line"></span><br><span class="line">pInitCtx-&gt;basic.a1 = (u32_t)pEntry;</span><br><span class="line">pInitCtx-&gt;basic.a2 = (u32_t)parameter1;</span><br><span class="line">pInitCtx-&gt;basic.a3 = (u32_t)parameter2;</span><br><span class="line">pInitCtx-&gt;basic.a4 = (u32_t)parameter3;</span><br><span class="line">pInitCtx-&gt;basic.xpsr =0x01000000UL; /* clear all, thumb bit is 1, even <span class="keyword">if</span> RO */</span><br><span class="line"></span><br><span class="line">thread-&gt;callee_saved.psp = (u32_t)pInitCtx;</span><br><span class="line">thread-&gt;arch.basepri = 0;</span><br></pre></td></tr></table></figure>
<p>以上部分主要完成对thread的数据初始化准备栈空间等一系列任务。</p>
<p><strong>schedule_new_thread</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 超时时间到则k_thread_start否则累加时间 */</span><br><span class="line"><span class="comment">#ifdef CONFIG_SYS_CLOCK_EXISTS</span></span><br><span class="line">	<span class="keyword">if</span> (delay == 0) &#123;</span><br><span class="line">		/* k_thread_start实际调用z_impl_k_thread_start */</span><br><span class="line">		k_thread_start(thread);</span><br><span class="line">			k_spinlock_key_t key = k_spin_lock(&amp;lock); /* protect kernel queues */</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (z_has_thread_started(thread)) &#123;</span><br><span class="line">				k_spin_unlock(&amp;lock, key);</span><br><span class="line">				<span class="built_in">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			z_mark_thread_as_started(thread);</span><br><span class="line">				thread-&gt;base.thread_state &amp;= ~_THREAD_PRESTART;	</span><br><span class="line">			z_ready_thread(thread);</span><br><span class="line">				<span class="keyword">if</span> (z_is_thread_ready(thread)) &#123;</span><br><span class="line">					z_add_thread_to_ready_q(thread);</span><br><span class="line">							LOCKED(&amp;sched_spinlock) &#123;</span><br><span class="line">								/*这里涉及一个数据结构struct z_kernel 这是个内核结构，系统内只有一个实体，成员有ready_q成员保存就绪态thread，timeout_q超时队列等 */</span><br><span class="line">								_priq_run_add(&amp;_kernel.ready_q.runq, thread);</span><br><span class="line">								z_mark_thread_as_queued(thread);</span><br><span class="line">								update_cache(0);</span><br><span class="line">							&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			z_reschedule(&amp;lock, key);</span><br><span class="line">				static ALWAYS_INLINE int z_swap(struct k_spinlock *lock, k_spinlock_key_t key)</span><br><span class="line">				&#123;</span><br><span class="line">					k_spin_release(lock);</span><br><span class="line">					<span class="built_in">return</span> z_swap_irqlock(key.key);</span><br><span class="line">						__swap(key)；</span><br><span class="line">								/* store off key and <span class="built_in">return</span> value */</span><br><span class="line">								_current-&gt;arch.basepri = key;</span><br><span class="line">								_current-&gt;arch.swap_return_value = _k_neg_eagain;</span><br><span class="line"></span><br><span class="line">								/* <span class="built_in">set</span> pending bit to make sure we will take a PendSV exception */</span><br><span class="line">								SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk;</span><br><span class="line"></span><br><span class="line">								/* clear mask or <span class="built_in">enable</span> all irqs to take a pendsv */</span><br><span class="line">								irq_unlock(0);</span><br><span class="line"></span><br><span class="line">								/* Context switch is performed here. Returning implies the</span><br><span class="line">								 * thread has been context-switched-in again.</span><br><span class="line">								 */</span><br><span class="line">								<span class="built_in">return</span> _current-&gt;arch.swap_return_value;</span><br><span class="line">				&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s32_t ticks = _TICK_ALIGN + z_ms_to_ticks(delay);</span><br><span class="line"></span><br><span class="line">		z_add_thread_timeout(thread, ticks);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	ARG_UNUSED(delay);</span><br><span class="line">	k_thread_start(thread);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这部分内容主要是将线程放入_kernel结构体的wait_q队列中去，然后执行__swap进行任务调度。</p>
<p><strong>__pendsv</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 获得当前线程的栈空间callee_save地址保存在<span class="built_in">r0</span>中</span><br><span class="line">   <span class="comment">/* load _kernel into r1 and current k_thread into r2 */</span></span><br><span class="line">   <span class="keyword">ldr</span> <span class="built_in">r1</span>, <span class="symbol">=_kernel</span></span><br><span class="line">   <span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="symbol">#_kernel_offset_to_current</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addr of callee-saved regs in thread in r0 */</span></span><br><span class="line">   <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="symbol">=_thread_offset_to_callee_saved</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">r0</span>, <span class="built_in">r2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* save callee-saved + psp in thread */</span></span><br><span class="line">   <span class="keyword">mrs</span> <span class="built_in">ip</span>, PSP</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 将相关寄存器保存到<span class="built_in">r0</span>指向的地址中</span><br><span class="line"><span class="comment">/* Store current r4-r7 */</span></span><br><span class="line">   stmea <span class="built_in">r0</span>!, &#123;<span class="built_in">r4</span>-<span class="built_in">r7</span>&#125;</span><br><span class="line">   <span class="comment">/* copy r8-r12 into r3-r7 */</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r3</span>, <span class="built_in">r8</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r4</span>, <span class="built_in">r9</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r5</span>, <span class="built_in">r10</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r6</span>, <span class="built_in">r11</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r7</span>, <span class="built_in">ip</span></span><br><span class="line">   <span class="comment">/* store r8-12 */</span></span><br><span class="line">   stmea <span class="built_in">r0</span>!, &#123;<span class="built_in">r3</span>-<span class="built_in">r7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 关中断，此时防止其他线程进行调度</span><br><span class="line"><span class="keyword">cpsid</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Prepare to clear PendSV with interrupts unlocked, but</span></span><br><span class="line"><span class="comment">    * don&#x27;t clear it yet. PendSV must not be cleared until</span></span><br><span class="line"><span class="comment">    * the new thread is context-switched in since all decisions</span></span><br><span class="line"><span class="comment">    * to pend PendSV have been taken with the current kernel</span></span><br><span class="line"><span class="comment">    * state and this is what we&#x27;re handling currently.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">ldr</span> <span class="built_in">v4</span>, <span class="symbol">=_SCS_ICSR</span></span><br><span class="line">   <span class="keyword">ldr</span> <span class="built_in">v3</span>, <span class="symbol">=_SCS_ICSR_UNPENDSV</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* _kernel is still in r1 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 取出下一个要运行线程的地址放入<span class="built_in">r2</span></span><br><span class="line">   <span class="comment">/* fetch the thread to run from the ready queue cache */</span></span><br><span class="line">   <span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="symbol">#_kernel_offset_to_ready_q_cache</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="symbol">#_kernel_offset_to_current</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. 清pendv中断</span><br><span class="line"><span class="comment">/* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */</span></span><br><span class="line"><span class="keyword">str</span> <span class="built_in">v3</span>, [<span class="built_in">v4</span>, <span class="number">#0</span>]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="number">6</span>. 获得新线程的callee_saved放入<span class="built_in">r0</span></span><br><span class="line"><span class="symbol">dr</span> <span class="built_in">r4</span>, <span class="symbol">=_thread_offset_to_callee_saved</span></span><br><span class="line">   <span class="keyword">adds</span> <span class="built_in">r0</span>, <span class="built_in">r2</span>, <span class="built_in">r4</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>. 恢复新线程的寄存器</span><br><span class="line"><span class="comment">/* restore r4-r12 for new thread */</span></span><br><span class="line">   <span class="comment">/* first restore r8-r12 located after r4-r7 (4*4bytes) */</span></span><br><span class="line">   <span class="keyword">adds</span> <span class="built_in">r0</span>, <span class="number">#16</span></span><br><span class="line">   <span class="keyword">ldmia</span> <span class="built_in">r0</span>!, &#123;<span class="built_in">r3</span>-<span class="built_in">r7</span>&#125;</span><br><span class="line">   <span class="comment">/* move to correct registers */</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r8</span>, <span class="built_in">r3</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r9</span>, <span class="built_in">r4</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r10</span>, <span class="built_in">r5</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">r11</span>, <span class="built_in">r6</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ip</span>, <span class="built_in">r7</span></span><br><span class="line">   <span class="comment">/* restore r4-r7, go back 9*4 bytes to the start of the stored block */</span></span><br><span class="line">   <span class="keyword">subs</span> <span class="built_in">r0</span>, <span class="number">#36</span></span><br><span class="line">   <span class="keyword">ldmia</span> <span class="built_in">r0</span>!, &#123;<span class="built_in">r4</span>-<span class="built_in">r7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>. 开中断</span><br><span class="line"><span class="keyword">cpsie</span> i</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>.返回</span><br><span class="line"><span class="comment">/* exc return */</span></span><br><span class="line">   <span class="keyword">bx</span> <span class="built_in">lr</span></span><br></pre></td></tr></table></figure>
<p>再看下中断中的调度，系统时钟会在每个时间片发出中断，在中断向量表中可以查到system_tick的中断入口如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">SECTION_SUBSEC_FUNC(exc_vector_table,_vector_table_section,_vector_table)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * setting the _very_ early boot on the main stack allows to use memset</span></span><br><span class="line"><span class="comment">     * on the interrupt stack when CONFIG_INIT_STACKS is enabled before</span></span><br><span class="line"><span class="comment">     * switching to the interrupt stack for the rest of the early boot</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    .<span class="keyword">word</span> _main_stack + CONFIG_MAIN_STACK_SIZE</span><br><span class="line"></span><br><span class="line">    .<span class="keyword">word</span> __reset</span><br><span class="line">    .<span class="keyword">word</span> __nmi</span><br><span class="line"></span><br><span class="line">    .<span class="keyword">word</span> __hard_fault</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)</span></span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __svc</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)</span></span><br><span class="line">    .<span class="keyword">word</span> __mpu_fault</span><br><span class="line">    .<span class="keyword">word</span> __bus_fault</span><br><span class="line">    .<span class="keyword">word</span> __usage_fault</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ARM_SECURE_FIRMWARE)</span></span><br><span class="line">    .<span class="keyword">word</span> __secure_fault</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_ARM_SECURE_FIRMWARE */</span></span></span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __svc</span><br><span class="line">    .<span class="keyword">word</span> __debug_monitor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown ARM architecture</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_ARMV6_M_ARMV8_M_BASELINE */</span></span></span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line">    .<span class="keyword">word</span> __pendsv</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SYS_CLOCK_EXISTS)</span></span><br><span class="line">    .<span class="keyword">word</span> z_clock_isr</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    .<span class="keyword">word</span> __reserved</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到__svc，__pendsv，z_clock_isr这几个关键的中断或异常入口，下面看下z_clock_isr这个函数</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">void</span> z_clock_isr(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	ARG_UNUSED(arg)<span class="comment">;</span></span><br><span class="line">	u32_t dticks<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	cycle_count += last_load<span class="comment">;</span></span><br><span class="line">	dticks = (cycle_count - announced_cycles) / CYC_PER_TICK<span class="comment">;</span></span><br><span class="line">	announced_cycles += dticks * CYC_PER_TICK<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	overflow_cyc = SysTick-&gt;CTRL<span class="comment">; /* Reset overflow flag */</span></span><br><span class="line">	overflow_cyc = <span class="number">0</span>U<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	z_clock_announce(TICKLESS ? dticks : <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">	z_ExcExit()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//exc_exit.S</span></span><br><span class="line"><span class="symbol">SECTION_SUBSEC_FUNC</span>(TEXT, _HandlerModeExit, z_ExcExit)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_PREEMPT_ENABLED</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="symbol">=_kernel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, [<span class="built_in">r0</span>, <span class="symbol">#_kernel_offset_to_current</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="symbol">#_kernel_offset_to_ready_q_cache</span>]</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">beq</span> _EXIT_EXC</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* context switch required, pend the PendSV exception */</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, <span class="symbol">=_SCS_ICSR</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, <span class="symbol">=_SCS_ICSR_PENDSV</span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">_ExcExitWithGdbStub:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_EXIT_EXC:</span></span><br><span class="line"><span class="comment">#endif /* CONFIG_PREEMPT_ENABLED */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_STACK_SENTINEL</span></span><br><span class="line">    <span class="keyword">push</span> &#123;<span class="built_in">r0</span>, <span class="built_in">lr</span>&#125;</span><br><span class="line">    <span class="keyword">bl</span> z_check_stack_sentinel</span><br><span class="line"><span class="comment">#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)</span></span><br><span class="line">    <span class="keyword">pop</span> &#123;<span class="built_in">r0</span>, <span class="built_in">r1</span>&#125;</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">lr</span>, <span class="built_in">r1</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">    <span class="keyword">pop</span> &#123;<span class="built_in">r0</span>, <span class="built_in">lr</span>&#125;</span><br><span class="line"><span class="comment">#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */</span></span><br><span class="line"><span class="comment">#endif /* CONFIG_STACK_SENTINEL */</span></span><br><span class="line">    <span class="keyword">bx</span> <span class="built_in">lr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到同样会触发pendv异常进行调度。</p>
<p>大致流程为切换线程前保存原线程环境（寄存器值）找到下一个就绪态最高优先级任务，恢复环境（寄存器值）返回，pc指针已经指向新的thread继续运行。调度有两种方式，一种是这样的主动调度，还一种是通过中断方式，中断后自动跳转到相应位置执行，大的流程是一样的。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>zephyr-uartDriver</title>
    <url>/2018/08/05/zephyr-uartDriver/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>zephyr的代码结构和linux系统很像，配置方式也用kconfig，硬件资源的定义也是采用dts，驱动也是采用向上注册的方式，提供统一的调用接口，因此学习linux前熟悉zephyr是非常不错的选择，同时zephyr也是一款非常不错的rtos，作为嵌入式开发的操作系统也非常合适。zephyr的串口设计到很多的东西，可以从这里入手去了解zephyr的驱动框架，本文以nucleo_f446re板子为例分析zephyr串口驱动框架。</p>
<h3 id="设备树dts"><a href="#设备树dts" class="headerlink" title="设备树dts"></a>设备树dts</h3><p>只分析uart1因此这里只贴出usart1相关配置，其配置在一个.dts文件以及多个.dtsi文件里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dts：</span><br><span class="line">&amp;usart1 &#123;</span><br><span class="line">	current-speed = &lt;115200&gt;;</span><br><span class="line">	pinctrl-0 = &lt;&amp;usart1_pins_b&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">dtsi：	</span><br><span class="line">	usart1: serial@40011000 &#123;</span><br><span class="line">			compatible = <span class="string">&quot;st,stm32-usart&quot;</span>, <span class="string">&quot;st,stm32-uart&quot;</span>;</span><br><span class="line">			reg = &lt;0x40011000 0x400&gt;;</span><br><span class="line">			clocks = &lt;&amp;rcc STM32_CLOCK_BUS_APB2 0x00000010&gt;;</span><br><span class="line">			interrupts = &lt;37 0&gt;;</span><br><span class="line">			status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">			label = <span class="string">&quot;UART_1&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	usart1_pins_a: usart1@0 &#123;</span><br><span class="line">		rx_tx &#123;</span><br><span class="line">			rx = &lt;STM32_PIN_PA10 STM32_PIN_USART_RX&gt;;</span><br><span class="line">			tx = &lt;STM32_PIN_PA9 STM32_PIN_USART_TX&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>zephyr对设备树的处理与linux不同，zephyr是通过将dts文件与h头文件一起通过dtc编译为头文件的方式进行配置硬件设备的，上面的dts通过dtc的编译将产生以下宏定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define DT_ST_STM32_UART_1				1</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1				1</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_BASE_ADDRESS		0x40011000</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_CLOCK_BITS_0		16</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_CLOCK_BUS_0		3</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_CLOCK_CONTROLLER	&quot;STM32_CLK_RCC&quot;</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_CURRENT_SPEED	115200</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_HW_FLOW_CONTROL	0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_IRQ_0		37</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_IRQ_0_PRIORITY	0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_LABEL		&quot;UART_1&quot;</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_SIZE			1024</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_BASE_ADDRESS		DT_ST_STM32_USART_40011000_BASE_ADDRESS</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_CLOCK_BITS		DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_CLOCK_BITS_0		DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_CLOCK_BUS		DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_CLOCK_BUS_0		DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_CLOCK_CONTROLLER	DT_ST_STM32_USART_40011000_CLOCK_CONTROLLER</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_CURRENT_SPEED		DT_ST_STM32_USART_40011000_CURRENT_SPEED</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_HW_FLOW_CONTROL		DT_ST_STM32_USART_40011000_HW_FLOW_CONTROL</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_IRQ_0			DT_ST_STM32_USART_40011000_IRQ_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_IRQ_0_PRIORITY		DT_ST_STM32_USART_40011000_IRQ_0_PRIORITY</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_LABEL			DT_ST_STM32_USART_40011000_LABEL</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_UART_SIZE			DT_ST_STM32_USART_40011000_SIZE</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_BASE_ADDRESS		DT_ST_STM32_USART_40011000_BASE_ADDRESS</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_CLOCK_BITS		DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_CLOCK_BITS_0		DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_CLOCK_BUS		DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_CLOCK_BUS_0		DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_CLOCK_CONTROLLER	DT_ST_STM32_USART_40011000_CLOCK_CONTROLLER</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_CURRENT_SPEED		DT_ST_STM32_USART_40011000_CURRENT_SPEED</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_HW_FLOW_CONTROL	DT_ST_STM32_USART_40011000_HW_FLOW_CONTROL</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_IRQ_0			DT_ST_STM32_USART_40011000_IRQ_0</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_IRQ_0_PRIORITY		DT_ST_STM32_USART_40011000_IRQ_0_PRIORITY</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_LABEL			DT_ST_STM32_USART_40011000_LABEL</span></span><br><span class="line"><span class="comment">#define DT_INST_1_ST_STM32_USART_SIZE			DT_ST_STM32_USART_40011000_SIZE</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_BASE_ADDRESS __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_BASE_ADDRESS</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_CLOCK_BITS __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_CLOCK_BITS_0 __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_CLOCK_BUS __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_CLOCK_BUS_0 __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_CLOCK_CONTROLLER __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_CONTROLLER</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_CURRENT_SPEED __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CURRENT_SPEED</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_HW_FLOW_CONTROL __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_HW_FLOW_CONTROL</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_IRQ_0 __DEPRECATED_MACRO 	DT_ST_STM32_USART_40011000_IRQ_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_IRQ_0_PRIORITY __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_IRQ_0_PRIORITY</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_LABEL __DEPRECATED_MACRO 	DT_ST_STM32_USART_40011000_LABEL</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_UART_1_SIZE __DEPRECATED_MACRO 	DT_ST_STM32_USART_40011000_SIZE</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_BASE_ADDRESS __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_BASE_ADDRESS</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_CLOCK_BITS __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_CLOCK_BITS_0 __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_CLOCK_BUS __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_CLOCK_BUS_0 __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_CLOCK_CONTROLLER __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CLOCK_CONTROLLER</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_CURRENT_SPEED __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_CURRENT_SPEED</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_HW_FLOW_CONTROL __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_HW_FLOW_CONTROL</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_IRQ_0 __DEPRECATED_MACRO 	DT_ST_STM32_USART_40011000_IRQ_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_IRQ_0_PRIORITY __DEPRECATED_MACRO DT_ST_STM32_USART_40011000_IRQ_0_PRIORITY</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_LABEL __DEPRECATED_MACRO 	DT_ST_STM32_USART_40011000_LABEL</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_1_SIZE __DEPRECATED_MACRO 	DT_ST_STM32_USART_40011000_SIZE</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_CLOCK_BITS		DT_ST_STM32_USART_40011000_CLOCK_BITS_0</span></span><br><span class="line"><span class="comment">#define DT_ST_STM32_USART_40011000_CLOCK_BUS		DT_ST_STM32_USART_40011000_CLOCK_BUS_0</span></span><br></pre></td></tr></table></figure>
<h3 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h3><p>初始化函数在/driver/usart目录下相应平台的c文件，该文件的对串口的初始化是通过以下宏定义完成的，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ifdef CONFIG_UART_1</span></span><br><span class="line">STM32_UART_INIT(USART_1)</span><br><span class="line"><span class="comment">#endif	/* CONFIG_UART_1 */</span></span><br></pre></td></tr></table></figure>
<p>采用宏定义而不用函数的原因是该部分内容只在运行开始时运行一次避免函数调用的额外开销，该宏定义为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define STM32_UART_INIT(name)						\</span></span><br><span class="line">STM32_UART_IRQ_HANDLER_DECL(name);					\</span><br><span class="line">									\</span><br><span class="line">static const struct uart_stm32_config uart_stm32_cfg_<span class="comment">##name = &#123;		\</span></span><br><span class="line">	.uconf = &#123;							\</span><br><span class="line">		.base = (u8_t *)DT_UART_STM32_<span class="comment">##name##_BASE_ADDRESS,\</span></span><br><span class="line">		STM32_UART_IRQ_HANDLER_FUNC(name)			\</span><br><span class="line">	&#125;,								\</span><br><span class="line">	.pclken = &#123; .bus = DT_UART_STM32_<span class="comment">##name##_CLOCK_BUS,	\</span></span><br><span class="line">		    .enr = DT_UART_STM32_<span class="comment">##name##_CLOCK_BITS	\</span></span><br><span class="line">	&#125;,								\</span><br><span class="line">	.hw_flow_control = DT_UART_STM32_<span class="comment">##name##_HW_FLOW_CONTROL	\</span></span><br><span class="line">&#125;;									\</span><br><span class="line">									\</span><br><span class="line">static struct uart_stm32_data uart_stm32_data_<span class="comment">##name = &#123;		\</span></span><br><span class="line">	.baud_rate = DT_UART_STM32_<span class="comment">##name##_BAUD_RATE			\</span></span><br><span class="line">&#125;;									\</span><br><span class="line">									\</span><br><span class="line">DEVICE_AND_API_INIT(uart_stm32_<span class="comment">##name, DT_UART_STM32_##name##_NAME,	\</span></span><br><span class="line">		    &amp;uart_stm32_init,					\</span><br><span class="line">		    &amp;uart_stm32_data_<span class="comment">##name, &amp;uart_stm32_cfg_##name,	\</span></span><br><span class="line">		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,	\</span><br><span class="line">		    &amp;uart_stm32_driver_api);				\</span><br><span class="line">									\</span><br><span class="line">STM32_UART_IRQ_HANDLER(name)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>中断函数的声明和定义</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#define STM32_UART_IRQ_HANDLER_DECL(name)				\</span><br><span class="line">	static void uart_stm32_irq_config_func_##name(struct device *dev)</span><br><span class="line">#define STM32_UART_IRQ_HANDLER_FUNC(name)				\</span><br><span class="line">	.irq_config_func = uart_stm32_irq_config_func_##name,</span><br><span class="line">#define STM32_UART_IRQ_HANDLER(name)					\</span><br><span class="line">static void uart_stm32_irq_config_func_##name(struct device *dev)	\</span><br><span class="line">&#123;									\</span><br><span class="line">	IRQ_CONNECT(DT_##name##_IRQ,					\</span><br><span class="line">		DT_UART_STM32_##name##_IRQ_PRI,			\</span><br><span class="line">		uart_stm32_isr, DEVICE_GET(uart_stm32_##name),	\</span><br><span class="line">		<span class="number">0</span>);							\</span><br><span class="line">	irq_enable(DT_##name##_IRQ);					\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STM32_UART_IRQ_HANDLER_DECL用于声明中断函数。<br>STM32_UART_IRQ_HANDLER_FUNC将对结构体里的irq_config_func成员赋值。<br>STM32_UART_IRQ_HANDLER定义中断函数并使能相关中断(里面具体宏不再展开，最终调用hal库相关函数)。</p>
</li>
<li><p>首先是定义并初始化两个结构体struct uart_stm32_config和struct uart_stm32_data。这两个结构体里含有对串口的配置，那么如何只传递一个串口名通过一个宏定义就完成对多个串口的定义和初始化的呢，这里就和dts文件生成的头文件有关了例如：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">static struct uart_stm32_data uart_stm32_data_##name = &#123;		\</span><br><span class="line">	.baud_rate = DT_UART_STM32_##name##_BAUD_RATE			\</span><br><span class="line">&#125;;	</span><br></pre></td></tr></table></figure>
<p>将name替换为USART_1展开得到<br>.baud_rate = DT_UART_STM32_USART_1_BAUD_RATE<br>我们可以在dts_fixup.h文件中找到DT_UART_STM32_USART_1_BAUD_RATE的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_BASE_ADDRESS	DT_ST_STM32_USART_40011000_BASE_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_BAUD_RATE	DT_ST_STM32_USART_40011000_CURRENT_SPEED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_IRQ_PRI	DT_ST_STM32_USART_40011000_IRQ_0_PRIORITY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_NAME		DT_ST_STM32_USART_40011000_LABEL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_USART_1_IRQ				DT_ST_STM32_USART_40011000_IRQ_0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_CLOCK_BITS	DT_ST_STM32_USART_40011000_CLOCK_BITS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_CLOCK_BUS	DT_ST_STM32_USART_40011000_CLOCK_BUS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_UART_STM32_USART_1_HW_FLOW_CONTROL	DT_ST_STM32_USART_40011000_HW_FLOW_CONTROL</span></span><br></pre></td></tr></table></figure>
<p>通过#define DT_UART_STM32_USART_1_BAUD_RATE    DT_ST_STM32_USART_40011000_CURRENT_SPEED查找DT_ST_STM32_USART_40011000_CURRENT_SPEED 查找的定义就在dts文件生成的头文件里#define DT_ST_STM32_USART_40011000_CURRENT_SPEED    115200就是在dts文件里定义的current-speed = &lt;115200&gt;;<br>这是串口波特率的定义，其他的配置采用相同的配置方法包括寄存器地址，波特率中断号。</p>
</li>
<li><p>DEVICE_AND_API_INIT注册</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">DEVICE_AND_API_INIT(uart_stm32_##name, DT_UART_STM32_##name##_NAME,	\</span><br><span class="line">		    &amp;uart_stm32_init,					\</span><br><span class="line">		    &amp;uart_stm32_data_##name, &amp;uart_stm32_cfg_##name,	\</span><br><span class="line">		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,	\</span><br><span class="line">		    &amp;uart_stm32_driver_api);</span><br></pre></td></tr></table></figure>
<p>展开得到</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">DEVICE_AND_API_INIT(<span class="name">uart_stm32_USART_1</span>, DT_UART_STM32_USART_1_NAME,	\</span><br><span class="line">		    <span class="symbol">&amp;uart_stm32_init</span>,					\</span><br><span class="line">		    <span class="symbol">&amp;uart_stm32_data_USART_1</span>, <span class="symbol">&amp;uart_stm32_cfg_USART_1</span>,	\</span><br><span class="line">		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,	\</span><br><span class="line">		    <span class="symbol">&amp;uart_stm32_driver_api</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>对于没有设备电源管理的定义为：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define DEVICE_AND_API_INIT(dev_name, drv_name, init_fn, data, cfg_info, \</span></span><br><span class="line">			    level, prio, api)				 <span class="string">\</span></span><br><span class="line">	DEVICE_DEFINE(dev_name, drv_name, init_fn,			 <span class="string">\</span></span><br><span class="line">		      device_pm_control_nop, data, cfg_info, level,	 <span class="string">\</span></span><br><span class="line">		      prio, api)</span><br></pre></td></tr></table></figure>
<p>进一步展开为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEVICE_DEFINE(uart_stm32_USART_1, DT_UART_STM32_USART_1_NAME, &amp;uart_stm32_init, device_pm_control_nop,\</span><br><span class="line">&amp;uart_stm32_data_USART_1, &amp;uart_stm32_cfg_USART_1, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,\</span><br><span class="line">&amp;uart_stm32_driver_api)</span><br></pre></td></tr></table></figure>
<p>DEVICE_DEFINE的定义</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> struct device_pm _CONCAT(__pm_, uart_stm32_USART_1) __used           <span class="string">\</span></span><br><span class="line">						= &#123;               <span class="string">\</span></span><br><span class="line">	.usage = ATOMIC_INIT(<span class="number">0</span>),                                  <span class="string">\</span></span><br><span class="line">	.lock = Z_SEM_INITIALIZER(                               <span class="string">\</span></span><br><span class="line">			_CONCAT(__pm_, uart_stm32_USART_1).lock, <span class="number">1</span>, <span class="number">1</span>),     <span class="string">\</span></span><br><span class="line">	.signal = K_POLL_SIGNAL_INITIALIZER(                      <span class="string">\</span></span><br><span class="line">			_CONCAT(__pm_, uart_stm32_USART_1).signal),         <span class="string">\</span></span><br><span class="line">	.event = K_POLL_EVENT_INITIALIZER(K_POLL_TYPE_SIGNAL,     <span class="string">\</span></span><br><span class="line">			K_POLL_MODE_NOTIFY_ONLY,                  <span class="string">\</span></span><br><span class="line">			&amp;_CONCAT(__pm_, uart_stm32_USART_1).signal),        <span class="string">\</span></span><br><span class="line">&#125;;								  <span class="string">\</span></span><br><span class="line"><span class="keyword">static</span> struct device_config _CONCAT(__config_, uart_stm32_USART_1) __used	  <span class="string">\</span></span><br><span class="line">__attribute__((__section__(<span class="string">&quot;.devconfig.init&quot;</span>))) = &#123;		  <span class="string">\</span></span><br><span class="line">	.name = DT_UART_STM32_USART_1_NAME, .init = (&amp;uart_stm32_init),			  <span class="string">\</span></span><br><span class="line">	.device_pm_control = (device_pm_control_nop),			  <span class="string">\</span></span><br><span class="line">	.pm  = &amp;_CONCAT(__pm_, uart_stm32_USART_1),                         <span class="string">\</span></span><br><span class="line">	.config_info = (&amp;uart_stm32_cfg_USART_1)				  <span class="string">\</span></span><br><span class="line">&#125;;								  <span class="string">\</span></span><br><span class="line"><span class="keyword">static</span> Z_DECL_ALIGN(struct device) _CONCAT(__device_, uart_stm32_USART_1) __used <span class="string">\</span></span><br><span class="line">__attribute__((__section__(<span class="string">&quot;.init_&quot;</span> PRE_KERNEL_1 STRINGIFY(CONFIG_KERNEL_INIT_PRIORITY_DEVICE)))) = &#123; <span class="string">\</span></span><br><span class="line">	.config = &amp;_CONCAT(__config_, uart_stm32_USART_1),		  <span class="string">\</span></span><br><span class="line">	.driver_api = &amp;uart_stm32_driver_api,					  <span class="string">\</span></span><br><span class="line">	.driver_data = &amp;uart_stm32_data_USART_1,					  <span class="string">\</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了三个结构体，并将其放入到不同的段中（.devconfig.init和.init_）<br>device_pm用于初始化single、lock、event、atomic等用于设备访问控制<br>device_config设置设备名称（UART_1），初始化函数（uart_stm32_init）、pm控制和配置信（uart_stm32_cfg_USART_1）<br>Z_DECL_ALIGN(struct device)这个展开得到</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">Z_DECL_ALIGN(<span class="params">type</span>)</span> <span class="constructor">__aligned(<span class="params">__alignof</span>(<span class="params">type</span>)</span>) <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>也就是以type长度对齐的type类型这里就是struct device结构体，这里严格显示出对齐长度是因为这个结构图会放入一段连续内存中，这段内存中会存放所有驱动结构体数据，device_get_binding函数会遍历这段地址进行name匹配<br>device设置驱动的优先级，对不同驱动给予不同优先级以让驱动在不同阶段进行初始化配置，操作api（uart_stm32_driver_api）以及驱动信息（uart_stm32_data_USART_1）</p>
</li>
</ol>
<p>到这里就是串口驱动的框架了，实际编写驱动就是完成初始化函数、uart_driver_api结构体里相关函数的实现，以及设置结构图里的参数，本例中完成如下函数：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">static const struct uart_driver_api uart_stm32_driver_api = &#123;</span><br><span class="line">	<span class="string">.poll_in</span> = uart_stm32_poll_in,</span><br><span class="line">	<span class="string">.poll_out</span> = uart_stm32_poll_out,</span><br><span class="line">	<span class="string">.err_check</span> = uart_stm32_err_check,</span><br><span class="line">	<span class="string">.configure</span> = uart_stm32_configure,</span><br><span class="line">	<span class="string">.config_get</span> = uart_stm32_config_get,</span><br><span class="line"><span class="comment">#ifdef CONFIG_UART_INTERRUPT_DRIVEN</span></span><br><span class="line">	<span class="string">.fifo_fill</span> = uart_stm32_fifo_fill,</span><br><span class="line">	<span class="string">.fifo_read</span> = uart_stm32_fifo_read,</span><br><span class="line">	<span class="string">.irq_tx_enable</span> = uart_stm32_irq_tx_enable,</span><br><span class="line">	<span class="string">.irq_tx_disable</span> = uart_stm32_irq_tx_disable,</span><br><span class="line">	<span class="string">.irq_tx_ready</span> = uart_stm32_irq_tx_ready,</span><br><span class="line">	<span class="string">.irq_tx_complete</span> = uart_stm32_irq_tx_complete,</span><br><span class="line">	<span class="string">.irq_rx_enable</span> = uart_stm32_irq_rx_enable,</span><br><span class="line">	<span class="string">.irq_rx_disable</span> = uart_stm32_irq_rx_disable,</span><br><span class="line">	<span class="string">.irq_rx_ready</span> = uart_stm32_irq_rx_ready,</span><br><span class="line">	<span class="string">.irq_err_enable</span> = uart_stm32_irq_err_enable,</span><br><span class="line">	<span class="string">.irq_err_disable</span> = uart_stm32_irq_err_disable,</span><br><span class="line">	<span class="string">.irq_is_pending</span> = uart_stm32_irq_is_pending,</span><br><span class="line">	<span class="string">.irq_update</span> = uart_stm32_irq_update,</span><br><span class="line">	<span class="string">.irq_callback_set</span> = uart_stm32_irq_callback_<span class="keyword">set</span>,</span><br><span class="line"><span class="comment">#endif	/* CONFIG_UART_INTERRUPT_DRIVEN */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们发现这里并没有gpio相关配置，管脚的复用是通过pinmux实现的，所以在编写驱动的时候还要添加pinmux的相关驱动来完成管脚复用配置。<br>pinmux.c文件里通过SYS_INIT()注册到系统初始化代码段里在系统初始化阶段执行。<br>而SYS_INIT()实际上就是DEVICE_INIT其定义如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">#define DEVICE_INIT(dev_name, drv_name, init_fn, <span class="built_in">data</span>, cfg_info, level, prio) \</span><br><span class="line">	DEVICE_AND_API_INIT(dev_name, drv_name, init_fn, <span class="built_in">data</span>, cfg_info,      \</span><br><span class="line">			    level, prio, <span class="built_in">NULL</span>)</span><br></pre></td></tr></table></figure>
<p>其过程同其他驱动流程一样，这里不再展开。</p>
<h3 id="内核调用"><a href="#内核调用" class="headerlink" title="内核调用"></a>内核调用</h3><p>device_get_binding函数有点复杂在script/gen_syscalls.py脚本里生成很多头文件，其中之一是device.h文件，内容如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* auto-generated by gen_syscalls.py, don&#x27;t edit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASMLANGUAGE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syscall_list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syscall_macros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, <span class="keyword">struct</span> device *, <span class="keyword">const</span> <span class="keyword">char</span> *, name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>K_SYSCALL_DECLARE1在syscall_macros.h文件里该文件由script/gen_syscall_header.py脚本生成，部分内容如下</p>
<figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">#define K_SYSCALL_DECLARE1(id, name, ret, t0, p0) \</span><br><span class="line">	extern ret z_impl_<span class="function"><span class="keyword">##</span><span class="title">name</span><span class="params">(<span class="variable">t0</span> <span class="variable">p0</span>)</span></span>; \</span><br><span class="line">	static inline ret name(t0 p0) \</span><br><span class="line">	&#123; \</span><br><span class="line">		return z_impl_<span class="function"><span class="keyword">##</span><span class="title">name</span><span class="params">(<span class="variable">p0</span>)</span></span>; \</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>将前面的头文件展开得到</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">extern ret z<span class="constructor">_impl_device_get_binding(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">name</span>)</span>; \</span><br><span class="line">	static inline ret device<span class="constructor">_get_binding(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span> <span class="params">name</span>)</span> \</span><br><span class="line">	&#123; \</span><br><span class="line">		return z<span class="constructor">_impl_device_get_binding(<span class="params">name</span>)</span>; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>extern ret z_impl_device_get_binding(const char * name);函数声明<br>device_get_binding函数实际上调用z_impl_device_get_binding这个函数，而这个函数的定义在kerner/device.c文件里，函数如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">struct device *z_impl_device_get_binding(const <span class="type">char</span> *<span class="type">name</span>)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *<span class="keyword">info</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Split the search into two loops: in the common scenario, where</span></span><br><span class="line"><span class="comment">	 * device names are stored in ROM (and are referenced by the user</span></span><br><span class="line"><span class="comment">	 * with CONFIG_* macros), only cheap pointer comparisons will be</span></span><br><span class="line"><span class="comment">	 * performed.  Reserve string comparisons for a fallback.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">info</span> = __device_init_start; <span class="keyword">info</span> != __device_init_end; <span class="keyword">info</span>++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">info</span>-&gt;driver_api != <span class="keyword">NULL</span>) &amp;&amp;</span><br><span class="line">		    (<span class="keyword">info</span>-&gt;config-&gt;<span class="type">name</span> == <span class="type">name</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">info</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">info</span> = __device_init_start; <span class="keyword">info</span> != __device_init_end; <span class="keyword">info</span>++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">info</span>-&gt;driver_api == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (strcmp(<span class="type">name</span>, <span class="keyword">info</span>-&gt;config-&gt;<span class="type">name</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">info</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将从__device_init_start到__device_init_end遍历device结构体将name与这个地址范围内的众多结构图里的config-&gt;name成员对比，如果相同则返回该结构图指针，从而获得操作该驱动的api和数据，而__device_init_start和__device_init_end这个地址范围就是在前面DEVICE_AND_API_INIT这个宏定义的结构图存放的地址。<br>这就是系统调用的流程，其他系统调用接口都是相同的生成流程。</p>
]]></content>
      <categories>
        <category>zephyr</category>
      </categories>
      <tags>
        <tag>device</tag>
        <tag>driver</tag>
        <tag>zephyr</tag>
      </tags>
  </entry>
  <entry>
    <title>宋词</title>
    <url>/2019/08/25/%E5%AE%8B%E8%AF%8D-%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h3 id="长相思·汴水流"><a href="#长相思·汴水流" class="headerlink" title="长相思·汴水流"></a>长相思·汴水流</h3><p>白居易<br>汴水流，泗水流，流到瓜州古渡头。吴山点点愁。</p>
<p>思悠悠，恨悠悠，恨到归时方始休。月明人倚楼。</p>
<h3 id="浪淘沙·借问江潮与海水"><a href="#浪淘沙·借问江潮与海水" class="headerlink" title="浪淘沙·借问江潮与海水"></a>浪淘沙·借问江潮与海水</h3><p>白居易<br>借问江潮与海水，何似君情与妾心？</p>
<p>相恨不如潮有信，相思始觉海非深。</p>
<h3 id="花非花"><a href="#花非花" class="headerlink" title="花非花"></a>花非花</h3><p>白居易<br>花非花，雾非雾。</p>
<p>夜半来，天明去。</p>
<p>来如春梦几多时？</p>
<p>去似朝云无觅处。</p>
<h3 id="忆江南·江南好"><a href="#忆江南·江南好" class="headerlink" title="忆江南·江南好"></a>忆江南·江南好</h3><p>白居易<br>江南好，风景旧曾谙。日出江花红胜火，春来江水绿如蓝。能不忆江南？</p>
<h3 id="十二月二日夜梦游沈氏园亭"><a href="#十二月二日夜梦游沈氏园亭" class="headerlink" title="十二月二日夜梦游沈氏园亭"></a>十二月二日夜梦游沈氏园亭</h3><p>陆游<br>城南小陌又逢春，只见梅花不见人。</p>
<p>玉骨久成泉下土，墨痕犹锁壁间尘。</p>
<h3 id="卜算子·咏梅"><a href="#卜算子·咏梅" class="headerlink" title="卜算子·咏梅"></a>卜算子·咏梅</h3><p>陆游<br>驿外断桥边，寂寞开无主。已是黄昏独自愁，更著风和雨。</p>
<p>无意苦争春，一任群芳妒。零落成泥碾作尘，只有香如故。</p>
<h3 id="诉衷情·当年万里觅封侯"><a href="#诉衷情·当年万里觅封侯" class="headerlink" title="诉衷情·当年万里觅封侯"></a>诉衷情·当年万里觅封侯</h3><p>陆游<br>当年万里觅封侯，匹马戍梁州。关河梦断何处？尘暗旧貂裘。</p>
<p>胡未灭，鬓先秋，泪空流。此生谁料，心在天山，身老沧洲。</p>
<h3 id="鹊桥仙·华灯纵博"><a href="#鹊桥仙·华灯纵博" class="headerlink" title="鹊桥仙·华灯纵博"></a>鹊桥仙·华灯纵博</h3><p>陆游<br>华灯纵博，雕鞍驰射，谁记当年豪举。酒徒一半取封侯，独去作、江边渔父。</p>
<p>轻舟八尺，低篷三扇，占断苹洲烟雨。镜湖元自属闲人，又何必、君恩赐与。</p>
<h3 id="夜游宫·记梦寄师伯浑"><a href="#夜游宫·记梦寄师伯浑" class="headerlink" title="夜游宫·记梦寄师伯浑"></a>夜游宫·记梦寄师伯浑</h3><p>陆游<br>雪晓清笳乱起。梦游处、不知何地。铁骑无声望似水。想关河，雁门西，青海际。</p>
<p>睡觉寒灯里。漏声断、月斜窗纸。自许封侯在万里。有谁知，鬓虽残，心未死。</p>
<h3 id="钗头凤·红酥手"><a href="#钗头凤·红酥手" class="headerlink" title="钗头凤·红酥手"></a>钗头凤·红酥手</h3><p>陆游<br>红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。</p>
<p>春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！</p>
<h3 id="秋波媚·七月十六日晚登高兴亭望长安南山"><a href="#秋波媚·七月十六日晚登高兴亭望长安南山" class="headerlink" title="秋波媚·七月十六日晚登高兴亭望长安南山"></a>秋波媚·七月十六日晚登高兴亭望长安南山</h3><p>陆游<br>秋到边城角声哀，烽火照高台。悲歌击筑，凭高酹酒，此兴悠哉。</p>
<p>多情谁似南山月，特地暮云开。灞桥烟柳，曲江池馆，应待人来。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>宋词</tag>
      </tags>
  </entry>
  <entry>
    <title>宋词-苏轼</title>
    <url>/2020/02/03/%E5%AE%8B%E8%AF%8D-%E8%8B%8F%E8%BD%BC/</url>
    <content><![CDATA[<h3 id="临江仙"><a href="#临江仙" class="headerlink" title="临江仙"></a>临江仙</h3><p>苏轼<br>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。</p>
<p>长恨此身非我有，何时忘却营营？夜阑风静縠纹平。小舟从此逝，江海寄余生。</p>
<h3 id="西江月·世事一场大梦"><a href="#西江月·世事一场大梦" class="headerlink" title="西江月·世事一场大梦"></a>西江月·世事一场大梦</h3><p>苏轼<br>世事一场大梦，人生几度秋凉？夜来风叶已鸣廊。看取眉头鬓上。</p>
<p>酒贱常愁客少，月明多被云妨。中秋谁与共孤光。把盏凄然北望。</p>
<h3 id="江城子·乙卯正月二十日夜记梦"><a href="#江城子·乙卯正月二十日夜记梦" class="headerlink" title="江城子·乙卯正月二十日夜记梦"></a>江城子·乙卯正月二十日夜记梦</h3><p>苏轼<br>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。</p>
<p>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</p>
<h3 id="念奴娇·赤壁怀古"><a href="#念奴娇·赤壁怀古" class="headerlink" title="念奴娇·赤壁怀古"></a>念奴娇·赤壁怀古</h3><p>苏轼<br>大江东去，浪淘尽，千古风流人物。</p>
<p>故垒西边，人道是，三国周郎赤壁。</p>
<p>乱石穿空，惊涛拍岸，卷起千堆雪。</p>
<p>江山如画，一时多少豪杰。</p>
<p>遥想公瑾当年，小乔初嫁了，雄姿英发。</p>
<p>羽扇纶巾，谈笑间，樯橹灰飞烟灭。</p>
<p>故国神游，多情应笑我，早生华发。</p>
<p>人生如梦，一尊还酹江月。</p>
<h3 id="水龙吟·次韵章质夫杨花词"><a href="#水龙吟·次韵章质夫杨花词" class="headerlink" title="水龙吟·次韵章质夫杨花词"></a>水龙吟·次韵章质夫杨花词</h3><p>苏轼<br>似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。</p>
<p>不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花，点点是离人泪。</p>
<h3 id="水调歌头·明月几时有"><a href="#水调歌头·明月几时有" class="headerlink" title="水调歌头·明月几时有"></a>水调歌头·明月几时有</h3><p>苏轼<br>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</p>
<p>明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？</p>
<p>转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。</p>
<h3 id="蝶恋花·春景"><a href="#蝶恋花·春景" class="headerlink" title="蝶恋花·春景"></a>蝶恋花·春景</h3><p>苏轼<br>花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草！</p>
<p>墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。</p>
<h3 id="定风波·莫听穿林打叶声"><a href="#定风波·莫听穿林打叶声" class="headerlink" title="定风波·莫听穿林打叶声"></a>定风波·莫听穿林打叶声</h3><p>苏轼<br>三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。</p>
<p>莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p>
<p>料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。</p>
<h3 id="江城子·密州出猎"><a href="#江城子·密州出猎" class="headerlink" title="江城子·密州出猎"></a>江城子·密州出猎</h3><p>苏轼<br>老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。为报倾城随太守，亲射虎，看孙郎。</p>
<p>酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？会挽雕弓如满月，西北望，射天狼。</p>
<h3 id="永遇乐·彭城夜宿燕子楼"><a href="#永遇乐·彭城夜宿燕子楼" class="headerlink" title="永遇乐·彭城夜宿燕子楼"></a>永遇乐·彭城夜宿燕子楼</h3><p>苏轼<br>彭城夜宿燕子楼，梦盼盼，因作此词。</p>
<p>明月如霜，好风如水，清景无限。曲港跳鱼，圆荷泻露，寂寞无人见。紞如三鼓，铿然一叶，黯黯梦云惊断。夜茫茫，重寻无处，觉来小园行遍。</p>
<p>天涯倦客，山中归路，望断故园心眼。燕子楼空，佳人何在，空锁楼中燕。古今如梦，何曾梦觉，但有旧欢新怨。异时对，黄楼夜景，为余浩叹。</p>
<h3 id="浣溪沙·游蕲水清泉寺"><a href="#浣溪沙·游蕲水清泉寺" class="headerlink" title="浣溪沙·游蕲水清泉寺"></a>浣溪沙·游蕲水清泉寺</h3><p>苏轼<br>游蕲水清泉寺，寺临兰溪，溪水西流。</p>
<p>山下兰芽短浸溪，松间沙路净无泥，潇潇暮雨子规啼。</p>
<p>谁道人生无再少？门前流水尚能西！休将白发唱黄鸡。</p>
<h3 id="卜算子·黄州定慧院寓居作"><a href="#卜算子·黄州定慧院寓居作" class="headerlink" title="卜算子·黄州定慧院寓居作"></a>卜算子·黄州定慧院寓居作</h3><p>苏轼<br>缺月挂疏桐，漏断人初静。时见幽人独往来，缥缈孤鸿影。</p>
<p>惊起却回头，有恨无人省。拣尽寒枝不肯栖，寂寞沙洲冷。</p>
<h3 id="定风波·南海归赠王定国侍人寓娘"><a href="#定风波·南海归赠王定国侍人寓娘" class="headerlink" title="定风波·南海归赠王定国侍人寓娘"></a>定风波·南海归赠王定国侍人寓娘</h3><p>苏轼<br>常羡人间琢玉郎，天应乞与点酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。</p>
<p>万里归来颜愈少，微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>苏轼</tag>
      </tags>
  </entry>
  <entry>
    <title>宋词-辛弃疾</title>
    <url>/2020/02/03/%E5%AE%8B%E8%AF%8D-%E8%BE%9B%E5%BC%83%E7%96%BE/</url>
    <content><![CDATA[<h3 id="清平乐·村居"><a href="#清平乐·村居" class="headerlink" title="清平乐·村居"></a>清平乐·村居</h3><p>辛弃疾<br>茅檐低小，溪上青青草。</p>
<p>醉里吴音相媚好，白发谁家翁媪？</p>
<p>大儿锄豆溪东，中儿正织鸡笼。</p>
<p>最喜小儿亡赖，溪头卧剥莲蓬。</p>
<h3 id="贺新郎·甚矣吾衰矣"><a href="#贺新郎·甚矣吾衰矣" class="headerlink" title="贺新郎·甚矣吾衰矣"></a>贺新郎·甚矣吾衰矣</h3><p>辛弃疾<br>邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。</p>
<p>甚矣吾衰矣。怅平生、交游零落，只今馀几！白发空垂三千丈，一笑人间万事。问何物、能令公喜？我见青山多妩媚，料青山见我应如是。情与貌，略相似。</p>
<p>一尊搔首东窗里。想渊明《停云》诗就，此时风味。江左沉酣求名者，岂识浊醪妙理。回首叫、云飞风起。不恨古人吾不见，恨古人不见吾狂耳。知我者，二三子。</p>
<h3 id="永遇乐·京口北固亭怀古"><a href="#永遇乐·京口北固亭怀古" class="headerlink" title="永遇乐·京口北固亭怀古"></a>永遇乐·京口北固亭怀古</h3><p>辛弃疾<br>千古江山，英雄无觅，孙仲谋处。舞榭歌台，风流总被雨打风吹去。斜阳草树，寻常巷陌，人道寄奴曾住。想当年，金戈铁马，气吞万里如虎。</p>
<p>元嘉草草，封狼居胥，赢得仓皇北顾。四十三年，望中犹记，烽火扬州路。可堪回首，佛狸祠下，一片神鸦社鼓。凭谁问，廉颇老矣，尚能饭否？</p>
<h3 id="摸鱼儿·更能消几番风雨"><a href="#摸鱼儿·更能消几番风雨" class="headerlink" title="摸鱼儿·更能消几番风雨"></a>摸鱼儿·更能消几番风雨</h3><p>辛弃疾<br>淳熙己亥，自湖北漕移湖南，同官王正之置酒小山亭，为赋。</p>
<p>更能消、几番风雨，匆匆春又归去。惜春长怕花开早，何况落红无数。春且住，见说道、天涯芳草无归路。怨春不语。算只有殷勤，画檐蛛网，尽日惹飞絮。 (无归路 一作：迷归路）</p>
<p>长门事，准拟佳期又误。蛾眉曾有人妒。千金纵买相如赋，脉脉此情谁诉？君莫舞，君不见、玉环飞燕皆尘土！闲愁最苦！休去倚危栏，斜阳正在，烟柳断肠处</p>
<h3 id="丑奴儿·书博山道中壁"><a href="#丑奴儿·书博山道中壁" class="headerlink" title="丑奴儿·书博山道中壁"></a>丑奴儿·书博山道中壁</h3><p>辛弃疾<br>少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。</p>
<p>而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。</p>
<h3 id="南乡子·登京口北固亭有怀"><a href="#南乡子·登京口北固亭有怀" class="headerlink" title="南乡子·登京口北固亭有怀"></a>南乡子·登京口北固亭有怀</h3><p>辛弃疾<br>何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。</p>
<p>年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。</p>
<h3 id="青玉案·元夕"><a href="#青玉案·元夕" class="headerlink" title="青玉案·元夕"></a>青玉案·元夕</h3><p>辛弃疾<br>东风夜放花千树。更吹落、星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。</p>
<p>蛾儿雪柳黄金缕。笑语盈盈暗香去。众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。</p>
<h3 id="菩萨蛮·书江西造口壁"><a href="#菩萨蛮·书江西造口壁" class="headerlink" title="菩萨蛮·书江西造口壁"></a>菩萨蛮·书江西造口壁</h3><p>辛弃疾<br>郁孤台下清江水，中间多少行人泪。西北望长安，可怜无数山。</p>
<p>青山遮不住，毕竟东流去。江晚正愁余，山深闻鹧鸪。</p>
<h3 id="破阵子·为陈同甫赋壮词以寄之"><a href="#破阵子·为陈同甫赋壮词以寄之" class="headerlink" title="破阵子·为陈同甫赋壮词以寄之"></a>破阵子·为陈同甫赋壮词以寄之</h3><p>辛弃疾<br>醉里挑灯看剑，梦回吹角连营。八百里分麾下炙，五十弦翻塞外声。沙场秋点兵。</p>
<p>马作的卢飞快，弓如霹雳弦惊。了却君王天下事，赢得生前身后名。可怜白发生！</p>
<h3 id="太常引·建康中秋夜为吕叔潜赋"><a href="#太常引·建康中秋夜为吕叔潜赋" class="headerlink" title="太常引·建康中秋夜为吕叔潜赋"></a>太常引·建康中秋夜为吕叔潜赋</h3><p>辛弃疾<br>一轮秋影转金波，飞镜又重磨。把酒问姮娥：被白发、欺人奈何？</p>
<p>乘风好去，长空万里，直下看山河。斫去桂婆娑，人道是、清光更多。</p>
<h3 id="西江月·遣兴"><a href="#西江月·遣兴" class="headerlink" title="西江月·遣兴"></a>西江月·遣兴</h3><p>辛弃疾<br>醉里且贪欢笑，要愁那得工夫。</p>
<p>近来始觉古人书。信著全无是处。</p>
<p>昨夜松边醉倒，问松我醉何如。</p>
<p>只疑松动要来扶。以手推松曰去。</p>
<h3 id="清平乐·独宿博山王氏庵"><a href="#清平乐·独宿博山王氏庵" class="headerlink" title="清平乐·独宿博山王氏庵"></a>清平乐·独宿博山王氏庵</h3><p>辛弃疾<br>绕床饥鼠，蝙蝠翻灯舞。屋上松风吹急雨，破纸窗间自语。</p>
<p>平生塞北江南，归来华发苍颜。布被秋宵梦觉，眼前万里江山。</p>
<h3 id="西江月·夜行黄沙道中"><a href="#西江月·夜行黄沙道中" class="headerlink" title="西江月·夜行黄沙道中"></a>西江月·夜行黄沙道中</h3><p>辛弃疾<br>明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。</p>
<p>七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。</p>
<h3 id="贺新郎·别茂嘉十二弟"><a href="#贺新郎·别茂嘉十二弟" class="headerlink" title="贺新郎·别茂嘉十二弟"></a>贺新郎·别茂嘉十二弟</h3><p>辛弃疾<br>别茂嘉十二弟。鹈鴂、杜鹃实两种，见《离骚补注》</p>
<p>绿树听鹈鴂。更那堪、鹧鸪声住，杜鹃声切。啼到春归无寻处，苦恨芳菲都歇。算未抵、人间离别。马上琵琶关塞黑，更长门、翠辇辞金阙。看燕燕，送归妾。</p>
<p>将军百战身名裂。向河梁、回头万里，故人长绝。易水萧萧西风冷，满座衣冠似雪。正壮士、悲歌未彻。啼鸟还知如许恨，料不啼清泪长啼血。谁共我，醉明月。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>辛弃疾</tag>
      </tags>
  </entry>
  <entry>
    <title>宋词-李清照.md</title>
    <url>/2020/02/03/%E6%9D%8E%E6%B8%85%E7%85%A7/</url>
    <content><![CDATA[<h3 id="一剪梅·红藕香残玉簟秋"><a href="#一剪梅·红藕香残玉簟秋" class="headerlink" title="一剪梅·红藕香残玉簟秋"></a>一剪梅·红藕香残玉簟秋</h3><p>李清照<br>红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。</p>
<p>花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。</p>
<h3 id="如梦令·常记溪亭日暮"><a href="#如梦令·常记溪亭日暮" class="headerlink" title="如梦令·常记溪亭日暮"></a>如梦令·常记溪亭日暮</h3><p>李清照<br>常记溪亭日暮，沉醉不知归路。</p>
<p>兴尽晚回舟，误入藕花深处。</p>
<p>争渡，争渡，惊起一滩鸥鹭。</p>
<h3 id="如梦令·昨夜雨疏风骤"><a href="#如梦令·昨夜雨疏风骤" class="headerlink" title="如梦令·昨夜雨疏风骤"></a>如梦令·昨夜雨疏风骤</h3><p>李清照<br>昨夜雨疏风骤，浓睡不消残酒。</p>
<p>试问卷帘人，却道海棠依旧。</p>
<p>知否，知否？应是绿肥红瘦。</p>
<h3 id="醉花阴·薄雾浓云愁永昼"><a href="#醉花阴·薄雾浓云愁永昼" class="headerlink" title="醉花阴·薄雾浓云愁永昼"></a>醉花阴·薄雾浓云愁永昼</h3><p>李清照<br>薄雾浓云愁永昼，瑞脑消金兽。佳节又重阳，玉枕纱橱，半夜凉初透。</p>
<p>东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。</p>
<h3 id="南歌子·天上星河转"><a href="#南歌子·天上星河转" class="headerlink" title="南歌子·天上星河转"></a>南歌子·天上星河转</h3><p>李清照<br>天上星河转，人间帘幕垂。凉生枕簟泪痕滋。起解罗衣聊问、夜何其。</p>
<p>翠贴莲蓬小，金销藕叶稀。旧时天气旧时衣。只有情怀不似、旧家时。</p>
<h3 id="点绛唇·蹴罢秋千"><a href="#点绛唇·蹴罢秋千" class="headerlink" title="点绛唇·蹴罢秋千"></a>点绛唇·蹴罢秋千</h3><p>李清照<br>蹴罢秋千，起来慵整纤纤手。露浓花瘦，薄汗轻衣透。</p>
<p>见客入来，袜刬金钗溜。和羞走，倚门回首，却把青梅嗅。</p>
<h3 id="清平乐·年年雪里"><a href="#清平乐·年年雪里" class="headerlink" title="清平乐·年年雪里"></a>清平乐·年年雪里</h3><p>李清照<br>年年雪里，常插梅花醉。挼尽梅花无好意，赢得满衣清泪。</p>
<p>今年海角天涯，萧萧两鬓生华。看取晚来风势，故应难看梅花。</p>
<h3 id="武陵春·春晚"><a href="#武陵春·春晚" class="headerlink" title="武陵春·春晚"></a>武陵春·春晚</h3><p>李清照<br>风住尘香花已尽，日晚倦梳头。物是人非事事休，欲语泪先流。</p>
<p>闻说双溪春尚好，也拟泛轻舟。只恐双溪舴艋舟，载不动许多愁。</p>
<h3 id="声声慢·寻寻觅觅"><a href="#声声慢·寻寻觅觅" class="headerlink" title="声声慢·寻寻觅觅"></a>声声慢·寻寻觅觅</h3><p>李清照<br>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急？雁过也，正伤心，却是旧时相识。</p>
<p>满地黄花堆积。憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑？梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>李清照</tag>
      </tags>
  </entry>
</search>
